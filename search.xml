<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[nginx 操作]]></title>
    <url>%2Fnginx%2Fck9bgz7wx008mqov79klvl03c.html</url>
    <content type="text"><![CDATA[第 1 章 Nginx 简介1.1 Nginx 概述Nginx (“engine x”) 是一个高性能的 HTTP 和反向代理服务器，特点是占有内存少，并发能力强，事实上 nginx 的并发能力确实在同类型的网页服务器中表现较好，中国大陆使用 nginx网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。 https://lnmp.org/nginx.html 1.2 Nginx 作为 web 服务器Nginx 可以作为静态页面的 web 服务器，同时还支持 CGI 协议的动态语言，比如 perl、 php等。但是不支持 java。 Java 程序只能通过与 tomcat 配合完成。 Nginx 专为性能优化而开发，性能是其最重要的考量，实现上非常注重效率 ，能经受高负载的考验，有报告表明能支持高达 50,000 个并发连接数。 1.3 正向代理如果把局域网外的 Internet 想象成一个巨大的资源库，则局域网中的客户端要访问 Internet，则需要通过代理服务器来访问，这种代理服务就称为正向代理 1.4 反向代理反向代理，其实客户端对代理是无感知的，因为客户端不需要任何配置就可以访问，我们只需要将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据后，在返回给客户端，此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器地址，隐藏了真实服务器 IP 地址 。 1.5 负载均衡客户端发送多个请求到服务器，服务器处理请求，有一些可能要与数据库进行交互，服务器处理完毕后，再将结果返回给客户端。这种架构模式对于早期的系统相对单一，并发请求相对较少的情况下是比较适合的，成本也低。但是随着信息数量的不断增长，访问量和数据量的飞速增长，以及系统业务的复杂度增加，这种架构会造成服务器相应客户端的请求日益缓慢，并发量特别大的时候，还容易造成服务器直接崩溃。很明显这是由于服务器性能的瓶颈造成的问题，那么如何解决这种情况呢？ 我们首先想到的可能是升级服务器的配置，比如提高 CPU 执行频率，加大内存等提高机器的物理性能来解决此问题，但是我们知道摩尔定律的日益失效，硬件的性能提升已经不能满足日益提升的需求了。最明显的一个例子，天猫双十一当天，某个热销商品的瞬时访问量是极其庞大的，那么类似上面的系统架构，将机器都增加到现有的顶级物理配置，都是不能够满足需求的。那么怎么办呢？上面的分析我们去掉了增加服务器物理配置来解决问题的办法，也就是说纵向解决问题的办法行不通了，那么横向增加服务器的数量呢？ 这时候集群的概念产生了，单个服务器解决不了，我们增加服务器的数量，然后将请求分发到各个服务器上，将原先请求集中到单个 服务器上的情况改为将请求分发到多个服务器上，将负载分发到不同的服务器，也就是我们所说的负载均衡。 1.6 动静分离为了加快网站的解析速度，可以把动态页面和静态页面由不同的服务器来解析，加快解析速度。降低原来单个服务器的压力。 第 2 章 Nginx 安装2.1 下载 地址http://nginx.org/ 2.2 安装 nginx 安装依赖 pcre-8.32-17.el7.x86_64 openssl-1.0.2k-19.el7.x86_64 zlib-1.2.7-18.el7.x86_64 12wget http://downloads.sourceforge.net/project/pcre/pcre/8.37/pcre-8.37.tar.gzwget http://nginx.org/download/nginx-1.12.2.tar.gz 1yum -y install make zlib zlib-devel gcc-c++ libtool openssl openssl-devel 安装nginx 解压缩 nginx-xx.tar.gz 包。 进入解压缩目录， 执行./configure。 make &amp;&amp; make install 查看开放的端口号firewall-cmd –list-all 设置开放的端口号firewall-cmd –add-service=http –permanentsudo firewall-cmd –add-port=80/tcp –permanent 重启防火墙firewall-cmd –reload 第 3 章 nginx 常用的命令和配置文件3.1 nginx 常用的命令 查看帮助文档 12345678910111213141516[root@hadoop01 software]# cd /usr/local/nginx/[root@hadoop01 nginx]# ./sbin/nginx -hnginx version: nginx/1.12.2Usage: nginx [-?hvVtTq] [-s signal] [-c filename] [-p prefix] [-g directives]Options: -?,-h : this help -v : show version and exit -V : show version and configure options then exit -t : test configuration and exit -T : test configuration, dump it and exit -q : suppress non-error messages during configuration testing -s signal : send signal to a master process: stop, quit, reopen, reload -p prefix : set prefix path (default: /usr/local/nginx/) -c filename : set configuration file (default: conf/nginx.conf) -g directives : set global directives out of configuration file 启动命令 在/usr/local/nginx/sbin 目录下执行 ./nginx 关闭命令在/usr/local/nginx/sbin 目录下执行 ./nginx -s stop 重新加载命令在/usr/local/nginx/sbin 目录下执行 ./nginx -s reload 3.2 nginx.conf 配置文件nginx 安装目录下，其默认的配置文件都放在这个目录的 conf 目录下，而主配置文件nginx.conf 也在其中，后续对 nginx 的使用基本上都是对此配置文件进行相应的修改 。 12345678910111213141516171819202122[root@hadoop01 nginx]# lsclient_body_temp conf fastcgi_temp html logs proxy_temp sbin scgi_temp uwsgi_temp[root@hadoop01 nginx]# tree conf/conf/├── fastcgi.conf├── fastcgi.conf.default├── fastcgi_params├── fastcgi_params.default├── koi-utf├── koi-win├── mime.types├── mime.types.default├── nginx.conf├── nginx.conf.default├── scgi_params├── scgi_params.default├── uwsgi_params├── uwsgi_params.default└── win-utf0 directories, 15 files[root@hadoop01 nginx]# nginx.conf 配置文件分为三部分 : 第一部分：全局块 从配置文件开始到 events 块之间的内容，主要会设置一些影响 nginx 服务器整体运行的配置指令，主要包括配置运行 Nginx 服务器的用户（组）、允许生成的 worker process 数， 进程 PID 存放路径、日志存放路径和类型以及配置文件的引入等。 这是 Nginx 服务器并发处理服务的关键配置， worker_processes 值越大，可以支持的并发处理量也越多，但是会受到硬件、软件等设备的制约 。 第二部分： events 块 events 块涉及的指令主要影响 Nginx 服务器与用户的网络连接，常用的设置包括是否开启对多 work process下的网络连接进行序列化，是否允许同时接收多个网络连接，选取哪种事件驱动模型来处理连接请求，每个 word process 可以同时支持的最大连接数等。 这部分的配置对 Nginx 的性能影响较大，在实际中应该灵活配置。 第三部分： http 块 这算是 Nginx 服务器配置中最频繁的部分，代理、缓存和日志定义等绝大多数功能和第三方模块的配置都在这里。需要注意的是： http 块也可以包括 http 全局块、 server 块。 http 全局块 http 全局块配置的指令包括文件引入、 MIME-TYPE 定义、日志自定义、连接超时时间、单链接请求数上限等。 server 块 这块和虚拟主机有密切关系，虚拟主机从用户角度看，和一台独立的硬件主机是完全一样的，该技术的产生是为了节省互联网服务器硬件成本。每个 http 块可以包括多个 server 块，而每个 server 块就相当于一个虚拟主机。每个 server 块也分为全局 server 块，以及可以同时包含多个 locaton 块。 全局 server 块最常见的配置是本虚拟机主机的监听配置和本虚拟主机的名称或 IP 配置。 location 块一个 server 块可以配置多个 location 块。这块的主要作用是基于 Nginx 服务器接收到的请求字符串（例如 server_name/uri-string），对虚拟主机名称（也可以是 IP 别名）之外的字符串（例如 前面的 /uri-string）进行匹配，对特定的请求进行处理。地址定向、数据缓存和应答控制等功能，还有许多第三方模块的配置也在这里进行。 第 4 章 nginx 配置实例-反向代理4.1 反向代理实例一实现效果使用 nginx 反向代理，访问 www.spark.com 直接跳转到spark页面（192.168.100.10:8080） 准备工作 启动spark 12345678910# 进入SPARK_HOME[root@hadoop01 ~]# cd /opt/spark-2.4.4-bin-hadoop2.7/[root@hadoop01 spark-2.4.4-bin-hadoop2.7]# ./sbin/start-all.shstarting org.apache.spark.deploy.master.Master, logging to /opt/spark-2.4.4-bin-hadoop2.7/logs/spark-root-org.apache.spark.deploy.master.Master-1-hadoop01.outlocalhost: starting org.apache.spark.deploy.worker.Worker, logging to /opt/spark-2.4.4-bin-hadoop2.7/logs/spark-root-org.apache.spark.deploy.worker.Worker-1-hadoop01.out[root@hadoop01 spark-2.4.4-bin-hadoop2.7]# jps9302 Worker9336 Jps9209 Master[root@hadoop01 spark-2.4.4-bin-hadoop2.7]# 注：通过http://192.168.100.10:8080/可在浏览器进行登陆，如果登陆不上，查看端口是否开放。 查看端口开放命令：firewall-cmd –query-port=8080/tcp开放端口命令：firewall-cmd –zone=public –add-port=8080/tcp –permanent 重启firewall：firewall-cmd –reload window配置hosts文件，进行域名与IP的映射 路径：C:\Windows\System32\drivers\etc\hosts 添加：192.168.100.10 www.spark.com 注：通过http://www.spark.com:8080/在浏览器中登陆验证，看域名映射是否生效 修改nginx.conf文件， 进行请求转发的配置（反向代理配置） 123456789101112131415server &#123; listen 80; server_name 192.168.100.10; location / &#123; root html; proxy_pass http://192.168.100.10:8080; index index.html index.htm; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125;&#125; 修改http块中的server块： ​ server_name修改为所在主机的IP ​ 在location中添加proxy_pass http://192.168.100.10:8080; ​ 注意末尾分号 验证在浏览器中输入http://www.spark.com/，看其是否可以跳转至spark页面 4.2 反向代理实例二实现效果使用 nginx 反向代理， 根据访问的路径跳转到不同端口的服务中nginx 监听端口为 9001，访问 http://192.168.100.10:9001/index_80 直接跳转到127.0.0.0:8000/index_80访问 http://192.168.100.10:9001/index_81 直接跳转到127.0.0.0:8001/index_81 准备工作 启动两个模拟端口(用flask启动) 1234# dir tree├── app.py└── templates └── index.html 8000端口 ./app.py内容： 123456789101112131415from flask import Flaskfrom flask import render_template, redirectapp = Flask(__name__, static_url_path='')@app.route('/')def hello_world(): return 'Hello World!'@app.route("/index_80")def index(): return render_template("index.html")if __name__ == '__main__': app.run() ./templates/index.html内容： 12345678&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;8001...&lt;/body&gt;&lt;/html&gt; 启动项目： python -m flask run -p 8000 8001端口./app.py内容： 123456789101112131415from flask import Flaskfrom flask import render_template, redirectapp = Flask(__name__, static_url_path='')@app.route('/')def hello_world(): return 'Hello World!'@app.route("/index_81")def index(): return render_template("index.html")if __name__ == '__main__': app.run() ./templates/index.html内容： 12345678&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;8001...&lt;/body&gt;&lt;/html&gt; 启动项目： python -m flask run -p 8001 修改nginx.conf文件， 进行请求转发的配置（反向代理配置） 12345678910 server &#123; listen 9001; server_name 192.168.100.10; location ~ /index_80 &#123; proxy_pass http://localhost:8000; &#125; location ~ /index_81 &#123; proxy_pass http://localhost:8001; &#125;&#125; 验证在浏览器中输入 http://192.168.100.10:9001/index_80和 http://192.168.100.10:9001/index_81进行验证 location 指令说明该指令用于匹配 URL，语法如下： 123location [= | ~ | ~* | ^~] url &#123; ...&#125; 说明： = ：用于不含正则表达式的 uri 前，要求请求字符串与 uri 严格匹配，如果匹配成功，就停止继续向下搜索并立即处理该请求。 ~：用于表示 uri 包含正则表达式，并且区分大小写。 ~*：用于表示 uri 包含正则表达式，并且不区分大小写。 ^~：用于不含正则表达式的 uri 前，要求 Nginx 服务器找到标识 uri 和请求字符串匹配度最高的 location 后，立即使用此 location 处理请求，而不再使用 location块中的正则 uri 和请求字符串做匹配。 注意：如果 uri 包含正则表达式，则必须要有 ~ 或者 ~* 标识。 第 5 章 nginx 配置实例-负载均衡随着互联网信息的爆炸性增长，负载均衡（load balance）已经不再是一个很陌生的话题，顾名思义，负载均衡即是将负载分摊到不同的服务单元，既保证服务的可用性，又保证响应足够快，给用户很好的体验。快速增长的访问量和数据流量催生了各式各样的负载均衡产品，很多专业的负载均衡硬件提供了很好的功能，但却价格不菲，这使得负载均衡软件大受欢迎，nginx 就是其中的一个，在 linux 下有 Nginx、 LVS、 Haproxy 等等服务可以提供负载均衡服务，而且 Nginx 提供了几种分配方式(策略)： 轮询（默认）每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器 down 掉，能自动剔除。 weightweight 代表权,重默认为 1,权重越高被分配的客户端越多指定轮询几率， weight 和访问比率成正比，用于后端服务器性能不均的情况。 例如： 1234upstream server_pool&#123; server 192.168.5.21 weight=10; server 192.168.5.22 weight=10;&#125; ip_hash每个请求按访问 ip 的 hash 结果分配，这样每个访客固定访问一个后端服务器，可以解决 session 的问题。 例如： 12345upstream server_pool&#123; ip_hash; server 192.168.5.21:80; server 192.168.5.22:80;&#125; fair（第三方）按后端服务器的响应时间来分配请求，响应时间短的优先分配。 12345upstream server_pool&#123; server 192.168.5.21:80; server 192.168.5.22:80; fair;&#125; 5.1 示例实现效果页面输入http://192.168.100.10/index，实现负载均衡，转发在8000和8001端口中。 准备工作 启动两个测试端口 访问 http://192.168.100.10:8000/index，响应内容是`我是8000端口`访问 http://192.168.100.10:8001/index，响应内容是`我是8001端口` 修改nginx.conf文件， 进行请求转发的配置（负载均衡配置） 123456789101112upstream myserver &#123; server localhost:8000; server localhost:8001; &#125;server &#123; listen 8500; server_name 192.168.100.10; location = /index &#123; proxy_pass http://myserver; &#125;&#125; 第6 章 nginx 配置实例-动静分离Nginx 动静分离简单来说就是把动态跟静态请求分开，不能理解成只是单纯的把动态页面和静态页面物理分离。严格意义上说应该是动态请求跟静态请求分开，可以理解成使用 Nginx处理静态页面， Tomcat 处理动态页面。动静分离从目前实现角度来讲大致分为两种： 一种是纯粹把静态文件独立成单独的域名，放在独立的服务器上，也是目前主流推崇的方案； 另外一种方法就是动态跟静态文件混合在一起发布，通过 nginx 来分开。通过 location 指定不同的后缀名实现不同的请求转发。通过 expires 参数设置，可以使浏览器缓存过期时间，减少与服务器之前的请求和流量。具体 Expires 定义：是给一个资源设定一个过期时间，也就是说无需去服务端验证，直接通过浏览器自身确认是否过期即可，所以不会产生额外的流量。此种方法非常适合不经常变动的资源。（如果经常更新的文件，不建议使用 Expires 来缓存），我这里设置 3d，表示在这 3 天之内访问这个 URL，发送一个请求，比对服务器该文件最后更新时间没有变化，则不会从服务器抓取，返回状态码304，如果有修改，则直接从服务器重新下载，返回状态码 200。 123456789location /www/ &#123; root /opt/project/; index index.html index.htm;&#125;location /images/ &#123; root /opt/project/; # 指向服务器的路径 autoindex on;&#125; 第 7 章 nginx 原理与优化参数配置 master-workers 的机制的好处首先，对于每个 worker 进程来说，独立的进程，不需要加锁，所以省掉了锁带来的开销，同时在编程以及问题查找时，也会方便很多。其次，采用独立的进程，可以让互相之间不会影响，一个进程退出后，其它进程还在工作，服务不会中断， master 进程则很快启动新的worker 进程。当然， worker 进程的异常退出，肯定是程序有 bug 了，异常退出，会导致当前 worker 上的所有请求失败，不过不会影响到所有请求，所以降低了风险。 需要设置多少个 workerNginx 同 redis 类似都采用了 io 多路复用机制，每个 worker 都是一个独立的进程，但每个进程里只有一个主线程，通过异步非阻塞的方式来处理请求， 即使是成千上万个请求也不在话下。每个 worker 的线程可以把一个 cpu 的性能发挥到极致。所以 worker 数和服务器的 cpu数相等是最为适宜的。设少了会浪费 cpu，设多了会造成 cpu 频繁切换上下文带来的损耗。 #设置 worker 数量。worker_processes 4 #work 绑定 cpu(4 work 绑定 4cpu)。worker_cpu_affinity 0001 0010 0100 1000 #work 绑定 cpu (4 work 绑定 8cpu 中的 4 个) 。worker_cpu_affinity 0000001 00000010 00000100 00001000 连接数 worker_connection这个值是表示每个 worker 进程所能建立连接的最大值，所以，一个 nginx 能建立的最大连接数，应该是 worker_connections * worker_processes。当然，这里说的是最大连接数，对于HTTP 请 求 本 地 资 源 来 说 ， 能 够 支 持 的 最 大 并 发 数 量 是 worker_connections * worker_processes，如果是支持 http1.1 的浏览器每次访问要占两个连接，所以普通的静态访问最大并发数是： worker_connections * worker_processes /2，而如果是 HTTP 作 为反向代理来说，最大并发数量应该是 worker_connections * worker_processes / 4。因为作为反向代理服务器，每个并发会建立与客户端的连接和与后端服务的连接，会占用两个连接。]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python functools module]]></title>
    <url>%2Fpython%2Fmodule%2Fck9bgz84r00euqov7urj6rcq4.html</url>
    <content type="text"><![CDATA[functools 模块应用于高阶函数，此模块的功能适用于所有可调用对象。 源代码: Lib/functools.py functools.cmp_to_key(func)比较函数意为一个可调用对象，该对象接受两个参数并比较它们，结果为小于则返回一个负数，相等则返回零，大于则返回一个正数。key function则是一个接受一个参数，并返回另一个用以排序的值的可调用对象。 示例: 1sorted(iterable, key=cmp_to_key(locale.strcoll)) # locale-aware sort order 注：将代码从 Python 2.x 移植到 3.x 时，如果用户提供比较功能并且需要将其转换为键函数，则会出现这种情况。 以下包装器使这很容易： 123456789101112131415161718def cmp_to_key(mycmp): &apos;Convert a cmp= function into a key= function&apos; class K: def __init__(self, obj, *args): self.obj = obj def __lt__(self, other): return mycmp(self.obj, other.obj) &lt; 0 def __gt__(self, other): return mycmp(self.obj, other.obj) &gt; 0 def __eq__(self, other): return mycmp(self.obj, other.obj) == 0 def __le__(self, other): return mycmp(self.obj, other.obj) &lt;= 0 def __ge__(self, other): return mycmp(self.obj, other.obj) &gt;= 0 def __ne__(self, other): return mycmp(self.obj, other.obj) != 0 return K 要转换为键函数，只需包装旧的比较函数： 12&gt;&gt;&gt; sorted([5, 2, 4, 1, 3], key=cmp_to_key(reverse_numeric))[5, 4, 3, 2, 1] 在 Python 3.2 中， functools.cmp_to_key() 函数被添加到标准库中的 functools 模块中。 @functools.lru_cache(maxsize=128, typed=False)一个为函数提供缓存功能的装饰器，缓存 maxsize 组传入参数，在下次以相同参数调用时直接返回上一次的结果。用以节约高开销或I/O函数的调用时间。 由于使用了字典存储缓存，所以该函数的固定参数和关键字参数必须是可哈希的。 不同模式的参数可能被视为不同从而产生多个缓存项，例如, f(a=1, b=2) 和 f(b=2, a=1) 因其参数顺序不同，可能会被缓存两次。 如果 maxsize 设置为 None ，LRU功能将被禁用且缓存数量无上限。 maxsize 设置为2的幂时可获得最佳性能。 如果 typed 设置为true，不同类型的函数参数将被分别缓存。例如， f(3) 和 f(3.0) 将被视为不同而分别缓存。 为了衡量缓存的有效性以便调整 maxsize 形参，被装饰的函数带有一个 cache_info() 函数。当调用 cache_info() 函数时，返回一个具名元组，包含命中次数 hits*，未命中次数 *misses ，最大缓存数量 maxsize 和 当前缓存大小 currsize。在多线程环境中，命中数与未命中数是不完全准确的。 该装饰器也提供了一个用于清理/使缓存失效的函数 cache_clear() 。 原始的未经装饰的函数可以通过 __wrapped__ 属性访问。它可以用于检查、绕过缓存，或使用不同的缓存再次装饰原始函数。 “最久未使用算法”（LRU）缓存 在“最近的调用是即将到来的调用的最佳预测因子”时性能最好（比如，新闻服务器上最受欢迎的文章倾向于每天更改）。 “缓存大小限制”参数保证缓存不会在长时间运行的进程比如说网站服务器上无限制的增加自身的大小。 一般来说，LRU缓存只在当你想要重用之前计算的结果时使用。因此，用它缓存具有副作用的函数、需要在每次调用时创建不同、易变的对象的函数或者诸如time（）或random（）之类的不纯函数是没有意义的。 静态 Web 内容的 LRU 缓存示例: 12345678910111213141516@lru_cache(maxsize=32)def get_pep(num): &apos;Retrieve text of a Python Enhancement Proposal&apos; resource = &apos;http://www.python.org/dev/peps/pep-%04d/&apos; % num try: with urllib.request.urlopen(resource) as s: return s.read() except urllib.error.HTTPError: return &apos;Not Found&apos;&gt;&gt;&gt; for n in 8, 290, 308, 320, 8, 218, 320, 279, 289, 320, 9991:... pep = get_pep(n)... print(n, len(pep))&gt;&gt;&gt; get_pep.cache_info()CacheInfo(hits=3, misses=8, maxsize=32, currsize=8) 以下是使用缓存通过 动态规划 计算 斐波那契数列 的例子。 1234567891011@lru_cache(maxsize=None)def fib(n): if n &lt; 2: return n return fib(n-1) + fib(n-2)&gt;&gt;&gt; [fib(n) for n in range(16)][0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610]&gt;&gt;&gt; fib.cache_info()CacheInfo(hits=28, misses=16, maxsize=None, currsize=16) @functools.total_ordering给定一个声明一个或多个全比较排序方法的类，这个类装饰器实现剩余的方法。这减轻了指定所有可能的全比较操作的工作。 此类必须包含以下方法之一：__lt__() 、__le__()、__gt__() 或 __ge__()。另外，此类必须支持 __eq__() 方法。 123456789101112131415@total_orderingclass Student: def _is_valid_operand(self, other): return (hasattr(other, &quot;lastname&quot;) and hasattr(other, &quot;firstname&quot;)) def __eq__(self, other): if not self._is_valid_operand(other): return NotImplemented return ((self.lastname.lower(), self.firstname.lower()) == (other.lastname.lower(), other.firstname.lower())) def __lt__(self, other): if not self._is_valid_operand(other): return NotImplemented return ((self.lastname.lower(), self.firstname.lower()) &lt; (other.lastname.lower(), other.firstname.lower())) 注:虽然此装饰器使得创建具有良好行为的完全有序类型变得非常容易，但它 确实 是以执行速度更缓慢和派生比较方法的堆栈回溯更复杂为代价的。 如果性能基准测试表明这是特定应用的瓶颈所在，则改为实现全部六个富比较方法应该会轻松提升速度。 functools.partial(func, args, *keywords)返回一个新的 部分对象，当被调用时其行为类似于 func 附带位置参数 args 和关键字参数 keywords 被调用。 如果为调用提供了更多的参数，它们会被附加到 args。 如果提供了额外的关键字参数，它们会扩展并重载 keywords。 大致等价于: 123456789def partial(func, *args, **keywords): def newfunc(*fargs, **fkeywords): newkeywords = keywords.copy() newkeywords.update(fkeywords) return func(*args, *fargs, **newkeywords) newfunc.func = func newfunc.args = args newfunc.keywords = keywords return newfunc partial() 会被“冻结了”一部分函数参数和/或关键字的部分函数应用所使用，从而得到一个具有简化签名的新对象。 例如，partial() 可用来创建一个行为类似于 int() 函数的可调用对象，其中 base 参数默认为二： 12345&gt;&gt;&gt; from functools import partial&gt;&gt;&gt; basetwo = partial(int, base=2)&gt;&gt;&gt; basetwo.__doc__ = &apos;Convert base 2 string to an int.&apos;&gt;&gt;&gt; basetwo(&apos;10010&apos;)18 class functools.partialmethod(func, args, *keywords)返回一个新的 partialmethod 描述器，其行为类似 partial 但它被设计用作方法定义而非直接用作可调用对象。 func 必须是一个 descriptor 或可调用对象（同属两者的对象例如普通函数会被当作描述器来处理）。 当 func 是一个描述器（例如普通 Python 函数, classmethod(), staticmethod(), abstractmethod() 或其他 partialmethod 的实例）时, 对 get 的调用会被委托给底层的描述器，并会返回一个适当的 部分对象 作为结果。 当 func 是一个非描述器类可调用对象时，则会动态创建一个适当的绑定方法。 当用作方法时其行为类似普通 Python 函数：将会插入 self 参数作为第一个位置参数，其位置甚至会处于提供给 partialmethod 构造器的 args 和 keywords 之前。 示例: 1234567891011121314151617&gt;&gt;&gt; class Cell(object):... def __init__(self):... self._alive = False... @property... def alive(self):... return self._alive... def set_state(self, state):... self._alive = bool(state)... set_alive = partialmethod(set_state, True)... set_dead = partialmethod(set_state, False)...&gt;&gt;&gt; c = Cell()&gt;&gt;&gt; c.aliveFalse&gt;&gt;&gt; c.set_alive()&gt;&gt;&gt; c.aliveTrue functools.reduce(function, iterable[, initializer])将两个参数的 function 从左至右累积地应用到 sequence 的条目，以便将该序列缩减为单一值。 例如，reduce(lambda x, y: x+y, [1, 2, 3, 4, 5]) 是计算 ((((1+2)+3)+4)+5) 的值。 左边的参数 x 是累积值而右边的参数 y 则是来自 sequence 的更新值。 如果存在可选项 initializer，它会被放在参与计算的序列的条目之前，并在序列对象为空时作为默认值。 如果没有给出 initializer 并且 sequence 仅包含一个条目，则将返回第一项。 大致相当于： 12345678def reduce(function, iterable, initializer=None): it = iter(iterable) if initializer is None: value = next(it) else: value = initializer for element in it: value = fu @functools.singledispatch将一个函数转换为 单分派 generic function。 要定义一个泛型函数，应使用 @singledispatch 装饰器进行装饰。 请注意分派是作用于第一个参数的类型，要相应地创建你的函数: 123456&gt;&gt;&gt; from functools import singledispatch&gt;&gt;&gt; @singledispatch... def fun(arg, verbose=False):... if verbose:... print(&quot;Let me just say,&quot;, end=&quot; &quot;)... print(arg) 要将重载的实现添加到函数中，请使用泛型函数的 register() 属性。 它是一个装饰器。 对于带有类型标注的函数，该装饰器将自动推断第一个参数的类型: 123456789101112&gt;&gt;&gt; @fun.register... def _(arg: int, verbose=False):... if verbose:... print(&quot;Strength in numbers, eh?&quot;, end=&quot; &quot;)... print(arg)...&gt;&gt;&gt; @fun.register... def _(arg: list, verbose=False):... if verbose:... print(&quot;Enumerate this:&quot;)... for i, elem in enumerate(arg):... print(i, elem) 对于不使用类型标注的代码，可以将适当的类型参数显式地传给装饰器本身: 123456&gt;&gt;&gt; @fun.register(complex)... def _(arg, verbose=False):... if verbose:... print(&quot;Better than complicated.&quot;, end=&quot; &quot;)... print(arg.real, arg.imag)... 要启用注册 lambda 和现有函数，可以使用函数形式的 register() 属性: 1234&gt;&gt;&gt; def nothing(arg, verbose=False):... print(&quot;Nothing.&quot;)...&gt;&gt;&gt; fun.register(type(None), nothing) register() 属性将返回启用了装饰器堆栈、封存的未装饰函数，并会为每个变量单独创建单元测试: 123456789&gt;&gt;&gt; @fun.register(float)... @fun.register(Decimal)... def fun_num(arg, verbose=False):... if verbose:... print(&quot;Half of your number:&quot;, end=&quot; &quot;)... print(arg / 2)...&gt;&gt;&gt; fun_num is funFalse 在调用时，泛型函数会根据第一个参数的类型进行分派: 12345678910111213141516&gt;&gt;&gt; fun(&quot;Hello, world.&quot;)Hello, world.&gt;&gt;&gt; fun(&quot;test.&quot;, verbose=True)Let me just say, test.&gt;&gt;&gt; fun(42, verbose=True)Strength in numbers, eh? 42&gt;&gt;&gt; fun([&apos;spam&apos;, &apos;spam&apos;, &apos;eggs&apos;, &apos;spam&apos;], verbose=True)Enumerate this:0 spam1 spam2 eggs3 spam&gt;&gt;&gt; fun(None)Nothing.&gt;&gt;&gt; fun(1.23)0.615 在没有用于特定类型的已注册实现的情况下，则会使用其方法解析顺序来查找更通用的实现。 以 @singledispatch 装饰的原始函数将为最基本的 object 类型进行注册，这意味着它将在找不到更好的实现时被使用。 要检查泛型函数将为给定类型选择哪个实现，请使用 dispatch() 属性: 1234&gt;&gt;&gt; fun.dispatch(float)&lt;function fun_num at 0x1035a2840&gt;&gt;&gt;&gt; fun.dispatch(dict) # note: default implementation&lt;function fun at 0x103fe0000&gt; 要访问所有忆注册实现，请使用只读的 registry 属性: 12345678&gt;&gt;&gt; fun.registry.keys()dict_keys([&lt;class &apos;NoneType&apos;&gt;, &lt;class &apos;int&apos;&gt;, &lt;class &apos;object&apos;&gt;, &lt;class &apos;decimal.Decimal&apos;&gt;, &lt;class &apos;list&apos;&gt;, &lt;class &apos;float&apos;&gt;])&gt;&gt;&gt; fun.registry[float]&lt;function fun_num at 0x1035a2840&gt;&gt;&gt;&gt; fun.registry[object]&lt;function fun at 0x103fe0000&gt; functools.update_wrapper(wrapper, wrapped, assigned=WRAPPER_ASSIGNMENTS, updated=WRAPPER_UPDATES)更新一个 wrapper 函数以使其类似于 wrapped 函数。 可选参数为指明原函数的哪些属性要直接被赋值给 wrapper 函数的匹配属性的元组，并且这些 wrapper 函数的属性将使用原函数的对应属性来更新。 这些参数的默认值是模块级常量 WRAPPER_ASSIGNMENTS (它将被赋值给 wrapper 函数的 module, name, qualname, annotations 和 doc 即文档字符串) 以及 WRAPPER_UPDATES (它将更新 wrapper 函数的 dict 即实例字典)。 为了允许出于内省和其他目的访问原始函数（例如绕过 lru_cache() 之类的缓存装饰器），此函数会自动为 wrapper 添加一个指向被包装函数的 wrapped 属性。 此函数的主要目的是在 decorator 函数中用来包装被装饰的函数并返回包装器。 如果包装器函数未被更新，则被返回函数的元数据将反映包装器定义而不是原始函数定义，这通常没有什么用处。 update_wrapper() 可以与函数之外的可调用对象一同使用。 在 assigned 或 updated 中命名的任何属性如果不存在于被包装对象则会被忽略（即该函数将不会尝试在包装器函数上设置它们）。 如果包装器函数自身缺少在 updated 中命名的任何属性则仍将引发 AttributeError。 @functools.wraps(wrapped, assigned=WRAPPER_ASSIGNMENTS, updated=WRAPPER_UPDATES)这是一个便捷函数，用于在定义包装器函数时发起调用 update_wrapper() 作为函数装饰器。 它等价于 partial(update_wrapper, wrapped=wrapped, assigned=assigned, updated=updated)。 例如: 12345678910111213141516171819&gt;&gt;&gt; def my_decorator(f):... @wraps(f)... def wrapper(*args, **kwds):... print(&apos;Calling decorated function&apos;)... return f(*args, **kwds)... return wrapper...&gt;&gt;&gt; @my_decorator... def example():... &quot;&quot;&quot;Docstring&quot;&quot;&quot;... print(&apos;Called example function&apos;)...&gt;&gt;&gt; example()Calling decorated functionCalled example function&gt;&gt;&gt; example.__name__&apos;example&apos;&gt;&gt;&gt; example.__doc__&apos;Docstring&apos; 如果不使用这个装饰器工厂函数，则 example 函数的名称将变为 &#39;wrapper&#39;，并且 example() 原本的文档字符串将会丢失。 partial 对象partial 对象是由 partial() 创建的可调用对象。 它们具有三个只读属性： partial.func一个可调用对象或函数。 对 partial 对象的调用将被转发给 func 并附带新的参数和关键字。 partial.args最左边的位置参数将放置在提供给 partial 对象调用的位置参数之前。 partial.keywords当调用 partial 对象时将要提供的关键字参数。 partial 对象与 function 对象的类似之处在于它们都是可调用、可弱引用的对象并可拥有属性。 但两者也存在一些重要的区别。 例如前者不会自动创建 __name__ 和 __doc__ 属性。 而且，在类中定义的 partial 对象的行为类似于静态方法，并且不会在实例属性查找期间转换为绑定方法。 参考https://docs.python.org/zh-cn/3.7/library/functools.html]]></content>
      <categories>
        <category>python</category>
        <category>module</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>module</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pycharm 配置pylint]]></title>
    <url>%2Fpython%2Fck9bgz7nr004xqov7ncboc8t5.html</url>
    <content type="text"><![CDATA[pylint是一个用于检查python代码中的错误，尝试强制执行编码标准的工具。它还可以查找某些类型错误，可以建议如何重构特定块的建议，并可以向您提供有关代码复杂性的详细信息。 安装Windows1pip install pylint # see note Ubuntu1sudo apt-get install pylint openSUSE12sudo zypper install pylint # python2.7sudo zypper install python3-pylint windows pycharm配置方法一 在 PyCharm 选择 Settings&gt; Plugins 搜索并安装Pylint 在 PyCharm 选择 Settings&gt;Pylint 选择并配置pylint.exe 文档：https://github.com/leinardi/pylint-pycharm 方法二PyCharm界面选择File -&gt; Settings -&gt; Tools -&gt; External Tools，点击“+”，设置的参数如下图所示： 1234Tool settingsProgram: E:\Python37\Scripts\pylint.exeParameters: -rn --msg-template=&quot;&#123;abspath&#125;:&#123;line&#125;: [&#123;msg_id&#125;(&#123;symbol&#125;), &#123;obj&#125;] &#123;msg&#125;&quot; $FilePath$Working directory: $FileDir$ 相关网址github: https://github.com/PyCQA/pylintdocument: http://pylint.pycqa.org/en/latest/ 官网：www.pylint.org/用户手册：https://pylint.readthedocs.io/en/latest/#note-for-windows-users]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>pycharm</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pyspark 学习笔记]]></title>
    <url>%2Fpython%2Fck9bgz7r3007uqov7a6lab2ac.html</url>
    <content type="text"><![CDATA[pypark用法记录。 配置环境变量 copy以下文件到python安装目录下的Lib\site-packages目录中 12&#123;SPARK_HOME&#125;\python\lib\py4j-0.10.7-src.zip&#123;SPARK_HOME&#125;\python\lib\pyspark.zip 解压上述文件到当前目录 pyspark shell12cd &#123;SPARK_HOME&#125;/bin./pyspark 统计示例 1234567891011121314151617Welcome to ____ __ / __/__ ___ _____/ /__ _\ \/ _ \/ _ `/ __/ &apos;_/ /__ / .__/\_,_/_/ /_/\_\ version 2.4.4 /_/Using Python version 3.7.1 (v3.7.1:260ec2c36a, Oct 20 2018 14:57:15)SparkSession available as &apos;spark&apos;.&gt;&gt;&gt; import random&gt;&gt;&gt; lst = random.choices(range(5), k=10)&gt;&gt;&gt; lst[1, 4, 3, 1, 4, 1, 2, 4, 1, 2]&gt;&gt;&gt; rdd = sc.parallelize(lst)&gt;&gt;&gt; rdd1 = rdd.map(lambda x: (x, 1))&gt;&gt;&gt; rdd1.reduceByKey(lambda x, y: x + y).collect()[(4, 3), (1, 4), (2, 2), (3, 1)] pyspark读取路径问题读取hdfs路径内容12&gt;&gt;&gt; path = &quot;hdfs://ip:port/bigdata/hello.txt&quot;&gt;&gt;&gt; rdd = sc.textFile(path) 读取local路径内容12&gt;&gt;&gt; path = &quot;file:///opt/bigdata/hello.txt&quot;&gt;&gt;&gt; rdd = sc.textFile(path) 查看分区 sc.textFile方式默认分区计算公式 12math.min(defaultParallelism, 2)math.max(totalCoreCount.get(), 2) sc.parallelize方式默认分区计算公式 1math.max(totalCoreCount.get(), 2) 查看rdd分区个数 方式一 123&gt;&gt;&gt; rdd = sc.parallelize(range(10))&gt;&gt;&gt; rdd.getNumPartitions()4 方式二 123&gt;&gt;&gt; rdd = sc.parallelize(range(10))&gt;&gt;&gt; rdd.glom().collect() # 数据按照分区形式打印[[0, 1], [2, 3, 4], [5, 6], [7, 8, 9]] 常用算子map123&gt;&gt;&gt; rdd = sc.parallelize(range(5))&gt;&gt;&gt; rdd.map(lambda i: range(i)).collect()[range(0, 0), range(0, 1), range(0, 2), range(0, 3), range(0, 4)] flatMap123&gt;&gt;&gt; rdd = sc.parallelize(range(5))&gt;&gt;&gt; rdd.flatMap(lambda i: range(i)).collect()[0, 0, 1, 0, 1, 2, 0, 1, 2, 3] reduce123&gt;&gt;&gt; rdd = sc.parallelize(range(1, 6))&gt;&gt;&gt; rdd.reduce(lambda x, y: x + y)15 fold123&gt;&gt;&gt; rdd = sc.parallelize(range(1, 6))&gt;&gt;&gt; rdd.fold(0, lambda x, y: x + y)15 aggregate123456&gt;&gt;&gt; rdd = sc.parallelize([2, 5, 3, 1], 2)&gt;&gt;&gt; rdd.glom().collect()[[2, 5], [3, 1]]&gt;&gt;&gt; rdd.aggregate(0, lambda x, y: x + y, lambda x, y: x + y)11 注：lambda x, y: x + y中，x为临时聚合值，y为当前元素值。 filter123&gt;&gt;&gt; rdd = sc.parallelize(range(1, 10))&gt;&gt;&gt; rdd.filter(lambda x: x % 2 == 0).collect()[2, 4, 6, 8] distinct123456&gt;&gt;&gt; lst = random.choices(range(1, 6), k=10)&gt;&gt;&gt; rdd = sc.parallelize(lst)&gt;&gt;&gt; rdd.collect()[2, 1, 4, 5, 4, 3, 3, 1, 2, 5]&gt;&gt;&gt; rdd.distinct().collect()[4, 1, 5, 2, 3] intersection、union12345678910&gt;&gt;&gt; rdd1 = sc.parallelize([&quot;C&quot;, &quot;A&quot;, &quot;B&quot;, &quot;B&quot;])&gt;&gt;&gt; rdd2 = sc.parallelize([&quot;A&quot;, &quot;A&quot;, &quot;B&quot;, &quot;B&quot;, &quot;D&quot;])# 交集&gt;&gt;&gt; rdd1.intersection(rdd2).collect()[&apos;B&apos;, &apos;A&apos;]# 并集&gt;&gt;&gt; rdd.union(rdd2).collect()[&apos;C&apos;, &apos;A&apos;, &apos;B&apos;, &apos;B&apos;, &apos;A&apos;, &apos;A&apos;, &apos;B&apos;, &apos;B&apos;, &apos;D&apos;] sortBy1234567891011&gt;&gt;&gt; lst = random.choices(range(20), k=6)[19, 6, 13, 19, 2, 3]&gt;&gt;&gt; rdd = sc.parallelize(lst)# 正序排列&gt;&gt;&gt; rdd.sortBy(lambda x: x).collect()[2, 3, 6, 13, 19, 19]# 倒序排列&gt;&gt;&gt; rdd.sortBy(lambda x: x, ascending=False).collect()[19, 19, 13, 6, 3, 2] groupByKey1234567891011&gt;&gt;&gt; rdd = sc.parallelize(&quot;abccda&quot;)&gt;&gt;&gt; rdd.collect()[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;c&apos;, &apos;d&apos;, &apos;a&apos;]&gt;&gt;&gt; rdd1 = rdd.map(lambda x: (x, 1))&gt;&gt;&gt; rdd1.collect()[(&apos;a&apos;, 1), (&apos;b&apos;, 1), (&apos;c&apos;, 1), (&apos;c&apos;, 1), (&apos;d&apos;, 1), (&apos;a&apos;, 1)]&gt;&gt;&gt; rdd1.groupByKey().collect()[(&apos;b&apos;, &lt;pyspark.resultiterable.ResultIterable object at 0x0000015412DE3EF0&gt;), (&apos;c&apos;, &lt;pyspark.resultiterable.ResultIterable object at 0x0000015412DE3F98&gt;), (&apos;a&apos;, &lt;pyspark.resultiterable.ResultIterable object at 0x0000015412DE8080&gt;), (&apos;d&apos;, &lt;pyspark.resultiterable.ResultIterable object at 0x0000015412DE80B8&gt;)]注：&lt;pyspark.resultiterable.ResultIterable object at 0x0000015412DE3EF0&gt;包含属性 &apos;data&apos;, &apos;index&apos;, &apos;maxindex&apos; reduceByKey1234&gt;&gt;&gt; rdd = sc.parallelize(&quot;abccda&quot;)&gt;&gt;&gt; rdd1 = rdd.map(lambda x: (x, 1))&gt;&gt;&gt; rdd1.reduceByKey(lambda x, y: x + y).collect()[(&apos;b&apos;, 1), (&apos;c&apos;, 2), (&apos;a&apos;, 2), (&apos;d&apos;, 1)] reduceByKeyLocally123456&gt;&gt;&gt; rdd = sc.parallelize(&quot;abccda&quot;)&gt;&gt;&gt; rdd1 = rdd.map(lambda x: (x, 1))&gt;&gt;&gt; rdd1.reduceByKeyLocally(lambda x, y: x + y)&#123;&apos;a&apos;: 2, &apos;b&apos;: 1, &apos;c&apos;: 2, &apos;d&apos;: 1&#125;注： reduceByKeyLocally返回结果不是rdd，返回字典。 aggregateByKey12345678&gt;&gt;&gt; rdd = sc.parallelize(&quot;abccda&quot;)&gt;&gt;&gt; rdd1 = rdd.map(lambda x: (x, 1))&gt;&gt;&gt; zeroValue = 0&gt;&gt;&gt; seqFunc = lambda x, y: x + y&gt;&gt;&gt; seqFunc = lambda x, y: x + y&gt;&gt;&gt; rdd1.aggregateByKey(zeroValue, seqFunc, seqFunc).collect()[(&apos;b&apos;, 1), (&apos;c&apos;, 2), (&apos;a&apos;, 2), (&apos;d&apos;, 1)] 异常处理Exception: It appears that you are attempting to reference… 在pyspark中调用类方法，报错，如下： 123456789101112131415from pyspark.conf import SparkConffrom pyspark.context import SparkContextconf = SparkConf()conf.setMaster("local").setAppName("my app")sc = SparkContext(conf=conf)class Test: def add(self, x): return [x + 5] def test(self): rdd = sc.parallelize(range(5)).flatMap(self.add).collect()Test().test() 错误信息： 123456789101112131415161718During handling of the above exception, another exception occurred:Traceback (most recent call last): File &quot;E:/Python37/spark_test.py&quot;, line 17, in &lt;module&gt; Test().test() File &quot;E:/Python37/spark_test.py&quot;, line 14, in test rdd = sc.parallelize(range(5)).map(self.add).collect() File &quot;E:\Python37\lib\site-packages\pyspark\rdd.py&quot;, line 816, in collect sock_info = self.ctx._jvm.PythonRDD.collectAndServe(self._jrdd.rdd()) File &quot;E:\Python37\lib\site-packages\pyspark\rdd.py&quot;, line 2532, in _jrdd self._jrdd_deserializer, profiler) File &quot;E:\Python37\lib\site-packages\pyspark\rdd.py&quot;, line 2434, in _wrap_function pickled_command, broadcast_vars, env, includes = _prepare_for_python_RDD(sc, command) File &quot;E:\Python37\lib\site-packages\pyspark\rdd.py&quot;, line 2420, in _prepare_for_python_RDD pickled_command = ser.dumps(command) File &quot;E:\Python37\lib\site-packages\pyspark\serializers.py&quot;, line 600, in dumps raise pickle.PicklingError(msg)_pickle.PicklingError: Could not serialize object: Exception: It appears that you are attempting to reference SparkContext from a broadcast variable, action, or transformation. SparkContext can only be used on the driver, not in code that it run on workers. For more information, see SPARK-5063. 说明 spark不允许在action或transformation中访问SparkContext，如果你的action或transformation中引用了self，那么spark会将整个对象进行序列化，并将其发到工作节点上，这其中就保留了SparkContext，即使没有显式的访问它，它也会在闭包内被引用，所以会出错。 处理 将调用的类方法定义为静态方法 @staticmethod 12345678910111213141516171819from pyspark.conf import SparkConffrom pyspark.context import SparkContextconf = SparkConf()conf.setMaster("local").setAppName("my app")sc = SparkContext(conf=conf)class Test: @staticmethod def add(x): return [x + 5] def test(self): rdd = sc.parallelize(range(5)).flatMap(Test.add) print(rdd.collect())Test().test()# [5, 6, 7, 8, 9] 拓展Spark &amp; PySpark 使用手册 Spark 2.2.x 中文官方参考文档 子雨大叔据之Spark入门教程(Python版) Spark性能优化指南——基础篇 Spark性能优化指南——高级篇: 解决数据倾斜(通常出现在distinct、groupByKey、reduceByKey、aggregateByKey、join、cogroup、repartition)的几个方案。 aokoInychyi/spark-streaming-kafka-example: scala版本的示例代码]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python argparse module]]></title>
    <url>%2Fpython%2Fmodule%2Fck9bgz83k00doqov77s5mt1zj.html</url>
    <content type="text"><![CDATA[python 命令行解析模块 基础1234567891011121314151617181920212223import argparseparser = argparse.ArgumentParser(description=&apos;Process some integers.&apos;)parser.add_argument(&apos;integers&apos;, metavar=&apos;N&apos;, type=int, nargs=&apos;+&apos;, help=&apos;an integer for the accumulator&apos;)parser.add_argument(&apos;--sum&apos;, dest=&apos;accumulate&apos;, action=&apos;store_const&apos;, const=sum, default=max, help=&apos;sum the integers (default: find the max)&apos;)args = parser.parse_args()print(args.accumulate(args.integers))# 打印命名空间print(args)# 打印参数空间中的变量print(args.integers)# 打印使用方法parser.print_usage()# 打印使用帮助说明（此处会打印出使用方法）parser.print_help() 1234567891011E:\Python37&gt;python ts_cmd.py &quot;command line&quot;Namespace(echo=&apos;command line&apos;)command lineusage: ts_cmd.py [-h] echousage: ts_cmd.py [-h] echopositional arguments: echooptional arguments: -h, --help show this help message and exit 位置参数介绍123456import argparseparser = argparse.ArgumentParser()parser.add_argument("square", help="display a square of a given number", type=int)args = parser.parse_args()print(args.square**2) 以下是该代码的运行结果： 12345$ python3 prog.py 416$ python3 prog.py fourusage: prog.py [-h] squareprog.py: error: argument square: invalid int value: &apos;four&apos; 可选参数介绍12345678# prog.pyimport argparseparser = argparse.ArgumentParser()parser.add_argument(&quot;-v&quot;, &quot;--verbosity&quot;, help=&quot;increase output verbosity&quot;)args = parser.parse_args()if args.verbosity: print &quot;verbosity turned on&quot; 输出： 12345678910111213$ python3 prog.py --verbosity 1verbosity turned on$ python3 prog.py$ python3 prog.py --helpusage: prog.py [-h] [--verbosity VERBOSITY]optional arguments: -h, --help show this help message and exit --verbosity VERBOSITY increase output verbosity$ python3 prog.py --verbosityusage: prog.py [-h] [--verbosity VERBOSITY]prog.py: error: argument --verbosity: expected one argument 不指定参数值，让其为默认设置的 bool 值，使用 action=’store_true’ 可以实现 1234567import argparseparser = argparse.ArgumentParser()parser.add_argument(&quot;-v&quot;, &quot;--verbosity&quot;, help=&quot;increase output verbosity&quot;, action=&quot;store_true&quot;)args = parser.parse_args()print args.verbosity 类及方法说明class ArgumentParser(…)1234ArgumentParser(prog=None, usage=None, description=None, epilog=None, parents=[], formatter_class=&lt;class &apos;argparse.HelpFormatter&apos;&gt;, prefix_chars=&apos;-&apos;, fromfile_prefix_chars=None, argument_default=None, conflict_handler=&apos;error&apos;, add_help=True, allow_abbrev=True) 参数说明 1234567891011prog - 程序的名字（默认：sys.argv[0]）usage - 描述程序用法的字符串（默认：从解析器的参数生成）description - 参数帮助信息之前的文本（默认：空）epilog - 参数帮助信息之后的文本（默认：空）parents - ArgumentParser 对象的一个列表，这些对象的参数应该包括进去formatter_class - 定制化帮助信息的类prefix_chars - 可选参数的前缀字符集（默认：‘-‘）fromfile_prefix_chars - 额外的参数应该读取的文件的前缀字符集（默认：None）argument_default - 参数的全局默认值（默认：None）conflict_handler - 解决冲突的可选参数的策略（通常没有必要）add_help - 给解析器添加-h/–help 选项（默认：True） def add_argument(self, args, *kwargs)123456add_argument(*args, **kwargs) method of argparse.ArgumentParser instance add_argument(dest, ..., name=value, ...) add_argument(option_string, option_string, ..., name=value, ...)# python2.7 定义ArgumentParser.add_argument(name or flags...[, action][, nargs][, const][, default][, type][, choices][, required][, help][, metavar][, dest]) 参数说明 123456789101112131415161718192021name or flags - 选项字符串的名字或者列表，例如foo 或者-f, --foo。action - 在命令行遇到该参数时采取的基本动作类型。 -- store -- store_const -- store_true -- store_false -- append -- append_const -- count -- help -- version -- extendnargs - 应该读取的命令行参数数目。const - 某些action和nargs选项要求的常数值。default - 如果命令行中没有出现该参数时的默认值。type - 命令行参数应该被转换成的类型。choices - 参数可允许的值的一个容器。required - 该命令行选项是否可以省略（只针对可选参数）。help - 参数的简短描述。metavar - 参数在帮助信息中的名字。dest - 给parse_args()返回的对象要添加的属性名称。 示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061# -*- coding: utf-8 -*-import argparseimport sysimport osdef main(argv): &apos;&apos;&apos; python3 &#123;0&#125; ls [-r] minio_path minio_path is directory or file or None, [-r] recursive query python3 &#123;0&#125; get minio_path local_path download minio file or directory to local python3 &#123;0&#125; put local_path minio_path upload local file or directory to minio python3 &#123;0&#125; cat minio_path print minio file content, so minio_path is file name python3 &#123;0&#125; head [-L 10] print minio file content, default show head 10 line python3 &#123;0&#125; tail [-L 10] print minio file content, default show tail 10 line &apos;&apos;&apos; command_list = [&quot;ls&quot;, &quot;get&quot;, &quot;put&quot;, &quot;cat&quot;, &quot;head&quot;, &quot;tail&quot;] file_name, *args_list = argv if 1: pass else: print(getattr(globals()[sys._getframe().f_code.co_name], &quot;__doc__&quot;).format(file_name)) if __name__ == &quot;__main__&quot;: parser = argparse.ArgumentParser(prog=None, usage=&quot;python %(prog)s [option] ...&quot;, description=&quot;simulation minio mc&quot;, epilog=&quot;and so on ...&quot;, parents=[], formatter_class=argparse.HelpFormatter, prefix_chars=&apos;-&apos;, fromfile_prefix_chars=None, argument_default=None, conflict_handler=&apos;error&apos;, add_help=True, allow_abbrev=True) parser.add_argument(&quot;-ls&quot;, nargs=&quot;?&quot;, help=&quot;show dir or file info&quot;, const=os.sep) parser.add_argument(&quot;-r&quot;, &quot;--recursion&quot;, help=&quot;recursion dir&quot;, action=&quot;store_true&quot;) parser.add_argument(&quot;-get&quot;, nargs=2, metavar=(&quot;d_path&quot;, &quot;l_path&quot;), help=&quot;downlod dst file or dir to local&quot;) parser.add_argument(&quot;-put&quot;, nargs=2, metavar=(&quot;l_path&quot;, &quot;d_path&quot;), help=&quot;upload local file or dir to dst&quot;) parser.add_argument(&quot;-cat&quot;, nargs=1, help=&quot;print file content&quot;) parser.add_argument(&quot;-f&quot;, &quot;--format&quot;, help=&quot;format print content&quot;, action=&quot;store_true&quot;) parser.add_argument(&quot;-L&quot;, &quot;--line&quot;, help=&quot;show print line number&quot;, action=&quot;store_true&quot;) parser.add_argument(&quot;-n&quot;, &quot;--number&quot;, nargs=&quot;?&quot;, metavar=&quot;n&quot;, help=&quot;print line number&quot;, default=10, const=10, type=int) parser.add_argument(&quot;-head&quot;, nargs=1, metavar=&quot;d_file&quot;, help=&quot;print file content, default head 10 line&quot;) parser.add_argument(&quot;-tail&quot;, nargs=1, metavar=&quot;d_file&quot;, help=&quot;print file content, default tail 10 line&quot;) args = parser.parse_args() # print(args) # print(parser.print_help()) 说明文档示例： 12345678910111213141516171819E:\Python37&gt;python ts_cmd.py -husage: python ts_cmd.py [option] ...simulation minio mcoptional arguments: -h, --help show this help message and exit -ls [LS] show dir or file info -r, --recursion recursion dir -get d_path l_path downlod dst file or dir to local -put l_path d_path upload local file or dir to dst -cat CAT print file content -f, --format format print content -L, --line show print line number -n [n], --number [n] print line number -head d_file print file content, default head 10 line -tail d_file print file content, default tail 10 lineand so on ... 参考https://docs.python.org/zh-cn/dev/library/argparse.html Python 命令行工具 argparse 模块使用详解 PYTHON中argparse的用法 python argparse（参数解析）模块学习（二）]]></content>
      <categories>
        <category>python</category>
        <category>module</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>module</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python collections module]]></title>
    <url>%2Fpython%2Fmodule%2Fck9bgz86f00geqov7mbxqsh46.html</url>
    <content type="text"><![CDATA[Source code: Lib/collections/init.py 这个模块实现了特定目标的容器，以提供Python标准内建容器 dict , list , set , 和 tuple 的替代选择。 方法概述 namedtuple() 创建命名元组子类的工厂函数 deque 类似列表(list)的容器，实现了在两端快速添加(append)和弹出(pop) ChainMap 类似字典(dict)的容器类，将多个映射集合到一个视图里面 Counter 字典的子类，提供了可哈希对象的计数功能 OrderedDict 字典的子类，保存了他们被添加的顺序 defaultdict 字典的子类，提供了一个工厂函数，为字典查询提供一个默认值 UserDict 封装了字典对象，简化了字典子类化 UserList 封装了列表对象，简化了列表子类化 UserString 封装了列表对象，简化了字符串子类化 ChainMap 对象class collections.ChainMap(*maps)一个 ChainMap 将多个字典或者其他映射组合在一起，创建一个单独的可更新的视图。 如果没有 maps 被指定，就提供一个默认的空字典，这样一个新链至少有一个映射。 底层映射被存储在一个列表中。这个列表是公开的，可以通过 maps 属性存取和更新。没有其他的状态。 搜索查询底层映射，直到一个键被找到。不同的是，写，更新和删除只操作第一个映射。 一个 ChainMap 通过引用合并底层映射。 所以，如果一个底层映射更新了，这些更改会反映到 ChainMap 。 支持所有常用字典方法。另外还有一个 maps 属性(attribute)，一个创建子上下文的方法(method)， 一个存取它们首个映射的属性(property): 12345678&gt;&gt;&gt; from collections import ChainMap&gt;&gt;&gt; baseline = &#123;&apos;music&apos;: &apos;bach&apos;, &apos;art&apos;: &apos;rembrandt&apos;&#125;&gt;&gt;&gt; adjustments = &#123;&apos;art&apos;: &apos;van gogh&apos;, &apos;opera&apos;: &apos;carmen&apos;&#125;&gt;&gt;&gt; comb = ChainMap(baseline, adjustments)&gt;&gt;&gt; list(comb)[&apos;music&apos;, &apos;art&apos;, &apos;opera&apos;] maps一个可以更新的映射列表。这个列表是按照第一次搜索到最后一次搜索的顺序组织的。它是仅有的存储状态，可以被修改。列表最少包含一个映射。 12&gt;&gt;&gt; comb.maps[&#123;&apos;music&apos;: &apos;bach&apos;, &apos;art&apos;: &apos;rembrandt&apos;&#125;, &#123;&apos;art&apos;: &apos;van gogh&apos;, &apos;opera&apos;: &apos;carmen&apos;&#125;] new_child(m=None)返回一个新的 ChainMap 类，包含了一个新映射(map)，后面跟随当前实例的全部映射(map)。如果 m 被指定，它就成为不同新的实例，就是在所有映射前加上 m，如果没有指定，就加上一个空字典，这样的话一个 d.new_child() 调用等价于 ChainMap({}, *d.maps) 。这个方法用于创建子上下文，不改变任何父映射的值。 在 3.4 版更改: 添加了 m 可选参数。 12&gt;&gt;&gt; comb.new_child(&#123;&apos;sport&apos;: &apos;swim&apos;&#125;)ChainMap(&#123;&apos;sport&apos;: &apos;swim&apos;&#125;, &#123;&apos;music&apos;: &apos;bach&apos;, &apos;art&apos;: &apos;rembrandt&apos;&#125;, &#123;&apos;art&apos;: &apos;van gogh&apos;, &apos;opera&apos;: &apos;carmen&apos;&#125;) parents属性返回一个新的 ChainMap 包含所有的当前实例的映射，除了第一个。这样可以在搜索的时候跳过第一个映射。 使用的场景类似在 nested scopes 嵌套作用域中使用 nonlocal 关键词。用例也可以类比内建函数 super() 。一个 d.parents 的引用等价于 ChainMap(*d.maps[1:]) 。 12&gt;&gt;&gt; comb.parentsChainMap(&#123;&apos;art&apos;: &apos;van gogh&apos;, &apos;opera&apos;: &apos;carmen&apos;&#125;) ChainMap 例子和方法模拟Python内部lookup链的例子 12import builtinspylookup = ChainMap(locals(), globals(), vars(builtins)) 让用户指定的命令行参数优先于环境变量，优先于默认值的例子 123456789101112131415from collections import ChainMapimport osimport argparsedefaults = &#123;&apos;color&apos;: &apos;red&apos;, &apos;user&apos;: &apos;guest&apos;&#125;parser = argparse.ArgumentParser()parser.add_argument(&apos;-u&apos;, &apos;--user&apos;)parser.add_argument(&apos;-c&apos;, &apos;--color&apos;)namespace = parser.parse_args()command_line_args = &#123;k: v for k, v in vars(namespace).items() if v is not None&#125;combined = ChainMap(command_line_args, os.environ, defaults)print(combined[&apos;color&apos;])print(combined[&apos;user&apos;]) ChainMap 类只更新链中的第一个映射，但lookup会搜索整个链。 然而，如果需要深度写和删除，也可以很容易的通过定义一个子类来实现它 1234567891011121314151617181920212223class DeepChainMap(ChainMap): &apos;Variant of ChainMap that allows direct updates to inner scopes&apos; def __setitem__(self, key, value): for mapping in self.maps: if key in mapping: mapping[key] = value return self.maps[0][key] = value def __delitem__(self, key): for mapping in self.maps: if key in mapping: del mapping[key] return raise KeyError(key)&gt;&gt;&gt; d = DeepChainMap(&#123;&apos;zebra&apos;: &apos;black&apos;&#125;, &#123;&apos;elephant&apos;: &apos;blue&apos;&#125;, &#123;&apos;lion&apos;: &apos;yellow&apos;&#125;)&gt;&gt;&gt; d[&apos;lion&apos;] = &apos;orange&apos; # update an existing key two levels down&gt;&gt;&gt; d[&apos;snake&apos;] = &apos;red&apos; # new keys get added to the topmost dict&gt;&gt;&gt; del d[&apos;elephant&apos;] # remove an existing key one level down&gt;&gt;&gt; d # display resultDeepChainMap(&#123;&apos;zebra&apos;: &apos;black&apos;, &apos;snake&apos;: &apos;red&apos;&#125;, &#123;&#125;, &#123;&apos;lion&apos;: &apos;orange&apos;&#125;) Counter 对象一个计数器工具提供快速和方便的计数。比如： 12345678910111213&gt;&gt;&gt; # Tally occurrences of words in a list&gt;&gt;&gt; cnt = Counter()&gt;&gt;&gt; for word in [&apos;red&apos;, &apos;blue&apos;, &apos;red&apos;, &apos;green&apos;, &apos;blue&apos;, &apos;blue&apos;]:... cnt[word] += 1&gt;&gt;&gt; cntCounter(&#123;&apos;blue&apos;: 3, &apos;red&apos;: 2, &apos;green&apos;: 1&#125;)&gt;&gt;&gt; # Find the ten most common words in Hamlet&gt;&gt;&gt; import re&gt;&gt;&gt; words = re.findall(r&apos;\w+&apos;, open(&apos;hamlet.txt&apos;).read().lower())&gt;&gt;&gt; Counter(words).most_common(10)[(&apos;the&apos;, 1143), (&apos;and&apos;, 966), (&apos;to&apos;, 762), (&apos;of&apos;, 669), (&apos;i&apos;, 631), (&apos;you&apos;, 554), (&apos;a&apos;, 546), (&apos;my&apos;, 514), (&apos;hamlet&apos;, 471), (&apos;in&apos;, 451)] class collections.Counter([iterable-or-mapping])一个 Counter 是一个 dict 的子类，用于计数可哈希对象。它是一个集合，元素像字典键(key)一样存储，它们的计数存储为值。计数可以是任何整数值，包括0和负数。 Counter 类有点像其他语言中的 bags或multisets。 元素从一个 iterable 被计数或从其他的 mapping (or counter)初始化： 1234&gt;&gt;&gt; c = Counter() # a new, empty counter&gt;&gt;&gt; c = Counter(&apos;gallahad&apos;) # a new counter from an iterable&gt;&gt;&gt; c = Counter(&#123;&apos;red&apos;: 4, &apos;blue&apos;: 2&#125;) # a new counter from a mapping&gt;&gt;&gt; c = Counter(cats=4, dogs=8) # a new counter from keyword args Counter对象有一个字典接口，如果引用的键没有任何记录，就返回一个0，而不是弹出一个 KeyError : 123&gt;&gt;&gt; c = Counter([&apos;eggs&apos;, &apos;ham&apos;])&gt;&gt;&gt; c[&apos;bacon&apos;] # count of a missing element is zero0 设置一个计数为0不会从计数器中移去一个元素。使用 del 来删除它: 12&gt;&gt;&gt; c[&apos;sausage&apos;] = 0 # counter entry with a zero count&gt;&gt;&gt; del c[&apos;sausage&apos;] # del actually removes the entry 在 3.7 版更改: 作为 dict 的子类，Counter 继承了记住插入顺序的功能。 Counter 对象进行数学运算时同样会保持顺序。 结果会先按每个元素在运算符左边的出现时间排序，然后再按其在运算符右边的出现时间排序。 计数器对象除了字典方法以外，还提供了三个其他的方法： elements()返回一个迭代器，其中每个元素将重复出现计数值所指定次。 元素会按首次出现的顺序返回。 如果一个元素的计数值小于一，elements() 将会忽略它。 123&gt;&gt;&gt; c = Counter(a=4, b=2, c=0, d=-2)&gt;&gt;&gt; sorted(c.elements())[&apos;a&apos;, &apos;a&apos;, &apos;a&apos;, &apos;a&apos;, &apos;b&apos;, &apos;b&apos;] most_common([n])返回一个列表，其中包含 n 个最常见的元素及出现次数，按常见程度由高到低排序。 如果 n 被省略或为 None，most_common() 将返回计数器中的 所有 元素。 计数值相等的元素按首次出现的顺序排序： 12&gt;&gt;&gt; Counter(&apos;abracadabra&apos;).most_common(3)[(&apos;a&apos;, 5), (&apos;b&apos;, 2), (&apos;r&apos;, 2)] 通常字典方法都可用于 Counter 对象，除了有两个方法工作方式与字典并不相同。 fromkeys(iterable)这个类方法没有在 Counter 中实现。 update([iterable-or-mapping])从 迭代对象 计数元素或者 从另一个 映射对象 (或计数器) 添加。 像 dict.update() 但是是加上，而不是替换。另外，迭代对象 应该是序列元素，而不是一个 (key, value) 对。 Counter对象的常用案例123456789sum(c.values()) # total of all countsc.clear() # reset all countslist(c) # list unique elementsset(c) # convert to a setdict(c) # convert to a regular dictionaryc.items() # convert to a list of (elem, cnt) pairsCounter(dict(list_of_pairs)) # convert from a list of (elem, cnt) pairsc.most_common()[:-n-1:-1] # n least common elements+c # remove zero and negative counts 提供了几个数学操作，可以结合 Counter 对象，以生产 multisets (计数器中大于0的元素）。 加和减，结合计数器，通过加上或者减去元素的相应计数。交集和并集返回相应计数的最小或最大值。每种操作都可以接受带符号的计数，但是输出会忽略掉结果为零或者小于零的计数。 12345678910&gt;&gt;&gt; c = Counter(a=3, b=1)&gt;&gt;&gt; d = Counter(a=1, b=2)&gt;&gt;&gt; c + d # add two counters together: c[x] + d[x]Counter(&#123;&apos;a&apos;: 4, &apos;b&apos;: 3&#125;)&gt;&gt;&gt; c - d # subtract (keeping only positive counts)Counter(&#123;&apos;a&apos;: 2&#125;)&gt;&gt;&gt; c &amp; d # intersection: min(c[x], d[x]) Counter(&#123;&apos;a&apos;: 1, &apos;b&apos;: 1&#125;)&gt;&gt;&gt; c | d # union: max(c[x], d[x])Counter(&#123;&apos;a&apos;: 3, &apos;b&apos;: 2&#125;) 单目加和减（一元操作符）意思是从空计数器加或者减去。 12345&gt;&gt;&gt; c = Counter(a=2, b=-4)&gt;&gt;&gt; +cCounter(&#123;&apos;a&apos;: 2&#125;)&gt;&gt;&gt; -cCounter(&#123;&apos;b&apos;: 4&#125;) deque 对象class collections.deque([iterable[, maxlen]])返回一个新的双向队列对象，从左到右初始化(用方法 append()) ，从 iterable （迭代对象) 数据创建。如果 iterable 没有指定，新队列为空。 Deque队列是由栈或者queue队列生成的（发音是 “deck”，”double-ended queue”的简称）。Deque 支持线程安全，内存高效添加(append)和弹出(pop)，从两端都可以，两个方向的大概开销都是 O(1) 复杂度。 虽然 list 对象也支持类似操作，不过这里优化了定长操作和 pop(0) 和 insert(0, v) 的开销。它们引起 O(n) 内存移动的操作，改变底层数据表达的大小和位置。 如果 maxlen 没有指定或者是 None ，deques 可以增长到任意长度。否则，deque就限定到指定最大长度。一旦限定长度的deque满了，当新项加入时，同样数量的项就从另一端弹出。限定长度deque提供类似Unix filter tail 的功能。它们同样可以用与追踪最近的交换和其他数据池活动。 双向队列(deque)对象支持以下方法： 1234567891011121314&gt;&gt;&gt; from collections import deque&gt;&gt;&gt; d = deque(&apos;ghi&apos;) # make a new deque with three items&gt;&gt;&gt; for elem in d: # iterate over the deque&apos;s elements... print(elem.upper())GHI&gt;&gt;&gt; list(d) # list the contents of the deque[&apos;g&apos;, &apos;h&apos;, &apos;i&apos;]&gt;&gt;&gt; d[0] # peek at leftmost item&apos;g&apos;&gt;&gt;&gt; d[-1] # peek at rightmost item&apos;i&apos; append(x)添加 x 到右端。 12345&gt;&gt;&gt; from collections import deque&gt;&gt;&gt; d = deque('ghi')&gt;&gt;&gt; d.append('j') # add a new entry to the right side&gt;&gt;&gt; ddeque(['g', 'h', 'i', 'j']) appendleft(x)添加 x 到左端。 12345&gt;&gt;&gt; from collections import deque&gt;&gt;&gt; d = deque(&apos;ghi&apos;)&gt;&gt;&gt; d.appendleft(&apos;f&apos;) # add a new entry to the left side&gt;&gt;&gt; d # show the representation of the dequedeque([&apos;f&apos;, &apos;g&apos;, &apos;h&apos;, &apos;i&apos;]) clear()移除所有元素，使其长度为0. 12345&gt;&gt;&gt; from collections import deque&gt;&gt;&gt; d = deque(&apos;ghi&apos;)&gt;&gt;&gt; d.clear()&gt;&gt;&gt; ddeque([]) copy()创建一份浅拷贝。 3.5 新版功能. 1234&gt;&gt;&gt; from collections import deque&gt;&gt;&gt; d = deque(&apos;ghi&apos;)&gt;&gt;&gt; d.copy()deque(&apos;g&apos;, &apos;h&apos;, &apos;i&apos;) count(x)计算deque中个数等于 x 的元素。 3.2 新版功能. 1234&gt;&gt;&gt; from collections import deque&gt;&gt;&gt; d = deque(&apos;ghi&apos;)&gt;&gt;&gt; d.count(&apos;h&apos;)1 extend(iterable)扩展deque的右侧，通过添加iterable参数中的元素。 12345&gt;&gt;&gt; from collections import deque&gt;&gt;&gt; d = deque(&apos;ghi&apos;)&gt;&gt;&gt; d.extend(&apos;lmn&apos;)&gt;&gt;&gt; ddeque([&apos;g&apos;, &apos;h&apos;, &apos;i&apos;, &apos;l&apos;, &apos;m&apos;, &apos;n&apos;]) extendleft(iterable)扩展deque的左侧，通过添加iterable参数中的元素。注意，左添加时，在结果中iterable参数中的顺序将被反过来添加。 12345&gt;&gt;&gt; from collections import deque&gt;&gt;&gt; d = deque(&apos;ghi&apos;)&gt;&gt;&gt; d.extendleft(&apos;def&apos;)&gt;&gt;&gt; ddeque([&apos;f&apos;, &apos;e&apos;, &apos;d&apos;, &apos;g&apos;, &apos;h&apos;, &apos;i&apos;]) index(x[, start[, stop]])返回第 x 个元素（从 start 开始计算，在 stop 之前）。返回第一个匹配，如果没找到的话，升起 ValueError 。 3.5 新版功能. 12345678910&gt;&gt;&gt; from collections import deque&gt;&gt;&gt; d = deque(&apos;ghi&apos;)&gt;&gt;&gt; d.index(&apos;h&apos;)1&gt;&gt;&gt; d.index(&apos;x&apos;)Traceback (most recent call last): File &quot;&lt;pyshell#111&gt;&quot;, line 1, in &lt;module&gt; d.index(&apos;x&apos;)ValueError: &apos;x&apos; is not in deque insert(i, x)在位置 i 插入 x 。 如果插入会导致一个限长deque超出长度 maxlen 的话，就升起一个 IndexError 。 3.5 新版功能. 12345&gt;&gt;&gt; from collections import deque&gt;&gt;&gt; d = deque(&apos;ghi&apos;)&gt;&gt;&gt; d.insert(0, &apos;f&apos;)&gt;&gt;&gt; ddeque([&apos;f&apos;, &apos;g&apos;, &apos;h&apos;, &apos;i&apos;]) pop()移去并且返回一个元素，deque最右侧的那一个。如果没有元素的话，就升起 IndexError 索引错误。 1234&gt;&gt;&gt; from collections import deque&gt;&gt;&gt; d = deque(&apos;ghi&apos;)&gt;&gt;&gt; d.pop() # return and remove the rightmost item&apos;i&apos; popleft()移去并且返回一个元素，deque最左侧的那一个。如果没有元素的话，就升起 IndexError 索引错误。 1234&gt;&gt;&gt; from collections import deque&gt;&gt;&gt; d = deque(&apos;ghi&apos;)&gt;&gt;&gt; d.popleft() # return and remove the leftmost item&apos;g&apos; remove(value)移去找到的第一个 value。 如果没有的话就升起 ValueError 。 1234567891011&gt;&gt;&gt; from collections import deque&gt;&gt;&gt; d = deque(&apos;ghi&apos;)&gt;&gt;&gt; d.remove(&apos;h&apos;)&gt;&gt;&gt; ddeque(&apos;g&apos;, &apos;i&apos;)&gt;&gt;&gt; d.remove(&apos;h&apos;)Traceback (most recent call last): File &quot;&lt;pyshell#119&gt;&quot;, line 1, in &lt;module&gt; d.remove(&apos;h&apos;)ValueError: deque.remove(x): x not in deque reverse()将deque逆序排列。返回 None 。 3.2 新版功能. 12345&gt;&gt;&gt; from collections import deque&gt;&gt;&gt; d = deque(&apos;ghi&apos;)&gt;&gt;&gt; d.reverse()&gt;&gt;&gt; ddeque([&apos;i&apos;, &apos;h&apos;, &apos;g&apos;]) rotate(n=1)向右循环移动 n 步。 如果 n 是负数，就向左循环。 如果deque不是空的，向右循环移动一步就等价于 d.appendleft(d.pop()) ， 向左循环一步就等价于 d.append(d.popleft()) 。 Deque对象同样提供了一个只读属性: 12345678910&gt;&gt;&gt; from collections import deque&gt;&gt;&gt; d = deque(&apos;ghi&apos;)&gt;&gt;&gt; d.rotate(1) # right rotation&gt;&gt;&gt; ddeque([&apos;i&apos;, &apos;g&apos;, &apos;h&apos;])&gt;&gt;&gt; d = deque(&apos;ghi&apos;)&gt;&gt;&gt; d.rotate(-1) # left rotation&gt;&gt;&gt; ddeque([&apos;h&apos;, &apos;i&apos;, &apos;g&apos;]) maxlenDeque的最大尺寸，如果没有限定的话就是 None 。 3.1 新版功能. 除了以上操作，deque 还支持迭代、封存、len(d)、reversed(d)、copy.copy(d)、copy.deepcopy(d)、成员检测运算符 in 以及下标引用例如通过 d[0] 访问首个元素等。 索引访问在两端的复杂度均为 O(1) 但在中间则会低至 O(n)。 如需快速随机访问，请改用列表。 Deque从版本3.5开始支持 __add__(),__mul__(), 和 __imul__() 。 deque 用法限长deque提供了类似Unix tail 过滤功能 1234def tail(filename, n=10): &apos;Return the last n lines of a file&apos; with open(filename) as f: return deque(f, n) 维护一个近期添加元素的序列，通过从右边添加和从左边弹出 1234567891011def moving_average(iterable, n=3): # moving_average([40, 30, 50, 46, 39, 44]) --&gt; 40.0 42.0 45.0 43.0 # http://en.wikipedia.org/wiki/Moving_average it = iter(iterable) d = deque(itertools.islice(it, n-1)) d.appendleft(0) s = sum(d) for elem in it: s += elem - d.popleft() d.append(elem) yield s / n defaultdict 对象class collections.defaultdict([default_factory[, …]])返回一个新的类似字典的对象。 defaultdict 是内置 dict 类的子类。它重载了一个方法并添加了一个可写的实例变量。其余的功能与 dict 类相同，此处不再重复说明。 本对象包含一个名为 default_factory 的属性，构造时，第一个参数用于为该属性提供初始值，默认为 None。所有其他参数（包括关键字参数）都相当于传递给 dict 的构造函数。 defaultdict 对象除了支持标准 dict 的操作，还支持以下方法作为扩展： missing(key)如果 default_factory 属性为 None，则调用本方法会抛出 KeyError 异常，附带参数 key。 如果 default_factory 不为 None，则它会被（不带参数地）调用来为 key 提供一个默认值，这个值和 key 作为一对键值对被插入到字典中，并作为本方法的返回值返回。 如果调用 default_factory 时抛出了异常，这个异常会原封不动地向外层传递。 在无法找到所需键值时，本方法会被 dict 中的 getitem() 方法调用。无论本方法返回了值还是抛出了异常，都会被 getitem() 传递。 注意，missing() 不会 被 getitem() 以外的其他方法调用。意味着 get() 会像正常的 dict 那样返回 None，而不是使用 default_factory。 defaultdict 对象支持以下实例变量： default_factory本属性由 missing() 方法来调用。如果构造对象时提供了第一个参数，则本属性会被初始化成那个参数，如果未提供第一个参数，则本属性为 None。 defaultdict 例子使用 list 作为 default_factory，很轻松地将（键-值对组成的）序列转换为（键-列表组成的）字典： 1234567&gt;&gt;&gt; s = [(&apos;yellow&apos;, 1), (&apos;blue&apos;, 2), (&apos;yellow&apos;, 3), (&apos;blue&apos;, 4), (&apos;red&apos;, 1)]&gt;&gt;&gt; d = defaultdict(list)&gt;&gt;&gt; for k, v in s:... d[k].append(v)...&gt;&gt;&gt; sorted(d.items())[(&apos;blue&apos;, [2, 4]), (&apos;red&apos;, [1]), (&apos;yellow&apos;, [1, 3])] 等价于： 123456d = &#123;&#125;&gt;&gt;&gt; for k, v in s:... d.setdefault(k, []).append(v)...&gt;&gt;&gt; sorted(d.items())[(&apos;blue&apos;, [2, 4]), (&apos;red&apos;, [1]), (&apos;yellow&apos;, [1, 3])] 函数 int() 总是返回 0，这是常数函数的特殊情况。一个更快和灵活的方法是使用 lambda 函数，可以提供任何常量值（不只是0）： 123456&gt;&gt;&gt; def constant_factory(value):... return lambda: value&gt;&gt;&gt; d = defaultdict(constant_factory(&apos;&lt;missing&gt;&apos;))&gt;&gt;&gt; d.update(name=&apos;John&apos;, action=&apos;ran&apos;)&gt;&gt;&gt; &apos;%(name)s %(action)s to %(object)s&apos; % d&apos;John ran to &lt;missing&gt;&apos; 设置 default_factory 为 set 使 defaultdict 用于构建 set 集合： 1234567&gt;&gt;&gt; s = [(&apos;red&apos;, 1), (&apos;blue&apos;, 2), (&apos;red&apos;, 3), (&apos;blue&apos;, 4), (&apos;red&apos;, 1), (&apos;blue&apos;, 4)]&gt;&gt;&gt; d = defaultdict(set)&gt;&gt;&gt; for k, v in s:... d[k].add(v)...&gt;&gt;&gt; sorted(d.items())[(&apos;blue&apos;, &#123;2, 4&#125;), (&apos;red&apos;, &#123;1, 3&#125;)] namedtuple() 命名元组的工厂函数collections.namedtuple(typename, field_names, *, rename=False, defaults=None, module=None)返回一个新的元组子类，名为 typename 。这个新的子类用于创建类元组的对象，可以通过域名来获取属性值，同样也可以通过索引和迭代获取值。子类实例同样有文档字符串（类名和域名）另外一个有用的 repr() 方法，以 name=value 格式列明了元组内容。 field_names 是一个像 [‘x’, ‘y’] 一样的字符串序列。另外 field_names 可以是一个纯字符串，用空白或逗号分隔开元素名，比如 ‘x y’ 或者 ‘x, y’ 。 任何有效的Python 标识符都可以作为域名，除了下划线开头的那些。有效标识符由字母，数字，下划线组成，但首字母不能是数字或下划线，另外不能是关键词 keyword 比如 class, for, return, global, pass, 或 raise 。 rename 如果为真， 无效域名会自动转换成位置名。比如 [‘abc’, ‘def’, ‘ghi’, ‘abc’] 转换成 [‘abc’, ‘_1’, ‘ghi’, ‘_3’] ， 消除关键词 def 和重复域名 abc 。 defaults 可以为 None 或者是一个默认值的 iterable 。如果一个默认值域必须跟其他没有默认值的域在一起出现，defaults 就应用到最右边的参数。比如如果域名 [‘x’, ‘y’, ‘z’] 和默认值 (1, 2) ，那么 x 就必须指定一个参数值 ，y 默认值 1 ， z 默认值 2 。 如果 module 值有定义，命名元组的 module 属性值就被设置。 命名元组实例没有字典，所以它们要更轻量，并且占用更小内存。 除了继承元组的方法，命名元组还支持三个额外的方法和两个属性。为了防止域名冲突，方法和属性以下划线开始。 1234567891011121314# Basic example&gt;&gt;&gt; from collections import namedtuple&gt;&gt;&gt; Point = namedtuple(&apos;Point&apos;, [&apos;x&apos;, &apos;y&apos;])&gt;&gt;&gt; p = Point(11, y=22) # instantiate with positional or keyword arguments&gt;&gt;&gt; p[0] + p[1] # indexable like the plain tuple (11, 22)33&gt;&gt;&gt; x, y = p # unpack like a regular tuple&gt;&gt;&gt; x, y(11, 22)&gt;&gt;&gt; p.x + p.y # fields also accessible by name33&gt;&gt;&gt; p # readable __repr__ with a name=value stylePoint(x=11, y=22) classmethod somenamedtuple._make(iterable)类方法从存在的序列或迭代实例创建一个新实例。 123&gt;&gt;&gt; t = [11, 22]&gt;&gt;&gt; Point._make(t)Point(x=11, y=22) somenamedtuple._asdict()返回一个新的 dict ，它将字段名称映射到它们对应的值： 123&gt;&gt;&gt; p = Point(x=11, y=22)&gt;&gt;&gt; p._asdict()&#123;&apos;x&apos;: 11, &apos;y&apos;: 22&#125; 在 3.1 版更改: 返回一个 OrderedDict 而不是 dict 。 在 3.8 版更改: 返回一个常规 dict 而不是 OrderedDict。 因为自 Python 3.7 起，常规字典已经保证有序。 如果需要 OrderedDict 的额外特性，推荐的解决方案是将结果转换为需要的类型: OrderedDict(nt._asdict())。 somenamedtuple._replace(**kwargs)返回一个新的命名元组实例，并将指定域替换为新的值 123456&gt;&gt;&gt; p = Point(x=11, y=22)&gt;&gt;&gt; p._replace(x=33)Point(x=33, y=22)&gt;&gt;&gt; for partnum, record in inventory.items(): inventory[partnum] = record._replace(price=newprices[partnum], timestamp=time.now()) somenamedtuple._fields字符串元组列出了域名。用于提醒和从现有元组创建一个新的命名元组类型。 1234567&gt;&gt;&gt; p._fields # view the field names(&apos;x&apos;, &apos;y&apos;)&gt;&gt;&gt; Color = namedtuple(&apos;Color&apos;, &apos;red green blue&apos;)&gt;&gt;&gt; Pixel = namedtuple(&apos;Pixel&apos;, Point._fields + Color._fields)&gt;&gt;&gt; Pixel(11, 22, 128, 255, 0)Pixel(x=11, y=22, red=128, green=255, blue=0) somenamedtuple._field_defaults默认值的字典。 12345&gt;&gt;&gt; Account = namedtuple(&apos;Account&apos;, [&apos;type&apos;, &apos;balance&apos;], defaults=[0])&gt;&gt;&gt; Account._field_defaults&#123;&apos;balance&apos;: 0&#125;&gt;&gt;&gt; Account(&apos;premium&apos;)Account(type=&apos;premium&apos;, balance=0) OrderedDict 对象 常规的 dict 被设计为非常擅长映射操作。 跟踪插入顺序是次要的。 OrderedDict 旨在擅长重新排序操作。 空间效率、迭代速度和更新操作的性能是次要的。 算法上， OrderedDict 可以比 dict 更好地处理频繁的重新排序操作。 这使其适用于跟踪最近的访问（例如在 LRU cache 中）。 对于 OrderedDict ，相等操作检查匹配顺序。 OrderedDict 类的 popitem() 方法有不同的签名。它接受一个可选参数来指定弹出哪个元素。 OrderedDict 类有一个 move_to_end() 方法，可以有效地将元素移动到任一端。 有序字典还另外提供了逆序迭代的支持，通过 reversed() 。 Python 3.8之前， dict 缺少 __reversed__() 方法。 class collections.OrderedDict([items])popitem(last=True)返回一个 dict 子类的实例，它具有专门用于重新排列字典顺序的方法。 有序字典的 popitem() 方法移除并返回一个 (key, value) 键值对。 如果 last 值为真，则按 LIFO 后进先出的顺序返回键值对，否则就按 FIFO 先进先出的顺序返回键值对。 move_to_end(key, last=True)将现有 key 移动到有序字典的任一端。 如果 last 为真值（默认）则将元素移至末尾；如果 last 为假值则将元素移至开头。如果 key 不存在则会触发 KeyError: 1234567&gt;&gt;&gt; d = OrderedDict.fromkeys(&apos;abcde&apos;)&gt;&gt;&gt; d.move_to_end(&apos;b&apos;)&gt;&gt;&gt; &apos;&apos;.join(d.keys())&apos;acdeb&apos;&gt;&gt;&gt; d.move_to_end(&apos;b&apos;, last=False)&gt;&gt;&gt; &apos;&apos;.join(d.keys())&apos;bacde&apos; OrderedDict 例子和用法创建记住键值 最后 插入顺序的有序字典变体很简单。 如果新条目覆盖现有条目，则原始插入位置将更改并移至末尾: 123456class LastUpdatedOrderedDict(OrderedDict): &apos;Store items in the order the keys were last added&apos; def __setitem__(self, key, value): super().__setitem__(key, value) self.move_to_end(key) 一个 OrderedDict 对于实现 functools.lru_cache() 的变体也很有用: 1234567891011121314151617class LRU(OrderedDict): &apos;Limit size, evicting the least recently looked-up key when full&apos; def __init__(self, maxsize=128, /, *args, **kwds): self.maxsize = maxsize super().__init__(*args, **kwds) def __getitem__(self, key): value = super().__getitem__(key) self.move_to_end(key) return value def __setitem__(self, key, value): super().__setitem__(key, value) if len(self) &gt; self.maxsize: oldest = next(iter(self)) del self[oldest] UserDict 对象UserDict 类是用作字典对象的外包装。对这个类的需求已部分由直接创建 dict 的子类的功能所替代；不过，这个类处理起来更容易，因为底层的字典可以作为属性来访问。 class collections.UserDict([initialdata])模拟一个字典类。这个实例的内容保存为一个正常字典， 可以通过 UserDict 实例的 data 属性存取。如果提供了 initialdata 值， data 就被初始化为它的内容；注意一个 initialdata 的引用不会被保留作为其他用途。 UserDict 实例提供了以下属性作为扩展方法和操作的支持: data一个真实的字典，用于保存 UserDict 类的内容。 UserList 对象这个类封装了列表对象。它是一个有用的基础类，对于你想自定义的类似列表的类，可以继承和覆盖现有的方法，也可以添加新的方法。这样我们可以对列表添加新的行为。 对这个类的需求已部分由直接创建 list 的子类的功能所替代；不过，这个类处理起来更容易，因为底层的列表可以作为属性来访问。 class collections.UserList([list])模拟一个列表。这个实例的内容被保存为一个正常列表，通过 UserList 的 data 属性存取。实例内容被初始化为一个 list 的copy，默认为 [] 空列表。 list 可以是迭代对象，比如一个Python列表，或者一个 UserList 对象。 UserList 提供了以下属性作为可变序列的方法和操作的扩展: data一个 list 对象用于存储 UserList 的内容。 子类化的要求: UserList 的子类需要提供一个构造器，可以无参数调用，或者一个参数调用。返回一个新序列的列表操作需要创建一个实现类的实例。它假定了构造器可以以一个参数进行调用，这个参数是一个序列对象，作为数据源。 如果一个分离的类不希望依照这个需求，所有的特殊方法就必须重写；请参照源代码进行修改。 UserString 对象UserString 类是用作字符串对象的外包装。对这个类的需求已部分由直接创建 str 的子类的功能所替代；不过，这个类处理起来更容易，因为底层的字符串可以作为属性来访问。 class collections.UserString(seq)模拟一个字符串对象。这个实例对象的内容保存为一个正常字符串，通过 UserString 的 data 属性存取。实例内容初始化设置为 seq 的copy。seq 参数可以是任何可通过内建 str() 函数转换为字符串的对象。 UserString 提供了以下属性作为字符串方法和操作的额外支持： data一个真正的 str 对象用来存放 UserString 类的内容。 在 3.5 版更改: 新方法 getnewargs, rmod, casefold, format_map, isprintable, 和 maketrans。 参考https://docs.python.org/zh-cn/3/library/collections.html#module-collections]]></content>
      <categories>
        <category>python</category>
        <category>module</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>module</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python pickle module]]></title>
    <url>%2Fpython%2Fmodule%2Fck9bgz83r00dvqov7ow19kcy8.html</url>
    <content type="text"><![CDATA[源代码： Lib/pickle.py pickle 模块实现了对一个 Python 对象结构的二进制序列化(pickling)和反序列化(unpickling)。 pickling 是将 Python 对象及其所拥有的层次结构转化为一个字节流的过程, unpickling 是相反的操作，会将字节流转化回一个对象层次结构。 注： pickle 模块并不安全。你只应该对你信任的数据进行unpickle操作。 与 json 模块的比较Pickle 协议和 JSON (JavaScript Object Notation) 间有着本质的不同： JSON 是一个文本序列化格式（它输出 unicode 文本，尽管在大多数时候它会接着以 utf-8 编码），而 pickle 是一个二进制序列化格式； JSON 是我们可以直观阅读的，而 pickle 不是； JSON是可互操作的，在Python系统之外广泛使用，而pickle则是Python专用的； 默认情况下，JSON 只能表示 Python 内置类型的子集，不能表示自定义的类；但 pickle 可以表示大量的 Python 数据类型（可以合理使用 Python 的对象内省功能自动地表示大多数类型，复杂情况可以通过实现 specific object APIs 来解决）。 不像pickle，对一个不信任的JSON进行反序列化的操作本身不会造成任意代码执行漏洞。 模块接口要序列化某个包含层次结构的对象，只需调用 dumps() 函数即可。同样，要反序列化数据流，可以调用 loads() 函数。但是，如果要对序列化和反序列化加以更多的控制，可以分别创建 Pickler 或 Unpickler 对象。 pickle模块包含了以下常量： pickle.HIGHEST_PROTOCOL整数，可用的最高 协议版本。此值可以作为 协议 值传递给 dump() 和 dumps() 函数，以及 Pickler 的构造函数。 pickle.DEFAULT_PROTOCOL整数，用于 pickle 数据的默认 协议版本。它可能小于 HIGHEST_PROTOCOL。它在 Python 3.4 中首次引入，与之前的版本不兼容。 在 3.0 版更改: 默认协议版本是 3。 在 3.8 版更改: 默认协议版本是 4。 pickle 模块提供了以下方法： pickle.dump(obj, file, protocol=None, *, fix_imports=True, buffer_callback=None)将对象 obj 封存以后的对象写入已打开的 file object file。它等同于 Pickler(file, protocol).dump(obj)。 参数 file、protocol、fix_imports 和 buffer_callback 的含义与它们在 Pickler 的构造函数中的含义相同。 在 3.8 版更改: 加入了 buffer_callback 参数。 pickle.dumps(obj, protocol=None, *, fix_imports=True, buffer_callback=None)将 obj 封存以后的对象作为 bytes 类型直接返回，而不是将其写入到文件。 参数 protocol、fix_imports 和 buffer_callback 的含义与它们在 Pickler 的构造函数中的含义相同。 在 3.8 版更改: 加入了 buffer_callback 参数。 pickle.load(file, *, fix_imports=True, encoding=”ASCII”, errors=”strict”, buffers=None)从已打开的 file object 文件 中读取封存后的对象，重建其中特定对象的层次结构并返回。它相当于 Unpickler(file).load()。 Pickle 协议版本是自动检测出来的，所以不需要参数来指定协议。封存对象以外的其他字节将被忽略。 参数 file、fix_imports、encoding、errors、strict 和 buffers 的含义与它们在 Unpickler 的构造函数中的含义相同。 在 3.8 版更改: 加入了 buffers 参数。 pickle.loads(bytes_object, *, fix_imports=True, encoding=”ASCII”, errors=”strict”, buffers=None)对于封存生成的对象 bytes_object，还原出原对象的结构并返回。 Pickle 协议版本是自动检测出来的，所以不需要参数来指定协议。封存对象以外的其他字节将被忽略。 参数 file、fix_imports、encoding、errors、strict 和 buffers 的含义与它们在 Unpickler 的构造函数中的含义相同。 在 3.8 版更改: 加入了 buffers 参数。 pickle 模块定义了以下 3 个异常： exception pickle.PickleError其他 pickle 异常的基类。它是 Exception 的一个子类。 exception pickle.PicklingError当 Pickler 遇到无法解封的对象时抛出此错误。它是 PickleError 的子类。 参考 可以被封存/解封的对象 来了解哪些对象可以被封存。 exception pickle.UnpicklingError当解封出错时抛出此异常，例如数据损坏或对象不安全。它是 PickleError 的子类。 注意，解封时可能还会抛出其他异常，包括（但不限于） AttributeError、EOFError、ImportError 和 IndexError。 pickle 模块包含了 3 个类，Pickler、Unpickler 和 PickleBuffer： class pickle.Pickler(file, protocol=None, *, fix_imports=True, buffer_callback=None)它接受一个二进制文件用于写入 pickle 数据流。 protocol ：可选参数，是一个整数，告知 pickler 使用指定的协议，可选择的协议范围从 0 到 HIGHEST_PROTOCOL。如果没有指定，这一参数默认值为 DEFAULT_PROTOCOL。指定一个负数就相当于指定 HIGHEST_PROTOCOL。 file：参数必须有一个 write() 方法，该 write() 方法要能接收字节作为其唯一参数。因此，它可以是一个打开的磁盘文件（用于写入二进制内容），也可以是一个 io.BytesIO 实例，也可以是满足这一接口的其他任何自定义对象。 fix_imports：参数如果为 True 且 protocol 小于 3，pickle 将尝试将 Python 3 中的新名称映射到 Python 2 中的旧模块名称，因此 Python 2 也可以读取封存的数据流。 buffer_callback ：参数如果为 None（默认情况），缓冲区视图（buffer view）将会作为 pickle 流的一部分被序列化到 file 中。如果 buffer_callback 不为 None，那它可以用缓冲区视图调用任意次。如果某次调用返回了 False 值（例如 None），则给定的缓冲区是 带外的，否则缓冲区是带内的（例如保存在了 pickle 流里面）。如果 buffer_callback 不是 None 且 protocol 是 None 或小于 5，就会出错。 在 3.8 版更改: 加入了 buffer_callback 参数。 dump(obj)将 obj 封存后的内容写入已打开的文件对象，该文件对象已经在构造函数中指定。 persistent_id(obj)默认无动作，子类继承重载时使用。 如果 persistent_id() 返回 None，obj 会被照常 pickle。如果返回其他值，Pickler 会将这个函数的返回值作为 obj 的持久化 ID（Pickler 本应得到序列化数据流并将其写入文件，若此函数有返回值，则得到此函数的返回值并写入文件）。这个持久化 ID 的解释应当定义在 Unpickler.persistent_load() 中（该方法定义还原对象的过程，并返回得到的对象）。 注意，persistent_id() 的返回值本身不能拥有持久化 ID。 dispatch_tablePickler 对象的 dispatch 表是 copyreg.pickle() 中用到的 reduction 函数 的注册。dispatch 表本身是一个 class 到其 reduction 函数的映射键值对。一个 reduction 函数只接受一个参数，就是其关联的 class，函数行为应当遵守 reduce() 接口规范。 Pickler 对象默认并没有 dispatch_table 属性，该对象默认使用 copyreg 模块中定义的全局 dispatch 表。如果要为特定 Pickler 对象自定义序列化过程，可以将 dispatch_table 属性设置为类字典对象（dict-like object）。另外，如果 Pickler 的子类设置了 dispatch_table 属性，则该子类的实例会使用这个表作为默认的 dispatch 表。 reducer_override(self, obj)可以在 Pickler 的子类中定义的特殊 reducer。此方法的优先级高于 dispatch_table 中的任何 reducer。它应该与 reduce() 方法遵循相同的接口，它也可以返回 NotImplemented，这将使用 dispatch_table 里注册的 reducer 来封存 obj。 fast已弃用。设为 True 则启用快速模式。快速模式禁用了“备忘录” (memo) 的使用，即不生成多余的 PUT 操作码来加快封存过程。不应将其与自指 (self-referential) 对象一起使用，否则将导致 Pickler 无限递归。 class pickle.Unpickler(file, *, fix_imports=True, encoding=”ASCII”, errors=”strict”, buffers=None)它接受一个二进制文件用于读取 pickle 数据流。 Pickle 协议版本是自动检测出来的，所以不需要参数来指定协议。 file ：参数必须有三个方法，read() 方法接受一个整数参数，readinto() 方法接受一个缓冲区作为参数，readline() 方法不需要参数，这与 io.BufferedIOBase 里定义的接口是相同的。因此 file 可以是一个磁盘上用于二进制读取的文件，也可以是一个 io.BytesIO 实例，也可以是满足这一接口的其他任何自定义对象。 fix_imports, encoding 和 errors：可选的参数是 ，用于控制由Python 2 生成的 pickle 流的兼容性。如果 fix_imports 为 True，则 pickle 将尝试将旧的 Python 2 名称映射到 Python 3 中对应的新名称。encoding 和 errors 参数告诉 pickle 如何解码 Python 2 存储的 8 位字符串实例；这两个参数默认分别为 ‘ASCII’ 和 ‘strict’。encoding 参数可置为 ‘bytes’ 来将这些 8 位字符串实例读取为字节对象。读取 NumPy array 和 Python 2 存储的 datetime、date 和 time 实例时，请使用 encoding=’latin1’。 buffers ：如果为 None（默认值），则反序列化所需的所有数据都必须包含在 pickle 流中。这意味着在实例化 Pickler 时（或调用 dump() 或 dumps() 时），参数 buffer_callback 为 None。如果 buffers 不为 None，则每次 pickle 流引用 带外 缓冲区视图时，消耗的对象都应该是可迭代的启用缓冲区的对象。这样的缓冲区应该按顺序地提供给 Pickler 对象的 buffer_callback 方法。 在 3.8 版更改: 加入了 buffers 参数。 load()从构造函数中指定的文件对象里读取封存好的对象，重建其中特定对象的层次结构并返回。封存对象以外的其他字节将被忽略。 persistent_load(pid)默认抛出 UnpicklingError 异常。 如果定义了此方法，persistent_load() 应当返回持久化 ID pid 所指定的对象。 如果遇到无效的持久化 ID，则应当引发 UnpicklingError。 find_class(module, name)如有必要，导入 module 模块并返回其中名叫 name 的对象，其中 module 和 name 参数都是 str 对象。注意，不要被这个函数的名字迷惑， find_class() 同样可以用来导入函数。 子类可以重载此方法，来控制加载对象的类型和加载对象的方式，从而尽可能降低安全风险。 class pickle.PickleBuffer(buffer)缓冲区的包装器 (wrapper)，缓冲区中包含着可封存的数据。 buffer 必须是一个 buffer-providing 对象，比如 bytes-like object 或多维数组。 PickleBuffer 本身就可以生成缓冲区对象，因此可以将其传递给需要缓冲区生成器的其他 API，比如 memoryview。 PickleBuffer 对象只能用 pickle 版本 5 及以上协议进行序列化。它们符合 带外序列化 的条件。 3.8 新版功能. raw()返回该缓冲区底层内存区域的 memoryview。 返回的对象是一维的、C 连续布局的 memoryview，格式为 B (无符号字节)。 如果缓冲区既不是 C 连续布局也不是 Fortran 连续布局的，则抛出 BufferError 异常。 release()释放由 PickleBuffer 占用的底层缓冲区。 示例请使用 dump() 函数 123456789101112import pickle# An arbitrary collection of objects supported by pickle.data = &#123; 'a': [1, 2.0, 3, 4+6j], 'b': ("character string", b"byte string"), 'c': &#123;None, True, False&#125;&#125;with open('data.pickle', 'wb') as f: # Pickle the 'data' dictionary using the highest protocol available. pickle.dump(data, f, pickle.HIGHEST_PROTOCOL) 请使用 load() 函数 123456import picklewith open('data.pickle', 'rb') as f: # The protocol version used is detected automatically, so we do not # have to specify it. data = pickle.load(f) 参考https://docs.python.org/zh-cn/3/library/pickle.html#module-pickle]]></content>
      <categories>
        <category>python</category>
        <category>module</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>module</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[window搭建spark及hadoop开发环境.md]]></title>
    <url>%2Fbigdata%2Fck9bgz7lh002yqov7rxljr53v.html</url>
    <content type="text"><![CDATA[由于Spark是用Scala来写的，所以Spark对Scala肯定是原生态支持的，因此这里以Scala为主来介绍Spark环境的搭建，主要包括四个步骤，分别是：JDK的安装，Scala的安装，Spark的安装，Hadoop的下载和配置。 JDK的安装下载下载地址：http://www.oracle.com/technetwork/java/javase/downloads/index.html 安装双击后傻瓜式安装，安装完成后输入以下命令验证 123javajavacjava -version 环境变量设置设置方法在桌面右击【计算机】－－【属性】－－【高级系统设置】，然后在系统属性里选择【高级】－－【环境变量】，然后在系统变量中找到“Path”变量，并选择“编辑”按钮 设置变量 在新建页面输入”变量名”位 JAVA_HOME,输入“变量值”为你安装的JDK地址 1JAVA_HOME=E:\Java\jdk1.8.0_144 在系统变量区域，选择”新建按钮”输入”变量名”为CLASSPATH,输入”变量值”为.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar 1CLASSPATH=.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar 在系统变量区域，选择Path,点击下面的编辑按钮，在弹出的框中选择新建添加2行，一行输入%JAVA_HOME%\bin，一行输入%JAVA_HOME%\jre\bin 1;%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin; Scala的安装下载下载地址：http://www.scala-lang.org/ 安装双击下载得到Scala的msi文件，可执行安装。 输入下面命令验证 12345C:\Users\Mr wang&gt;scalaWelcome to Scala 2.13.1 (Java HotSpot(TM) Client VM, Java 1.8.0_144).Type in expressions for evaluation. Or try :help.scala&gt; 注：如果不能显示版本信息，并且未能进入Scala的交互命令行，通常有两种可能性： Path系统变量中未能正确添加Scala安装目录下的bin文件夹路径名，按照JDK安装中介绍的方法添加即可。 Scala未能够正确安装，重复上面的步骤即可。 Spark的安装下载下载地址：http://spark.apache.org/ 1wget http://mirrors.tuna.tsinghua.edu.cn/apache/spark/spark-2.4.4/spark-2.4.4-bin-hadoop2.7.tgz 安装解压后即可 注：spark的解压路径中不要有空格等 设置环境变量12345新增SPARK_HOME环境变量SPARK_HOME=E:\bigdata\spark-2.4.4-bin-hadoop2.7配置path环境变量%SPARK_HOME%\bin; 异常处理12C:\Users\Mr wang&gt;spark-shell系统找不到指定的路径。 出现上述错误 检查是否正确配置了spark环境变量 SPARK_HOME=spark_install_path path=…;%SPARK_HOME%\bin 检查是否正确配置了java环境变量 JAVA_HOME=java_install_path path=…;%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin; Hadoop安装下载下载地址：https://archive.apache.org/dist/hadoop/common/ 1wget https://archive.apache.org/dist/hadoop/common/hadoop-2.7.6/hadoop-2.7.6.tar.gz 安装解压到指定目录 设置环境变量12345# 新增HADOOP_HOME环境变量HADOOP_HOME=E:\bigdata\hadoop-2.7.6# 添加path变量path=;%HADOOP_HOME%\bin 参考Spark在Windows下的环境搭建]]></content>
      <categories>
        <category>bigdata</category>
      </categories>
      <tags>
        <tag>bigdata</tag>
        <tag>spark</tag>
        <tag>hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[window使用随记]]></title>
    <url>%2Fwindow%2Fck9bgz7b1000gqov7c3a04gwg.html</url>
    <content type="text"><![CDATA[主要记录window使用的一些命令和使用技巧。 WIN7下查看CPU核心数方法一: WIN+R输入cmd 输入wmic ,输入cpu get * 找到numberofcores和numberoflogicalprocessors 12NumberOfCores NumberOfEnabledCore NumberOfLogicalProcessors2 2 4 方法二： 桌面计算机图标 &gt; 计算机右键 &gt; 管理 &gt; 设备管理器 &gt; 处理器 方法三： 任务管理器 &gt; 性能]]></content>
      <categories>
        <category>window</category>
      </categories>
      <tags>
        <tag>window</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vscode 编辑java程序插件]]></title>
    <url>%2Fjava%2Fck9bgz7nc004kqov7axgiqapu.html</url>
    <content type="text"><![CDATA[VS Code is a fast editor and ships with great editing features. Add Java language support to VS Code by installing the popular Java extensions. To help set up Java on VS Code, there is a Java Extension Pack, which contains the most popular extensions for most Java developers: Language Support for Java(TM) by Red Hat Debugger for Java Java Test Runner Maven for Java Java Dependency Viewer There are also other popular Java extensions you can pick for your own needs, including: Spring Boot Tools Spring Initializr Java Support Spring Boot Dashboard Tomcat Jetty CheckStyle]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java学习笔记]]></title>
    <url>%2Fjava%2Fck9bgz82z00d7qov7m2kfila5.html</url>
    <content type="text"><![CDATA[java学习随记 Java简介Java最早是由SUN公司（已被Oracle收购）的詹姆斯·高斯林（高司令，人称Java之父）在上个世纪90年代初开发的一种编程语言，最初被命名为Oak，目标是针对小型家电设备的嵌入式应用，结果市场没啥反响。谁料到互联网的崛起，让Oak重新焕发了生机，于是SUN公司改造了Oak，在1995年以Java的名称正式发布，原因是Oak已经被人注册了，因此SUN注册了Java这个商标。随着互联网的高速发展，Java逐渐成为最重要的网络编程语言。 Java介于编译型语言和解释型语言之间。 随着Java的发展，SUN给Java又分出了三个不同版本： Java SE：Standard Edition Java EE：Enterprise Edition Java ME：Micro Edition 简单来说，Java SE就是标准版，包含标准的JVM和标准库，而Java EE是企业版，它只是在Java SE的基础上加上了大量的API和库，以便方便开发Web应用、数据库、消息服务等，Java EE的应用使用的虚拟机和Java SE完全相同。 名词解释： JDK：Java Development Kit JRE：Java Runtime Environment 1JRE就是运行Java字节码的虚拟机。但是，如果只有Java源码，要编译成Java字节码，就需要JDK，因为JDK除了包含JRE，还提供了编译器、调试器等开发工具。 JSR规范：Java Specification Request JCP组织：Java Community Process 1JSR是一系列的规范，从JVM的内存模型到Web程序接口，全部都标准化了。而负责审核JSR的组织就是JCP。 Java注释单行注释1// 注释内容 多行注释12345/*注释内容注释内容注释内容*/ javadoc注释，可被javadoc.exe解析为java帮助文档。 12345/*** 注释内容* 注释内容* 注释内容*/ 第一个代码说明123456789101112131415// public 表示公开的// class 表示定义一个类// HelloWorld 表示一个类名public class HelloWorld&#123; /** public 表示公开的 static 表示静态的 void 表示空 main 表示方法名是main (String [] args) 是main方法的形式参数列表 */ public static void main(String [] args)&#123; System.out.println("hello world..."); &#125;&#125; public class 和 class的区别 一个java源文件中可以定义多个class 一个java源文件中public class不是必须的 一个java源文件中若定义多个class，编译后每一个class会生成相应的xxx.class字节码文件 一个java源文件中如定义public class类，只能有一个，名字和文件名相同 每一个class中都可以编写main方法，都可以设定程序的入口 在调用java xxx时，xxx中须有主方法public static void main(String [] args)。 标识符什么是标识符用于表示类名、方法名、变量名、接口名、常量名等有效字符的组合。 标识符的命名规则 只能由数字、字母、下划线(_)和美元符号($)组成 不能以数字开头 严格区分大小写 关键字不能做标识符 理论上长度不限制，但不要太长 标识符的命名规范 见名知意 遵守驼峰命名方式 类名、接口名：采用大驼峰 变量名、方法名：采用小驼峰 常量名：采用全部大写 关键字https://www.cnblogs.com/chenglc/p/6922834.html java语言的变量什么是变量 变量是指向内存中的一块空间，这块空间有数据类型、名字和字面值 变量包括三部分：数据类型、名字和字面值 变量是内存中数据存储的最基本单元 数据类型的作用 不用的数据有不同的数据类型，不同的数据类型底层会分配不同大小的空间 数据类型是程序在运行期间应该分配多大的内存空间 变量的要求变量中存储的数据必须和其对应的数据类型一致，否则编译出错。 变量的声明和赋值声明1数据类型 变量名; 示例： 12int age;int a, b, c; 赋值1变量名 = 字面值; 初始化并赋值1数据类型 变量名 = 字面值; 12345678910int age = 25;int a, b, c = 200;int c = 300; //重复声明，编译出错注： 多变量赋值是，前面变量只进行声明，只有最后一个声明并赋值。 在同一个命名空间里，同一个变量只能声明一次，否则编译出错 PS D:\Practice\Java&gt; javac .\2p\Variable.java .\2p\Variable.java:10: 错误: 已在方法 main(String[])中定义了变量 c int c = 300; ^ 示例： 1234567891011public class Variable&#123; public static void main(String [] args)&#123; int i; i = 100; System.out.println(i); int a, b, c = 200; System.out.println(a); // 未赋值， 编译出错 System.out.println(b); // 未赋值， 编译出错 System.out.println(c); // 200 &#125;&#125; 变量的分类根据变量声明的位置 局部变量：方法体中的变量 成员变量：类体中的变量 12345678910111213141516public class Variable&#123; /* 类体中不能写java语句，可以声明变量 */ static int age = 25; // 成员变量 static int value; // 成员变量会默认赋值 public static void main(String [] args)&#123; int i; // 局部变量 i = 100; // int i = 100; System.out.println(i); // 100 System.out.println(age); // 25 System.out.println(value); // 0 &#125;&#125; java语言的数据类型数据类型的作用JVM在运行程序的时候根据数据类型来分配内存空间 数据类型分类 基本数据类型 整数型(byte, short, int, long) 浮点型(float, double) 布尔型(boolean) 字符型(char) 引用数据新类型 字符串(string) 八种基本数据类型各自占用的空间大小及默认值1234567891011基本数据类型 占用空间大小(Byte) 默认值byte 1 0short 2 0int 4 0long 8 0float 4 0.0double 8 0.0boolean 1 falsechar 2 \u0000# 数据类型的默认值趋向于0 char数据类型语法1234567891011public class DataTypeChar&#123; public static void main(String [] args)&#123; //声明后赋值 char varName; varName = 'a'; // 赋值初始化 char varName1 = 'a'; char varName2 = '爱'; &#125;&#125; 转译字符 转义字符 意义 ASCII码值（十进制 \b 退格(BS) ，将当前位置移到前一列 008 \f 换页(FF)，将当前位置移到下页开头 012 \n 换行(LF) ，将当前位置移到下一行开头 010 \r 回车(CR) ，将当前位置移到本行开头 013 \t 水平制表(HT) （跳到下一个TAB位置） 009 \v 垂直制表(VT) 011 \ 代表一个反斜线字符’’&#39; 092 &#39; 代表一个单引号（撇号）字符 039 &quot; 代表一个双引号字符 034 \0 空字符(NULL) 000 \ddd 1到3位八进制数所代表的任意字符 三位八进制 \uhhhh 1到2位十六进制所代表的任意字符 二位十六进制 整数型java整数型默认为int型，若要使用长整形，数字后加上l或L。 java语言整数型字面值有三种表现形式 十进制：缺省默认方式 八进制：数字以0开头 十六进制：数字以0x开头 示例： 12345678910public class DataTypeTest&#123; public static void main(String [] args)&#123; int a = 10; // 默认，十进制 int b = 012; // 八进制 int c = 0xa; // 十六进制 System.out.println(a); // 10 System.out.println(b); // 10 System.out.println(c); // 10 &#125;&#125; 类型转换 java中整数型默认为int,占4个字节。 1234// 声明数据类型为int的变量a// 将数据类型为int的100字面值复制给变量a// 这里不存在数据类型转换int a = 100; 12345// 声明数据类型为 long 的变量 b// 将数据类型为int的100字面值复制给变量b// 这里存在数据类型转换// 小容量赋值给大容量，程序不会报错long b = 100; 12long c = 100L;int d = c; // 大容量数据赋值给小容量数据，编译出错 强制类型转换原理 12345long c = 100L;int d = (int)c;//long 100L --&gt; 0000000 0000000 0000000 0000000 0000000 0000000 0000000 01100100//int 100 --&gt; 0000000 0000000 0000000 01100100 浮点型java中浮点型默认为double型。 123float f1 = 5.1ffloat f = 5.1; // 编译出错，5.1为double, f为float型。 布尔型在java中，boolean型只有true和false两个值。 12boolean flag = true;boolean mark = false; 基本数据类型转换规则 基本类型中除boolean类型外，其它7种类型之间都可以转换。 小容量向大容量转换称为自动类型转换，容量从小到大排序： byte &lt; short / char &lt; int &lt; long &lt; float &lt; double 大容量转换为小容量称为强制类型转换，需要加强制类型转换符，可能会损失精度。 当整数字面值没有超过byte、short、char的取值范围，可直接赋值 byte、short、char混合运算时，先各自转换成int类型再做运算。 多种数据类型混合运算时，先转换成容量最大的那个再做运算。 运算符算数运算符12345678910111213141516/*+ - * / % ++ 自增-- 自减*/public class OperatorTest&#123; public static void main(String [] args)&#123; int x = 10; int y = 3; System.out.println(x + y); // 13 System.out.println(x - y); // 7 System.out.println(x * y); // 30 System.out.println(x / y); // 3 System.out.println(x % y); // 1 &#125;&#125; 关系运算符123456789101112public class OperatorTest&#123; public static void main(String [] args)&#123; int x = 10; int y = 10; System.out.println(x == y); // true System.out.println(x != y); // false System.out.println(x &gt; y); // false System.out.println(x &gt;= y); // true System.out.println(x &lt; y); // false System.out.println(x &lt;= y); // true &#125;&#125; 逻辑运算符123456789101112/*&amp; 逻辑与| 逻辑或! 逻辑非^ 逻辑异或&amp;&amp; 短路与|| 短路货逻辑运算符要求两边的算子都是boolean类型，结果也是boolean类型。短路与和逻辑与运算结果相同，短路或和逻辑或运算结果相同。*/ 赋值运算符12345678910111213141516/*基本赋值运算符= 扩展赋值运算符+= -= *= /= */public class OperatorTest&#123; public static void main(String [] args)&#123; int x = 10; x = x + 10; // x += 10; System.out.println(x); // 20 &#125;&#125; 1234byte a = 10;a = a + 5; //编译出错，int型赋值给byte型a += 5; 注：扩展类的赋值运算符不改变数据类型 字符串连接运算符12345678/*+ 自左向右依次运算，结果为字符串*/int a = 10;int b = 20;System.out.println(a + " + " + b "=" (a + b)) // a + b = 30 三目运算符1布尔表达式 ? 值一 : 值二 12char sex = true ? '女' : '男';System.out.println(sex); 控制语句选择语句123ifif ... else ...switch if 语法1234567if(布尔表达式)&#123; java 语句; java 语句; ...&#125;if(布尔表达式) java 语句; 123456789if(布尔表达式)&#123; java 语句; java 语句; ...&#125; else&#123; java 语句; java 语句; ...&#125; 12345678910111213if(布尔表达式)&#123; java 语句; java 语句; ...&#125; else if(布尔表达式)&#123; java 语句; java 语句; ...&#125; else &#123; java 语句; java 语句; ...&#125; 示例： 123456789101112131415161718192021222324public class TestIf&#123; public static void main(String [] args)&#123; double distance = 6.0; if(distance &lt; 5)&#123; System.out.println("小于5"); &#125; else &#123; System.out.println("不小于5"); &#125; double score = 60.0; if(score &gt; 100 || score &lt; 0)&#123; System.out.println("成绩不合法"); &#125;else if(score &gt;= 60)&#123; System.out.println("成绩合格"); &#125;else&#123; System.out.println("成绩不合格"); &#125; String grade = "成绩不合格"; if(score &gt; 100 || score &lt; 0) grade = "成绩不合法"; else if(score &gt;= 60) grade = "成绩合格"; System.out.println(grade); &#125;&#125; switch语句语法12345678910111213switch(int or String字面值或变量:)&#123; case int or String字面值或变量: java 语句; ... break; case int or String字面值或变量: java 语句; ... break; default: java 语句; ...&#125; switch case合并 12345switch (int or String)&#123; case 1: case 2: case 3: java语句; break;&#125; 注意事项 switch后只能是int或String，不能是别的 123456789public class SwitchTest&#123; public static void main(String [] args)&#123; long num = 10L; switch (num)&#123; // 编译出错，num是long类型，要求是int类型 case 10: System.out.println("10"); &#125; &#125;&#125; switch后若是char类型，最后会转换为int类型，在进行匹配。 12345678910public class SwitchTest&#123; public static void main(String [] args)&#123; char a = 'a'; switch(a)&#123; case 97: System.out.println("a is 97"); break; &#125; &#125;&#125; 示例123456789101112131415161718192021222324252627282930313233343536373839public class SwitchTest&#123; public static void main(String [] args)&#123; java.util.Scanner s = new java.util.Scanner(System.in); System.out.print("请输入第一个数字："); int x = s.nextInt(); System.out.print("请输入运算符："); String operator = s.next(); System.out.print("请输入第二个数字："); int y = s.nextInt(); String result = x + operator + y + " = "; switch(operator)&#123; case "+": System.out.println(result + (x + y)); break; case "-": System.out.println(result + (x - y)); break; case "*": System.out.println(result + (x * y)); break; case "/": if(y == 0)&#123; System.out.println("除数不能为零"); break; &#125; System.out.println(result + (x / y)); break; case "%": if(y == 0)&#123; System.out.println("除数不能为零"); break; &#125; System.out.println(result + (x % y)); break; default: System.out.println("输入不合法"); &#125; &#125;&#125; 循环语句123forwhiledo ... while() for循环123456789101112131415161718public class ForTest&#123; public static void main(String [] args)&#123; for(int i = 0; i &lt; 10; i++)&#123; System.out.println(i); &#125; int j = 10; for(; j&gt; 0; j--)&#123; System.out.println("j ==&gt; " + j); &#125; System.out.println(j); for(int i=1; i &lt;= 100; i+=2)&#123; System.out.println(i); // i += 2; &#125; &#125;&#125; 示例打印 9*9 乘法表 123456789101112131415161718192021222324// 打印 9*9 乘法表public class ForTest&#123; public static void main(String [] args)&#123; for(int i=1;i&lt;10;i++)&#123; for(int j=1;j&lt;=i;j++)&#123; System.out.print(j + "*" + i + "=" + (i * j)); System.out.print(" "); &#125; System.out.println(); &#125; &#125;&#125;// resultD:\Practice\Java&gt;java ForTest1*1=11*2=2 2*2=41*3=3 2*3=6 3*3=91*4=4 2*4=8 3*4=12 4*4=161*5=5 2*5=10 3*5=15 4*5=20 5*5=251*6=6 2*6=12 3*6=18 4*6=24 5*6=30 6*6=361*7=7 2*7=14 3*7=21 4*7=28 5*7=35 6*7=42 7*7=491*8=8 2*8=16 3*8=24 4*8=32 5*8=40 6*8=48 7*8=56 8*8=641*9=9 2*9=18 3*9=27 4*9=36 5*9=45 6*9=54 7*9=63 8*9=72 9*9=81 打印 1000内的质数，每8个显示一行 1234567891011121314151617181920public class ForTest&#123; public static void main(String [] args)&#123; int count = 0; boolean mark = true; for(int i=2; i &lt;= 10000; i++)&#123; for(int j=2;j&lt;i/2 + 1;j++)&#123; if(i % j ==0)&#123; mark = false; break; &#125; mark = true; &#125; if(!mark)&#123; count++; if(count % 8 ==0) System.out.println(i + " "); else System.out.print(i+ " "); &#125; &#125; &#125;&#125; while / do … while循环12345678910111213141516public class WhileTest&#123; public static void main(String [] args)&#123; int i = 1; // while 循环 while(i &lt;= 10)&#123; System.out.println(i); i++; &#125; // do ... while 循环 do&#123; System.out.println(i); i--; &#125;while(i&gt;0); &#125;&#125; 控制循环语句12breakcontinue break语句 break是java中的关键字 break;是一个完整的语句 break语句用在switch语句、循环语句等当中用来终止程序的执行 break语句默认终止当前循环，也可以指定终止某一个循环，需给该循环起名 123456789101112public class BreakTest&#123; public static void main(String [] args)&#123; outerFor:for(int i=1; i&lt;10; i++)&#123; innerFor:for(int j=10; j&gt;0; j--)&#123; System.out.println(j); if(5 == j)&#123; break outerFor; &#125; &#125; &#125; &#125;&#125; continue 语句 continue是java中的一个关键字 continue;是一个完整的语句 continue语句默认继续当前循环，也可以指定继续某一个循环，需给该循环起名 键盘输入1234java.util.Scanner s = new java.util.Scanner(System.in);System.out.print("提示信息：");String str = s.next(); // 接收字符串int num = s.nextInt(); // 接收整数 java 方法方法的定义123[修饰符列表] 返回值类型 方法名(形参列表)&#123; 方法体&#125; 修饰符列表： 可选项，不是必须的 方法中有static关键字，调用方式：ClassName.methodName(实参列表) 返回值类型： 可以是java的任意一种数据类型 返回值类型是void，方法没有返回值。 返回值类型不是void，必须有返回值，且返回值的类型与声明的返回值类型保持一致。 方法名： 合法的标识符 命名应见名知意 方法名尽量使用动词 方法名使用小驼峰命名 说明 方法定义在类体当中，类体中可以定义多个方法 方法中不能在定义方法 方法执行过程中内存的分配 方法只定义，不调用，不会执行。JVM也不会给该方法分配运行所需的内存空间。只有再调用这个方法时，才会动态的给所调用的方法分配所需的内存空间。 JVM在内存划分上有三个主要的内存空间： 方法区内存 堆内存 栈内存 数据结构 数据结构反应的是数据的存储形态 常见的数据结构 数组 队列 栈 链表 二叉树 哈希表 / 散列表 关于栈数据结构 栈 - stack，是一种数据结构 栈帧永远指向栈顶元素 栈顶元素出于活跃状态，其它元素处于静止状态 栈术语 压栈 / 入栈(push) 弹栈 / 出栈(pop) 栈数据结构存储数据的特点 先进后出 / 后进先出 方法代码片段在哪里？ 方法代码片段属于class字节码文件的一部分 字节码文件在JVM加载后存储于方法区内内存中 方法区内存中最先有数据，存放代码片段 方法调用后，会在栈中给该方法分配内存空间(压栈动作) 方法结束后，会释放栈中所分配的内存空间(弹栈动作) 局部变量在栈中分配内存 示例1234567891011121314151617public class MethodTest&#123; public static void main(String [] args)&#123; MethodTest.sum(1， 2); sumInt(10, 20); // 接收函数结果，变量类型须与返回值类型相同 int product = productInt(10, 2); &#125; public static void sum(long a, long b)&#123; System.out.println(a + " + " + b + " = " + a + b); &#125; public static int productInt(int x, int y)&#123; return x * y &#125;&#125; 方法重载说明 方法重载又被称为overload 功能相同，可以使用方法重载，让方法名形同 123456789101112public class OverloadTest&#123; public static void main(String [] args)&#123; //方法参数列表不同 public static void method1(); public static void method1(int a); //方法参数类型不同 public static void method2(double a); public static void method2(int a); public static void method2(long a); &#125;&#125; 方法重载和方法名+参数列表有关 方法重载和返回值类型无关 方法重载和修饰符列表无关 示例12345678910111213141516171819public class MethodTest&#123; public static void main(String [] args)&#123; System.out.println("int sum: " + sum(10, 20)); System.out.println("double sum: " + sum(10.0, 20.0)); System.out.println("long sum: " + sum(10L, 20)); &#125; public static int sum(int a, int b)&#123; return a + b; &#125; public static double sum(double a, double b)&#123; return a + b; &#125; public static long sum(long a, long b)&#123; return a + b; &#125;&#125; java面向对象三大特质 封装 继承 多态 三个阶段 面向对象的分析：OOA (Object-Oriented Analysis) 面向对象的设计：OOD (Object-Oriented Design) 面向对象的编程：OOP (Object - Oriented Programming) 类和对象的概念什么是类 类在现实世界中是不存在的，是人为抽象的一个概念 类代表现实世界中具有相同属性和行为的一类事物 什么是对象 对象是现实世界中真实存在的个体 类与对象的关系 类 –&gt; 实例化为 –&gt; 对象 对象 –&gt; 抽象为 –&gt; 类 对象又称为实例 对象的创建和使用123456789101112131415161718192021222324252627282930// Husband.javapublic class Husband&#123; String name; short age; Wife wife;&#125;//Wife.javapublic class Wife&#123; String name; short age; Husband husband;&#125;//OOPTest.javapublic class OOPTest&#123; public static void main(String [] args) &#123; Husband Jack = new Husband(); Wife lucy = new Wife(); Jack.name = "Jack"; lucy.name = "lucy"; Jack.wife = lucy; lucy.husband = Jack; System.out.println("Jack的wife是" + Jack.wife.name); System.out.println("Lucy的husband是" + lucy.husband.name); &#125;&#125; JVM的内存管理 JVM主要包括三块内存：方法去内存、栈内存和堆内存 堆内存和方法去内存各有一个，栈内存一个线程一个 方法及类的代码片段在加载时会存储于方法去内存中 方法调用是所需的内存在栈内存中分配，即压栈；方法调用结束后，栈中分配的内存将释放，即弹栈 在程序执行过程中使用new关键字创建java对象时，所创建的实例将会存储于堆内存当中 变量分类 成员变量（方法体外声明的变量） 实例变量（没有static修饰符） 静态变量（有static修饰符） 静态变量存储于方法区内存当中 局部变量（方法体中声明的变量） 三块内存当中频繁变化的是栈内存，最先有数据的是方法去内存，垃圾回收主要针对堆内存 垃圾回收器（自动垃圾回收、gc机制） 当内存中java对象没有被引用或无法使用时将是为垃圾，会自动回收 类的封装类的构造方法 构造方法又称为构造函数或构造器 构造方法的语法 123[类型修饰符] 构造方法名(形参列表)&#123; 构造方法体;&#125; 普通方法的语法 123[类型修饰符] 返回值类型 方法名(形参列表)&#123; 方法体;&#125; 构造方法无返回值类型，若加上，则为普通方法 对于构造方法来说，构造方法的方法名必须和类名保持一致 构造方法的作用 通过调用构造方法可以创建对象 初始化实例变量 构造方法调用 1constructorName var = new constructorName(para); 当类中没有构造方法时，系统会提供一个默认的无参数构造方法，称为缺省构造方法 当一个类中构造方法被定义后，就不会调用默认的缺省构造方法 构造方法可以重载 类的继承作用 代码复用 方法覆盖 多态机制 语法123[修饰符列表] class 类名 extends&#123; 类体 = 属性 + 方法;&#125; 关于继承的一些术语 B类继承于A类 A类称为：父类、基类、超类、superclass B类称为：子类、派生类、subclass java类只支持单继承，不支持多继承 子类继承于父类的数据 私有地不支持继承 构造方法不支持继承 其他数据都可以继承 java类可以间接继承其他类 123A extends B&#123;&#125;B extends C&#123;&#125;c extends D&#123;&#125; java 类默认继承自java.lang.Object类 java方法的覆盖（重写） 私有方法不能覆盖 构造方法不能覆盖 覆盖只针对方法，不涉及属性 类的多态涉及的概念 向上转型(upcasting) 子类型 –&gt; 父类型 自动类型转换 向下转型(downcasting) 父类型 –&gt; 子类型 强制类型转换（需加强之类型转换符） java允许父类型引用子类型对象 转型之间必须存在继承关系 关键字this关键字 this是一个引用 构造方法使用this(para)可以调用其它的构造方法，且只能出现在第一行 static关键字 带有static关键字的变量和方法为静态变量和类方法，通过类名调用或实例调用 不带有static关键字的变量和方法为实例变量和实例方法，通过实例调用 使用static定义静态代码块 语法 123static&#123; java语句;&#125; 静态代码块在类加载时执行，且只执行一次。 静态代码块在类中可以编写多个 通常在静态代码块中完成数据的准备工作 123456789101112131415161718public class Chinese &#123; String id; String name; String city; static String country = "China"; static &#123; System.out.println("开始调用Chinese类。。。"); &#125; public Chinese() &#123;&#125; public Chinese(String id, String name, String city) &#123; this.id = id; this.name = name; this.city = city; &#125;&#125; final关键字 final表示最终的，不可变的 final修饰的类无法继承 final修饰的方法无法覆盖 final修饰的变量赋值后不可更改 final修饰的成员变量中的实例变量需要给其赋初始值，不能用默认值 12345678public class Test&#123; final String name = "Jack"; // 需要赋初始值，否则编译出错 final int age; public Test()&#123; this.age = 20; &#125;&#125; final修饰的引用，一旦指向某个对象后，不能在指向其它对象 final和static一般连用，表示一个常量 123public class Test&#123; static final double PI = 3.141592654;&#125; 使用技巧中文转译为unicode码1234&#123;JAVA_HOME&#125;/bin/native2ascii.exe# &lt;Enter&gt;# 输入中文&lt;Enter&gt;即可 异常处理使用cmd命令出现“HelloWorld.java:3: 错误: 编码GBK的不可映射字符”解决方案方法一： 1javac -encoding utf-8 HelloWorld.java 方法二： 更改文件编码，如以GB2312编码方式保存文件。 1javac HelloWorld.java]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 杂记]]></title>
    <url>%2FLinux%2Fck9bgz7qq007jqov72ld4rcp6.html</url>
    <content type="text"><![CDATA[记录Linux相关的知识或使用技巧。 Linux放行8080端口以centos7为例： 查看防火墙状态 firewall-cmd --state 123[root@hadoop01 ~]# firewall-cmd --staterunning[root@hadoop01 ~]# systemctl status firewalld.service 1234567891011121314151617181920212223[root@hadoop01 ~]# systemctl status firewalld.service● firewalld.service - firewalld - dynamic firewall daemon Loaded: loaded (/usr/lib/systemd/system/firewalld.service; enabled; vendor preset: enabled) Active: active (running) since Sat 2020-03-14 05:38:19 CST; 16min ago Docs: man:firewalld(1) Main PID: 9269 (firewalld) Tasks: 2 Memory: 25.6M CGroup: /system.slice/firewalld.service └─9269 /usr/bin/python -Es /usr/sbin/firewalld --nofork --nopidMar 14 05:38:20 hadoop01 firewalld[9269]: WARNING: COMMAND_FAILED: '/usr/sbin/iptables -w2 -w --table filter --delete FORWARD -...hain?).Mar 14 05:38:20 hadoop01 firewalld[9269]: WARNING: COMMAND_FAILED: '/usr/sbin/iptables -w2 -w --table filter --delete FORWARD -...hain?).Mar 14 05:38:20 hadoop01 firewalld[9269]: WARNING: COMMAND_FAILED: '/usr/sbin/iptables -w2 -w --table filter --delete FORWARD -...hain?).Mar 14 05:38:21 hadoop01 firewalld[9269]: WARNING: COMMAND_FAILED: '/usr/sbin/iptables -w2 -w --table filter --delete FORWARD -...t name.Mar 14 05:38:21 hadoop01 firewalld[9269]: WARNING: COMMAND_FAILED: '/usr/sbin/iptables -w2 -w --table filter --delete FORWARD -...t name.Mar 14 05:38:21 hadoop01 firewalld[9269]: WARNING: COMMAND_FAILED: '/usr/sbin/iptables -w2 -w --table filter --delete INPUT --i...hain?).Mar 14 05:38:21 hadoop01 firewalld[9269]: WARNING: COMMAND_FAILED: '/usr/sbin/iptables -w2 -w --table filter --delete INPUT --i...hain?).Mar 14 05:38:21 hadoop01 firewalld[9269]: WARNING: COMMAND_FAILED: '/usr/sbin/iptables -w2 -w --table filter --delete OUTPUT --...hain?).Mar 14 05:38:21 hadoop01 firewalld[9269]: WARNING: COMMAND_FAILED: '/usr/sbin/iptables -w2 -w --table filter --delete INPUT --i...hain?).Mar 14 05:38:21 hadoop01 firewalld[9269]: WARNING: COMMAND_FAILED: '/usr/sbin/iptables -w2 -w --table filter --delete INPUT --i...hain?).Hint: Some lines were ellipsized, use -l to show in full.[root@hadoop01 ~]# 开启防火墙 systemctl start firewalld.service 12[root@hadoop01 ~]# systemctl start firewalld.service[root@hadoop01 ~]# 开启8080端口 firewall-cmd --zone=public --add-port=8080/tcp --permanent 123[root@hadoop01 ~]# firewall-cmd --zone=public --add-port=8080/tcp --permanentsuccess[root@hadoop01 ~]# –zone=public：表示作用域为公共的； –add-port=8080/tcp：添加tcp协议的端口8080； –permanent：永久生效，如果没有此参数，则只能维持当前服务生命周期内，重新启动后失效； 重启防火墙 systemctl restart firewalld.service 12[root@hadoop01 ~]# systemctl restart firewalld.service[root@hadoop01 ~]# 重新载入配置 firewall-cmd --reload 12[root@hadoop01 ~]# firewall-cmd --reloadsuccess firewall-cmd用法firewall-cmd 使用总结 Linux卸载java-1.8 查看已安装java rpm -qa | grep jdk 1234567[root@hadoop01 ~]# rpm -qa | grep jdkcopy-jdk-configs-3.3-10.el7_5.noarchjava-1.8.0-openjdk-headless-1.8.0.181-7.b13.el7.x86_64java-1.8.0-openjdk-1.8.0.181-7.b13.el7.x86_64java-1.7.0-openjdk-1.7.0.191-2.6.15.5.el7.x86_64java-1.7.0-openjdk-headless-1.7.0.191-2.6.15.5.el7.x86_64[root@hadoop01 ~]# 卸载 方式一 yum -y remove java-1.7.0-openjdk-1.7.0.191-2.6.15.5.el7.x86_64 1234567891011[root@hadoop01 ~]# yum -y remove java-1.7.0-openjdk-1.7.0.191-2.6.15.5.el7.x86_64Loaded plugins: fastestmirror, langpacksResolving Dependencies--&gt; Running transaction check---&gt; Package java-1.7.0-openjdk.x86_64 1:1.7.0.191-2.6.15.5.el7 will be erased--&gt; Finished Dependency Resolution......Removed: java-1.7.0-openjdk.x86_64 1:1.7.0.191-2.6.15.5.el7Complete! 方式二 rpm -e --nodeps java-1.7.0-openjdk-headless-1.7.0.191-2.6.15.5.el7.x86_64 123456[root@hadoop01 ~]# rpm -e --nodeps java-1.7.0-openjdk-headless-1.7.0.191-2.6.15.5.el7.x86_64[root@hadoop01 ~]# rpm -qa | grep jdkcopy-jdk-configs-3.3-10.el7_5.noarchjava-1.8.0-openjdk-headless-1.8.0.181-7.b13.el7.x86_64java-1.8.0-openjdk-1.8.0.181-7.b13.el7.x86_64[root@hadoop01 ~]# yum和rpm区别 rpm是RPM Package Manager（RPM软件包管理器）的缩写，是由红帽公司开发的软件包管理方式，使用rpm可以方便的进行软件的安装、查询、卸载、升级等工作。但是rpm软件包之间的依赖性问题往往会很繁琐,尤其是软件由多个rpm包组成时。 Yum（全称为 Yellow dog Updater, Modified）是一个在Fedora和RedHat以及SUSE中的Shell前端软件包管理器。基於RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装。yum会从一个资源库（repository）中下载软件包，并经过完全依赖解析来安装它，所以每次运行yum install的时候会看到安装一堆相关软件；而rpm则需要先下载好一个rpm文件然后进行安装，并且如果rpm程序发现缺少了一个依赖，就会报错并退出。 yum -y remove 和 rpm -e --nodeps区别 为什么使用yum remove卸载不了，而需要使用rpm卸载呢？ 这里需要首先判断软件是通过什么方式安装的，执行：rpm -q php 如果此命令返回php版本，则是rpm安装； 如不返回php版本则是二进制安装。 卸载有没有顺序？ 有的。使用rpm –qa | grep php 此命令是把php相关的包都列出来，而卸载最好从最下面的一个包开始，直到卸载掉第一个为止。 注意：卸载的时候如果卸载不掉，系统一般会提示包的依赖关系，并且列出依赖的包的名称，先卸载提示依赖的包即可。 如果实在实在有卸载不掉的包，可以增加—nodeps这个参数来卸载，例如： 123rpm -e php-4.3.4-11 --nodeps或rpm -e --nodeps php-4.3.4-11 使用编译安装make &amp;&amp; make install ，如果要卸载可以使用：make uninstall centos7开放、关闭及查看端口查看防火墙所有开放的端口1[root@hadoop01 ~]# firewall-cmd --zone=public --list-ports 查看防火墙状态1[root@hadoop01 ~]# firewall-cmd --state 查看防火墙状态查看防火墙状态 systemctl status firewalld开启防火墙 systemctl start firewalld关闭防火墙 systemctl stop firewalld开启防火墙 service firewalld start若遇到无法开启先用：systemctl unmask firewalld.service然后：systemctl start firewalld.service 查询端口号8080 是否开启12[root@hadoop01 nginx]# firewall-cmd --query-port=8080/tcpyes 开放端口的方法12[root@hadoop01 ~]# firewall-cmd --zone=public --add-port=8080/tcp --permanentsuccess 关闭端口方法12[root@hadoop01 ~]# firewall-cmd --remove-port=8080/tcp --permanentsuccess 重启防火墙1systemctl restart firewalld.service 关闭防火墙1systemctl stop firewalld.service 查看监听(Listen)的端口1netstat -lntp 检查端口被哪个进程占用1netstat -lnp|grep 8080]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python 杂记]]></title>
    <url>%2Fpython%2Fck9bgz7rj007wqov7bphyrrf5.html</url>
    <content type="text"><![CDATA[记录python相关的知识或使用技巧。 LEGB规则LEGB含义解释：L-Local(function)：函数内的名字空间E-Enclosing function locals：外部嵌套函数的名字空间(例如closure)G-Global(module)：函数定义所在模块（文件）的名字空间B-Builtin(Python)：Python内置模块的名字空间 yield 语句1234567891011121314151617181920212223242526272829303132333435363738def consumer(): r = '' while True: n = yield r if not n: return print('[CONSUMER] Consuming %s...' % n) r = '200 OK'def produce(c): c.send(None) # first para is None n = 0 while n &lt; 5: n = n + 1 print('[PRODUCER] Producing %s...' % n) r = c.send(n) print('[PRODUCER] Consumer return: %s' % r) c.close()c = consumer()produce(c)# result[PRODUCER] Producing 1...[CONSUMER] Consuming 1...[PRODUCER] Consumer return: 200 OK[PRODUCER] Producing 2...[CONSUMER] Consuming 2...[PRODUCER] Consumer return: 200 OK[PRODUCER] Producing 3...[CONSUMER] Consuming 3...[PRODUCER] Consumer return: 200 OK[PRODUCER] Producing 4...[CONSUMER] Consuming 4...[PRODUCER] Consumer return: 200 OK[PRODUCER] Producing 5...[CONSUMER] Consuming 5...[PRODUCER] Consumer return: 200 OK 将列表中的元素，依次每 k 个分作一组1234567def group_each(a, size: int): """ 将一个可迭代对象 a 内的元素, 每 size 个分为一组 list(group_each([1,2,3,4], 2)) -&gt; [(1,2), (3,4)] """ iterators = [iter(a)] * size # 将新构造的 iterator 复制 size 次（浅复制） return zip(*iterators) # 然后 zip 偏函数1234from functools import partial # 每两个分一组group_each_2 = partial(group_each, size=2) 多 dict 的去重12# a = [&#123;&apos;a&apos;: 1&#125;, &#123;&apos;a&apos;: 1&#125;, &#123;&apos;b&apos;: 2&#125;]# a = [&#123;&apos;a&apos;: 1&#125;, &#123;&apos;b&apos;: 2&#125;] 12345678910import jsondef unique_dicts(data_list: list): """unique a list of dict dict 是 unhashable 的，不能放入 set 中，所以先转换成 str unique_dicts([&#123;'a': 1&#125;, &#123;'a': 1&#125;, &#123;'b': 2&#125;]) -&gt; [&#123;'a': 1&#125;, &#123;'b': 2&#125;] """ data_json_set = set(json.dumps(item) for item in data_list) return [json.loads(item) for item in data_json_set] str 的 startswith 和 endswith 两个函数的参数可以是元组123&gt;&gt;&gt; file = "/opt/gts.tar.gz"&gt;&gt;&gt; file.endswith((".gz", "txt")) True 交互环境下的”_”操作符在 Python 控制台，不论何时我们测试一个表达式或者调用一个方法，结果都会分配给一个临时变量： _（一个下划线） 。 1234&gt;&gt;&gt; 2 + 35&gt;&gt;&gt; _5 开启文件分享Python 允许运行一个 HTTP 服务器来从根路径共享文件，下面是开启服务器的命令：（python3环境） 1python3 -m http.server 上面的命令会在默认端口也就是 8000 开启一个服务器，你可以将一个自定义的端口号以最后一个参数的方式传递到上面的命令中。 重置递归限制1234567&gt;&gt;&gt; import sys &gt;&gt;&gt; sys.getrecursionlimit()1000&gt;&gt;&gt; sys.setrecursionlimit(2000)&gt;&gt;&gt; sys.getrecursionlimit()2000 检查一个对象的内存使用1234&gt;&gt;&gt; import sys&gt;&gt;&gt; sys.getsizeof(1)28 使用slots来减少内存开支123456789101112131415161718192021&gt;&gt;&gt; import sys&gt;&gt;&gt; class FileSystem(object): def __init__(self, files, folders, devices): self.files = files self.folders = folders self.devices = devices3&gt;&gt;&gt; sys.getsizeof(FileSystem) 1056&gt;&gt;&gt; class FileSystem1(object): __slots__ = ['files', 'folders', 'devices'] def __init__(self, files, folders, devices): self.files = files self.folders = folders self.devices = devices&gt;&gt;&gt; sys.getsizeof(FileSystem1)888 将中文转为unicode编码12&gt;&gt;&gt; "编码".encode("unicode_escape")b'\\u7f16\\u7801' 创建多级目录123import osos.makdirs("/opt/a/b/c") 打印日期序列123456789&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; a = pd.date_range("2020-02-25", "2020-03-02")&gt;&gt;&gt; aDatetimeIndex(['2020-02-25', '2020-02-26', '2020-02-27', '2020-02-28', '2020-02-29', '2020-03-01', '2020-03-02'], dtype='datetime64[ns]', freq='D')&gt;&gt;&gt; time_list = [x.strftime("%Y-%m-%d") for x in pd.date_range("2020-02-25", "2020-03-02")]&gt;&gt;&gt; time_list['2020-02-25', '2020-02-26', '2020-02-27', '2020-02-28', '2020-02-29', '2020-03-01', '2020-03-02'] 查看当前系统编码方式1234&gt;&gt;&gt; import locale &gt;&gt;&gt; locale.getpreferredencoding() 'cp936' 序列过滤1234567891011&gt;&gt;&gt; import random &gt;&gt;&gt; lst = [random.randint(-10, 10) for range(10)] &gt;&gt;&gt; lst [2, 10, 3, 4, 6, -4, 2, 1, -6, -7]&gt;&gt;&gt; [x for x in lst if x &gt; 0] [2, 10, 3, 4, 6, 2, 1]&gt;&gt;&gt; list(filter(lambda x: x &gt; 0, lst)) [2, 10, 3, 4, 6, 2, 1] 命名元组12345678910111213141516import collectionsstudent = collections.namedtuple(&quot;student&quot;, (&quot;name&quot;, &quot;age&quot;, &quot;grade&quot;))# 方式一jack = student(&quot;Jack&quot;, 20, &quot;A&quot;) # student(name=&apos;Jack&apos;, age=20, grade=&apos;A&apos;)# 方式二bob = student(**dict(name=&quot;Jack&quot;, age=20, grade=&quot;A&quot;))print(jack[0]) # &apos;Jack&apos;print(jack.name) #&apos;Jack&apos;print(bob[-1]) # &apos;A&apos;print(bob.grade) # &apos;A&apos; 实现tail和head功能123456789101112131415161718192021222324# -*- coding: utf-8 -*-from collections import dequefrom itertools import islicedef head(path, n=10, mode=&apos;r&apos;, buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None): try: with open(path, mode, buffering, encoding, errors, newline, closefd, opener) as f: return deque(islice(f, n - 1)) except Exception as e: print(e)def tail(path, n=10, mode=&apos;r&apos;, buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None): try: with open(path, mode, buffering, encoding, errors, newline, closefd, opener) as f: return deque(f, maxlen=n) except Exception as e: print(e)if __name__ == &quot;__main__&quot;: path = &quot;NEWS.txt&quot; 实现轮询调度器实现下述需求 1[&apos;ABC&apos;, &apos;D&apos;, &apos;EF&apos;] --&gt; [&apos;A&apos;, &apos;D&apos;, &apos;E&apos;, &apos;B&apos;, &apos;F&apos;, &apos;C&apos;] 方式一：可以通过在 deque 中放入迭代器来实现。 值从当前迭代器的位置0被取出并暂存(yield)。 如果这个迭代器消耗完毕，就用 popleft() 将其从对列中移去；否则，就通过 rotate() 将它移到队列的末尾 12345678910111213141516from collections import dequedef roundrobin(*iterables): &quot;roundrobin(&apos;ABC&apos;, &apos;D&apos;, &apos;EF&apos;) --&gt; A D E B F C&quot; iterators = deque(map(iter, iterables)) while iterators: try: while True: yield next(iterators[0]) iterators.rotate(-1) except StopIteration: # Remove an exhausted iterator. iterators.popleft() if __name__ == &quot;__main__&quot;: roundrobin(&apos;ABC&apos;, &apos;D&apos;, &apos;EF&apos;) 耗时测试： 1234&gt;&gt;&gt; import timeit&gt;&gt;&gt; timeit.timeit(&quot;list(roundrobin(&apos;ABC&apos;, &apos;D&apos;, &apos;EF&apos;))&quot;, &quot;from __main__ import roundrobin&quot;)8.649481091000325 方式二：通过zip_longest实现 12345&gt;&gt;&gt; import functools&gt;&gt;&gt; import itertools&gt;&gt;&gt; list(filter(lambda x: x, functools.reduce(lambda x, y: x + y, itertools.zip_longest(&apos;ABC&apos;, &apos;D&apos;, &apos;EF&apos;))))[&apos;A&apos;, &apos;D&apos;, &apos;E&apos;, &apos;B&apos;, &apos;F&apos;, &apos;C&apos;] 耗时测试： 1234&gt;&gt;&gt; import timeit&gt;&gt;&gt; timeit.timeit(&quot;list(filter(lambda x: x, functools.reduce(lambda x, y: x + y, itertools.zip_longest(&apos;ABC&apos;, &apos;D&apos;, &apos;EF&apos;))))&quot;, &quot;import functools&quot;)4.335959078000087 python 在函数内部获取函数名方式一：sys._getframe().f_code.co_name 123456import sysdef my_function_1(): func_name = sys._getframe(0).f_code.co_name print(func_name) 方式二：用inspect模块中的inspect.stack() 1234import inspectdef my_function_2(): print(inspect.stack()[0][3]) python获取当前进程所在的文件名 sys._getframe().f_code.co_filename __file__ re中的\1\2\3问题1234&gt;&gt;&gt; import re&gt;&gt;&gt; st = &quot;Today is 01/08/2020, yesterday is 01/08/2020.&quot;&gt;&gt;&gt; re.sub(&quot;(\d+)/(\d+)/(\d+)&quot;, r&quot;\3-\1-\2&quot;, st)&apos;Today is 2020-01-08, yesterday is 2020-01-08.&apos; 简析Python中的四种队列参考：https://www.jianshu.com/p/55243999aa56 spark 中文文档http://spark-cn.cn/rdd-programming-guide.htmlApache Spark 2.2.0 官方文档中文版 Python 中关于 round 函数的小坑round的结果跟python版本有关： 1234Python 2.7.14 (v2.7.14:84471935ed, Sep 16 2017, 20:25:58) [MSC v.1500 64 bit (AMD64)] on win32Type &quot;copyright&quot;, &quot;credits&quot; or &quot;license()&quot; for more information.&gt;&gt;&gt; round(2.5)3.0 1234Python 3.7.1 (v3.7.1:260ec2c36a, Oct 20 2018, 14:57:15) [MSC v.1915 64 bit (AMD64)] on win32Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license()&quot; for more information.&gt;&gt;&gt; round(2.5)2 阅读一下python的文档，里面是这么写的： 在python2.7的doc中，round()的最后写着，”Values are rounded to the closest multiple of 10 to the power minus ndigits; if two multiples are equally close, rounding is done away from 0.” 保留值将保留到离上一位更近的一端（四舍六入），如果距离两端一样远，则保留到离0远的一边。所以round(0.5)会近似到1，而round(-0.5)会近似到-1。 但是到了python3.5的doc中，文档变成了”values are rounded to the closest multiple of 10 to the power minus ndigits; if two multiples are equally close, rounding is done toward the even choice.” 如果距离两边一样远，会保留到偶数的一边。比如round(0.5)和round(-0.5)都会保留到0，而round(1.5)会保留到2。 python 求最小公倍数1234567891011# -*- coding:utf-8 -*-import mathwhile True: try: m, n = map(int, input().strip().split()) max_fac = math.gcd(m, n) # 最大公约数 print(m * n // max_fac) # 最小公倍数 except Exception as e: break python求两数的最大公约数 使用 math.gcd 方法 123&gt;&gt;&gt; import math&gt;&gt;&gt; math.gcd(20, 25)5 欧几里德算法 欧几里德算法又称辗转相除法， 用于计算两个整数a, b的最大公约数。其计算原理依赖于下面的定理：定理：gcd(a, b) = gcd(b, a mod b) (a &gt; b) 证明： a可以表示成a = kb + r, 则r = a mod b 假设d是a, b的一个公约数， 则有 d|a, d|b, 而r = a - kb, 因此d|r。 因此，d是(b, a mod b)的公约数。 加上d是(b，a mod b)的公约数，则d|b, d|r, 但是a = kb + r,因此d也是(a, b)的公约数。 因此，(a, b) 和(a, a mod b)的公约数是一样的，其最大公约数也必然相等，得证。 1234567891011# -*- coding:utf-8 -*-def gcd(a, b): a, b = a, b if a &gt;= b else b, a while b != 0: remainder = a % b a = b b = remainder return agcd(20, 25) python中开n次方根利用 pow(a, b) 函数即可。需要开a的r次方则 pow(a, 1/r) ‘ascii’ codec can’t encode characters in position 0-6: ordinal not in range(128)1&apos;ascii&apos; codec can&apos;t encode characters in position 0-6: ordinal not in range(128) 方式一 在文件开头添加： 123import sysreload(sys)sys.setdefaultencoding(&apos;utf8&apos;) 方式二： 123import sysimport iosys.stdout=io.TextIOWrapper(sys.stdout.buffer,encoding=&quot;utf-8&quot;) Python2.x 和 Python3.x 中 raw_input( ) 和 input( ) 区别Python3.x 中 input() 函数接受一个标准输入数据，返回为 string 类型。 Python2.x 中 input() 相等于 eval(raw_input(prompt)) ，用来获取控制台的输入。 raw_input() 将所有输入作为字符串看待，返回字符串类型。而 input() 在对待纯数字输入时具有自己的特性，它返回所输入的数字的类型（ int, float ）。 注意：input() 和 raw_input() 这两个函数均能接收 字符串 ，但 raw_input() 直接读取控制台的输入（任何类型的输入它都可以接收）。而对于 input() ，它希望能够读取一个合法的 python 表达式，即你输入字符串的时候必须使用引号将它括起来，否则它会引发一个 SyntaxError 。 除非对 input() 有特别需要，否则一般情况下我们都是推荐使用 raw_input() 来与用户交互。 注意：python3 里 input() 默认接收到的是 str 类型。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python numpy module]]></title>
    <url>%2Fpython%2Fmodule%2Fck9bgz86m00giqov7whrjzbvc.html</url>
    <content type="text"><![CDATA[NumPy 是一个 Python 包。 它代表 “Numeric Python”。 它是一个由多维数组对象和用于处理数组的例程集合组成的库。 Numeric，即 NumPy 的前身，是由 Jim Hugunin 开发的。 也开发了另一个包 Numarray ，它拥有一些额外的功能。 2005年，Travis Oliphant 通过将 Numarray 的功能集成到 Numeric 包中来创建 NumPy 包。 这个开源项目有很多贡献者。 NumPy Ndarray 对象NumPy 最重要的一个特点是其 N 维数组对象 ndarray，它是一系列同类型数据的集合，以 0 下标为开始进行集合中元素的索引。 ndarray 对象是用于存放同类型元素的多维数组。 ndarray 中的每个元素在内存中都有相同存储大小的区域。 ndarray 内部由以下内容组成： 一个指向数据（内存或内存映射文件中的一块数据）的指针。 数据类型或 dtype，描述在数组中的固定大小值的格子。 一个表示数组形状（shape）的元组，表示各维度大小的元组。 一个跨度元组（stride），其中的整数指的是为了前进到当前维度下一个元素需要”跨过”的字节数。 创建一个 ndarray 只需调用 NumPy 的 array 函数即可： numpy.array(object, dtype=None, copy=True, order=’K’, subok=False, ndmin=0)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849array(object, dtype=None, copy=True, order=&apos;K&apos;, subok=False, ndmin=0)Create an array.Parameters----------object : array_like An array, any object exposing the array interface, an object whose __array__ method returns an array, or any (nested) sequence.dtype : data-type, optional The desired data-type for the array. If not given, then the type will be determined as the minimum type required to hold the objects in the sequence. This argument can only be used to &apos;upcast&apos; the array. For downcasting, use the .astype(t) method.copy : bool, optional If true (default), then the object is copied. Otherwise, a copy will only be made if __array__ returns a copy, if obj is a nested sequence, or if a copy is needed to satisfy any of the other requirements (`dtype`, `order`, etc.).order : &#123;&apos;K&apos;, &apos;A&apos;, &apos;C&apos;, &apos;F&apos;&#125;, optional Specify the memory layout of the array. If object is not an array, the newly created array will be in C order (row major) unless &apos;F&apos; is specified, in which case it will be in Fortran order (column major). If object is an array the following holds. ===== ========= =================================================== order no copy copy=True ===== ========= =================================================== &apos;K&apos; unchanged F &amp; C order preserved, otherwise most similar order &apos;A&apos; unchanged F order if input is F and not C, otherwise C order &apos;C&apos; C order C order &apos;F&apos; F order F order ===== ========= =================================================== When ``copy=False`` and a copy is made for other reasons, the result is the same as if ``copy=True``, with some exceptions for `A`, see the Notes section. The default order is &apos;K&apos;.subok : bool, optional If True, then sub-classes will be passed-through, otherwise the returned array will be forced to be a base-class array (default).ndmin : int, optional Specifies the minimum number of dimensions that the resulting array should have. Ones will be pre-pended to the shape as needed to meet this requirement.Returns-------out : ndarray An array object satisfying the specified requirements. 1234567891011121314151617181920212223242526272829303132333435363738394041Examples--------&gt;&gt;&gt; np.array([1, 2, 3])array([1, 2, 3])Upcasting:&gt;&gt;&gt; np.array([1, 2, 3.0])array([ 1., 2., 3.])More than one dimension:&gt;&gt;&gt; np.array([[1, 2], [3, 4]])array([[1, 2], [3, 4]])Minimum dimensions 2:&gt;&gt;&gt; np.array([1, 2, 3], ndmin=2)array([[1, 2, 3]])Type provided:&gt;&gt;&gt; np.array([1, 2, 3], dtype=complex)array([ 1.+0.j, 2.+0.j, 3.+0.j])Data-type consisting of more than one element:&gt;&gt;&gt; x = np.array([(1,2),(3,4)],dtype=[('a','&lt;i4'),('b','&lt;i4')])&gt;&gt;&gt; x['a']array([1, 3])Creating an array from sub-classes:&gt;&gt;&gt; np.array(np.mat('1 2; 3 4'))array([[1, 2], [3, 4]])&gt;&gt;&gt; np.array(np.mat('1 2; 3 4'), subok=True)matrix([[1, 2], [3, 4]]) 数据类型对象 (dtype)数据类型对象是用来描述与数组对应的内存区域如何使用，这依赖如下几个方面： 数据的类型（整数，浮点数或者 Python 对象） 数据的大小（例如， 整数使用多少个字节存储） 数据的字节顺序（小端法或大端法） 在结构化类型的情况下，字段的名称、每个字段的数据类型和每个字段所取的内存块的部分 如果数据类型是子数组，它的形状和数据类型 字节顺序是通过对数据类型预先设定”&lt;”或”&gt;”来决定的。”&lt;”意味着小端法(最小值存储在最小的地址，即低位组放在最前面)。”&gt;”意味着大端法(最重要的字节存储在最小的地址，即高位组放在最前面)。 dtype(obj, align=False, copy=False) object - 要转换为的数据类型对象 align - 如果为 true，填充字段使其类似 C 的结构体。 copy - 复制 dtype 对象 ，如果为 false，则是对内置数据类型对象的引用 NumPy 数组属性NumPy 数组的维数称为秩（rank），秩就是轴的数量，即数组的维度，一维数组的秩为 1，二维数组的秩为 2，以此类推。 在 NumPy中，每一个线性的数组称为是一个轴（axis），也就是维度（dimensions）。比如说，二维数组相当于是两个一维数组，其中第一个一维数组中每个元素又是一个一维数组。所以一维数组就是 NumPy 中的轴（axis），第一个轴相当于是底层数组，第二个轴是底层数组里的数组。而轴的数量——秩，就是数组的维数。 很多时候可以声明 axis。axis=0，表示沿着第 0 轴进行操作，即对每一列进行操作；axis=1，表示沿着第1轴进行操作，即对每一行进行操作。 NumPy 的数组中比较重要 ndarray 对象属性有： 属性 说明 ndarray.ndim 秩，即轴的数量或维度的数量 ndarray.shape 数组的维度，对于矩阵，n 行 m 列 ndarray.size 数组元素的总个数，相当于 .shape 中 n*m 的值 ndarray.dtype ndarray 对象的元素类型 ndarray.itemsize ndarray 对象中每个元素的大小，以字节为单位 ndarray.flags ndarray 对象的内存信息 ndarray.real ndarray元素的实部 ndarray.imag ndarray 元素的虚部 ndarray.data 包含实际数组元素的缓冲区，由于一般通过数组的索引获取元素，所以通常不需要使用这个属性。 NumPy 创建数组numpy.empty(shape, dtype = float, order = ‘C’)numpy.empty 方法用来创建一个指定形状（shape）、数据类型（dtype）且未初始化的数组 参数说明： 参数 描述 shape 数组形状 dtype 数据类型，可选 order 有”C”和”F”两个选项,分别代表，行优先和列优先，在计算机内存中的存储元素的顺序。 numpy.zeros(shape, dtype = float, order = ‘C’)创建指定大小的数组，数组元素以 0 来填充 参数说明： 参数 描述 shape 数组形状 dtype 数据类型，可选 order ‘C’ 用于 C 的行数组，或者 ‘F’ 用于 FORTRAN 的列数组 numpy.ones(shape, dtype = None, order = ‘C’)创建指定形状的数组，数组元素以 1 来填充 参数说明： 参数 描述 shape 数组形状 dtype 数据类型，可选 order ‘C’ 用于 C 的行数组，或者 ‘F’ 用于 FORTRAN 的列数组 123456789101112import numpy as np # 默认为浮点数x = np.ones(5) print(x) # [1. 1. 1. 1. 1.] # 自定义类型x = np.ones([2,2], dtype = int)print(x)#[[1 1]# [1 1]] numpy.full(shape, fill_value, dtype=None, order=’C’)返回一个给定形状和类型的新数组，用’ fill_value ‘填充 参数说明： 参数 描述 shape 数组形状 dtype 数据类型，可选 order ‘C’ 用于 C 的行数组，或者 ‘F’ 用于 FORTRAN 的列数组 numpy.asarray(a, dtype = None, order = None)numpy.asarray 类似 numpy.array，但 numpy.asarray 参数只有三个，比 numpy.array 少两个。 参数说明： 参数 描述 a 任意形式的输入参数，可以是，列表, 列表的元组, 元组, 元组的元组, 元组的列表，多维数组 dtype 数据类型，可选 order 可选，有”C”和”F”两个选项,分别代表，行优先和列优先，在计算机内存中的存储元素的顺序。 12345import numpy as np x = [1,2,3] a = np.asarray(x) print (a) # [1 2 3] numpy.frombuffer(buffer, dtype = float, count = -1, offset = 0)numpy.frombuffer 用于实现动态数组。 numpy.frombuffer 接受 buffer 输入参数，以流的形式读入转化成 ndarray 对象。 注意: * *buffer 是字符串的时候，Python3 默认 str 是 Unicode 类型，所以要转成 bytestring 在原 str 前加上 b。 参数说明： 参数 描述 buffer 可以是任意对象，会以流的形式读入。 dtype 返回数组的数据类型，可选 count 读取的数据数量，默认为-1，读取所有数据。 offset 读取的起始位置，默认为0。 12345import numpy as np s = b'Hello World' a = np.frombuffer(s, dtype = 'S1') print (a) # [b'H' b'e' b'l' b'l' b'o' b' ' b'W' b'o' b'r' b'l' b'd'] numpy.fromiter(iterable, dtype, count=-1)numpy.fromiter 方法从可迭代对象中建立 ndarray 对象，返回一维数组。 参数 描述 iterable 可迭代对象 dtype 返回数组的数据类型 count 读取的数据数量，默认为-1，读取所有数据 123456789import numpy as np # 使用 range 函数创建列表对象 list=range(5)it=iter(list) # 使用迭代器创建 ndarray x=np.fromiter(it, dtype=float)print(x) # [0. 1. 2. 3. 4.] numpy.arange([start,] stop[, step,], dtype=None)根据 start 与 stop 指定的范围以及 step 设定的步长，生成一个 ndarray。 参数说明： 参数 描述 start 起始值，默认为0 stop 终止值（不包含） step 步长，默认为1 dtype 返回ndarray的数据类型，如果没有提供，则会使用输入数据的类型。 numpy.linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None)numpy.linspace 函数用于创建一个一维数组，数组是一个等差数列构成的 参数说明： 参数 描述 start 序列的起始值 stop 序列的终止值，如果endpoint为true，该值包含于数列中 num 要生成的等步长的样本数量，默认为50 endpoint 该值为 true 时，数列中中包含stop值，反之不包含，默认是True。 retstep 如果为 True 时，生成的数组中会显示间距，反之不显示。 dtype ndarray 的数据类型 1234import numpy as npa = np.linspace(1, 10, 10, retstep=True)print(a)# (array([ 1., 2., 3., 4., 5., 6., 7., 8., 9., 10.]), 1.0) numpy.logspace(start, stop, num=50, endpoint=True, base=10.0, dtype=None)numpy.logspace 函数用于创建一个于等比数列。 base 参数意思是取对数的时候 log 的下标。 参数 描述 start 序列的起始值为：base ** start stop 序列的终止值为：base ** stop。如果endpoint为true，该值包含于数列中 num 要生成的等步长的样本数量，默认为50 endpoint 该值为 true 时，数列中中包含stop值，反之不包含，默认是True。 base 对数 log 的底数。 dtype ndarray 的数据类型 1234567891011import numpy as np# base 10a = np.logspace(1.0, 2.0, num = 10) print (a)# [ 10. 12.91549665 16.68100537 21.5443469 27.82559402 35.93813664 46.41588834 59.94842503 77.42636827 100. ]# base 2a = np.logspace(0,9,10,base=2)print (a)# [ 1. 2. 4. 8. 16. 32. 64. 128. 256. 512.] NumPy 切片和索引ndarray对象的内容可以通过索引或切片来访问和修改，与 Python 中 list 的切片操作一样。 ndarray 数组可以基于 0 - n 的下标进行索引，切片对象可以通过内置的 slice 函数，并设置 start, stop 及 step 参数进行，从原数组中切割出一个新数组。 123456import numpy as np a = np.arange(10)s = slice(2,7,2) # 从索引 2 开始到索引 7 停止，间隔为2print (a[s])[2 4 6] 也可以通过冒号分隔切片参数 start:stop:step 来进行切片操作： 123456import numpy as np a = np.arange(10)s = slice(2:7:2) # 从索引 2 开始到索引 7 停止，间隔为2print (a[s])[2 4 6] 切片还可以包括省略号 …，来使选择元组的长度与数组的维度相同。 如果在行位置使用省略号，它将返回包含行中元素的 ndarray。 12345678910import numpy as np a = np.array([[1,2,3],[3,4,5],[4,5,6]]) print (a[...,1]) # 第2列元素 [2 4 5]print (a[1,...]) # 第2行元素 [3 4 5]print (a[...,1:]) # 第2列及剩下的所有元素# [[2 3]# [4 5]# [5 6]] NumPy 高级索引整数数组索引以下实例获取数组中(0,0)，(1,1)和(2,0)位置处的元素。 12345import numpy as np x = np.array([[1, 2], [3, 4], [5, 6]]) y = x[[0,1,2], [0,1,0]] print (y) # [1 4 5] 以下实例获取了 4X3 数组中的四个角的元素。 行索引是 [0,0] 和 [3,3]，而列索引是 [0,2] 和 [0,2]。 123456789101112131415161718192021import numpy as np x = np.array([[ 0, 1, 2],[ 3, 4, 5],[ 6, 7, 8],[ 9, 10, 11]]) print (&apos;我们的数组是：&apos; )print (x)print (&apos;\n&apos;)rows = np.array([[0,0],[3,3]]) cols = np.array([[0,2],[0,2]]) y = x[rows,cols] print (&apos;这个数组的四个角元素是：&apos;)print (y)我们的数组是：[[ 0 1 2] [ 3 4 5] [ 6 7 8] [ 9 10 11]]这个数组的四个角元素是：[[ 0 2] [ 9 11]] 返回的结果是包含每个角元素的 ndarray 对象。 可以借助切片 : 或 … 与索引数组组合。 1234567891011121314151617import numpy as np a = np.array([[1,2,3], [4,5,6],[7,8,9]])b = a[1:3, 1:3]c = a[1:3,[1,2]]d = a[...,1:]print(b)print(c)print(d)[[5 6] [8 9]][[5 6] [8 9]][[2 3] [5 6] [8 9]] 布尔索引我们可以通过一个布尔数组来索引目标数组。 布尔索引通过布尔运算（如：比较运算符）来获取符合指定条件的元素的数组。 以下实例获取大于 5 的元素： 123456789101112131415161718import numpy as np x = np.array([[ 0, 1, 2],[ 3, 4, 5],[ 6, 7, 8],[ 9, 10, 11]]) print (&apos;我们的数组是：&apos;)print (x)print (&apos;\n&apos;)# 现在我们会打印出大于 5 的元素 print (&apos;大于 5 的元素是：&apos;)print (x[x &gt; 5])我们的数组是：[[ 0 1 2] [ 3 4 5] [ 6 7 8] [ 9 10 11]]大于 5 的元素是：[ 6 7 8 9 10 11] 以下实例使用了 ~（取补运算符）来过滤 NaN。 123456import numpy as np a = np.array([np.nan, 1,2,np.nan,3,4,5]) print (a[~np.isnan(a)])[ 1. 2. 3. 4. 5.] 花式索引花式索引指的是利用整数数组进行索引。 花式索引根据索引数组的值作为目标数组的某个轴的下标来取值。对于使用一维整型数组作为索引，如果目标是一维数组，那么索引的结果就是对应位置的元素；如果目标是二维数组，那么就是对应下标的行。 花式索引跟切片不一样，它总是将数据复制到新数组中。 1、传入顺序索引数组 12345678910import numpy as np x=np.arange(32).reshape((8,4))print (x[[4,2,1,7]])输出结果为：[[16 17 18 19] [ 8 9 10 11] [ 4 5 6 7] [28 29 30 31]] 2、传入倒序索引数组 12345678910import numpy as np x=np.arange(32).reshape((8,4))print (x[[-4,-2,-1,-7]])输出结果为：[[16 17 18 19] [24 25 26 27] [28 29 30 31] [ 4 5 6 7]] 3、传入多个索引数组（要使用np.ix_） 12345678910import numpy as np x=np.arange(32).reshape((8,4))print (x[np.ix_([1,5,7,2],[0,3,1,2])])输出结果为：[[ 4 7 5 6] [20 23 21 22] [28 31 29 30] [ 8 11 9 10]] NumPy 广播(Broadcast)广播(Broadcast)是 numpy 对不同形状(shape)的数组进行数值计算的方式， 对数组的算术运算通常在相应的元素上进行。 如果两个数组 a 和 b 形状相同，即满足 a.shape == b.shape，那么 a*b 的结果就是 a 与 b 数组对应位相乘。这要求维数相同，且各维度的长度相同。 广播的规则: 让所有输入数组都向其中形状最长的数组看齐，形状中不足的部分都通过在前面加 1 补齐。 输出数组的形状是输入数组形状的各个维度上的最大值。 如果输入数组的某个维度和输出数组的对应维度的长度相同或者其长度为 1 时，这个数组能够用来计算，否则出错。 当输入数组的某个维度的长度为 1 时，沿着此维度运算时都用此维度上的第一组值。 简单理解：对两个数组，分别比较他们的每一个维度（若其中一个数组没有当前维度则忽略），满足： 数组拥有相同形状。 当前维度的值相等。 当前维度的值有一个是 1。 若条件不满足，抛出 “ValueError: frames are not aligned” 异常。 NumPy 迭代数组NumPy 迭代器对象 numpy.nditer 提供了一种灵活访问一个或者多个数组元素的方式。 迭代器最基本的任务的可以完成对数组元素的访问。 接下来我们使用 arange() 函数创建一个 2X3 数组，并使用 nditer 对它进行迭代。 123456789101112131415161718import numpy as np a = np.arange(6).reshape(2,3)print (&apos;原始数组是：&apos;)print (a)print (&apos;\n&apos;)print (&apos;迭代输出元素：&apos;)for x in np.nditer(a): print (x, end=&quot;, &quot; )print (&apos;\n&apos;)原始数组是：[[0 1 2] [3 4 5]]迭代输出元素：0, 1, 2, 3, 4, 5, 以上实例不是使用标准 C 或者 Fortran 顺序，选择的顺序是和数组内存布局一致的，这样做是为了提升访问的效率，默认是行序优先（row-major order，或者说是 C-order）。 这反映了默认情况下只需访问每个元素，而无需考虑其特定顺序。我们可以通过迭代上述数组的转置来看到这一点，并与以 C 顺序访问数组转置的 copy 方式做对比，如下实例: 1234567891011121314import numpy as np a = np.arange(6).reshape(2,3)for x in np.nditer(a.T): print (x, end=&quot;, &quot; )print (&apos;\n&apos;) for x in np.nditer(a.T.copy(order=&apos;C&apos;)): print (x, end=&quot;, &quot; )print (&apos;\n&apos;)输出结果为：0, 1, 2, 3, 4, 5, 0, 3, 1, 4, 2, 5, 从上述例子可以看出，a 和 a.T 的遍历顺序是一样的，也就是他们在内存中的存储顺序也是一样的，但是 a.T.copy(order = ‘C’) 的遍历结果是不同的，那是因为它和前两种的存储方式是不一样的，默认是按行访问。 控制遍历顺序 for x in np.nditer(a, order=&#39;F&#39;):Fortran order，即是列序优先； for x in np.nditer(a.T, order=&#39;C&#39;):C order，即是行序优先； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import numpy as np a = np.arange(0,60,5) a = a.reshape(3,4) print (&apos;原始数组是：&apos;) print (a) print (&apos;\n&apos;) print (&apos;原始数组的转置是：&apos;) b = a.T print (b) print (&apos;\n&apos;) print (&apos;以 C 风格顺序排序：&apos;) c = b.copy(order=&apos;C&apos;) print (c)for x in np.nditer(c): print (x, end=&quot;, &quot; )print (&apos;\n&apos;) print (&apos;以 F 风格顺序排序：&apos;)c = b.copy(order=&apos;F&apos;) print (c)for x in np.nditer(c): print (x, end=&quot;, &quot; )输出结果为：原始数组是：[[ 0 5 10 15] [20 25 30 35] [40 45 50 55]]原始数组的转置是：[[ 0 20 40] [ 5 25 45] [10 30 50] [15 35 55]]以 C 风格顺序排序：[[ 0 20 40] [ 5 25 45] [10 30 50] [15 35 55]]0, 20, 40, 5, 25, 45, 10, 30, 50, 15, 35, 55, 以 F 风格顺序排序：[[ 0 20 40] [ 5 25 45] [10 30 50] [15 35 55]]0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 可以通过显式设置，来强制 nditer 对象使用某种顺序： 123456789101112131415161718192021222324252627import numpy as np a = np.arange(0,60,5) a = a.reshape(3,4) print (&apos;原始数组是：&apos;)print (a)print (&apos;\n&apos;)print (&apos;以 C 风格顺序排序：&apos;)for x in np.nditer(a, order = &apos;C&apos;): print (x, end=&quot;, &quot; )print (&apos;\n&apos;)print (&apos;以 F 风格顺序排序：&apos;)for x in np.nditer(a, order = &apos;F&apos;): print (x, end=&quot;, &quot; )输出结果为：原始数组是：[[ 0 5 10 15] [20 25 30 35] [40 45 50 55]]以 C 风格顺序排序：0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 以 F 风格顺序排序：0, 20, 40, 5, 25, 45, 10, 30, 50, 15, 35, 55, 修改数组中元素的值 nditer 对象有另一个可选参数 op_flags。 默认情况下，nditer 将视待迭代遍历的数组为只读对象（read-only），为了在遍历数组的同时，实现对数组元素值得修改，必须指定 read-write 或者 write-only 的模式。 12345678910111213141516171819202122import numpy as np a = np.arange(0,60,5) a = a.reshape(3,4) print (&apos;原始数组是：&apos;)print (a)print (&apos;\n&apos;)for x in np.nditer(a, op_flags=[&apos;readwrite&apos;]): x[...]=2*x print (&apos;修改后的数组是：&apos;)print (a)输出结果为：原始数组是：[[ 0 5 10 15] [20 25 30 35] [40 45 50 55]]修改后的数组是：[[ 0 10 20 30] [ 40 50 60 70] [ 80 90 100 110]] 使用外部循环 nditer类的构造器拥有flags参数，它可以接受下列值： 参数 描述 c_index 可以跟踪 C 顺序的索引 f_index 可以跟踪 Fortran 顺序的索引 multi-index 每次迭代可以跟踪一种索引类型 external_loop 给出的值是具有多个值的一维数组，而不是零维数组 在下面的实例中，迭代器遍历对应于每列，并组合为一维数组。 123456789101112131415161718import numpy as np a = np.arange(0,60,5) a = a.reshape(3,4) print (&apos;原始数组是：&apos;)print (a)print (&apos;\n&apos;)print (&apos;修改后的数组是：&apos;)for x in np.nditer(a, flags = [&apos;external_loop&apos;], order = &apos;F&apos;): print (x, end=&quot;, &quot; )输出结果为：原始数组是：[[ 0 5 10 15] [20 25 30 35] [40 45 50 55]]修改后的数组是：[ 0 20 40], [ 5 25 45], [10 30 50], [15 35 55], 广播迭代 如果两个数组是可广播的，nditer 组合对象能够同时迭代它们。 假设数组 a 的维度为 3X4，数组 b 的维度为 1X4 ，则使用以下迭代器（数组 b 被广播到 a 的大小）。 1234567891011121314151617181920212223242526import numpy as np a = np.arange(0,60,5) a = a.reshape(3,4) print (&apos;第一个数组为：&apos;)print (a)print (&apos;\n&apos;)print (&apos;第二个数组为：&apos;)b = np.array([1, 2, 3, 4], dtype = int) print (b)print (&apos;\n&apos;)print (&apos;修改后的数组为：&apos;)for x,y in np.nditer([a,b]): print (&quot;%d:%d&quot; % (x,y), end=&quot;, &quot; )输出结果为：第一个数组为：[[ 0 5 10 15] [20 25 30 35] [40 45 50 55]]第二个数组为：[1 2 3 4]修改后的数组为：0:1, 5:2, 10:3, 15:4, 20:1, 25:2, 30:3, 35:4, 40:1, 45:2, 50:3, 55:4, Numpy 数组操作Numpy 中包含了一些函数用于处理数组，大概可分为以下几类： 修改数组形状 翻转数组 修改数组维度 连接数组 分割数组 数组元素的添加与删除 修改数组形状 函数 描述 reshape 不改变数据的条件下修改形状 flat 数组元素迭代器 flatten 返回一份数组拷贝，对拷贝所做的修改不会影响原始数组 ravel 返回展开数组 numpy.reshape(arr, newshape, order=’C’) arr：要修改形状的数组 newshape：整数或者整数数组，新的形状应当兼容原有形状 order：’C’ – 按行，’F’ – 按列，’A’ – 原顺序，’k’ – 元素在内存中的出现顺序。 numpy.ndarray.flatnumpy.ndarray.flat 是一个数组元素迭代器，实例如下: 1234567891011121314151617181920212223242526import numpy as np a = np.arange(9).reshape(3,3) print (&apos;原始数组：&apos;)for row in a: print (row) #对数组中每个元素都进行处理，可以使用flat属性，该属性是一个数组元素迭代器：print (&apos;迭代后的数组：&apos;)for element in a.flat: print (element) 原始数组：[0 1 2][3 4 5][6 7 8]迭代后的数组：012345678 ndarray.flatten(order=’C’)numpy.ndarray.flatten 返回一份数组拷贝，对拷贝所做的修改不会影响原始数组 参数说明： order：’C’ – 按行，’F’ – 按列，’A’ – 原顺序，’K’ – 元素在内存中的出现顺序。 12345678910111213141516171819202122232425import numpy as np a = np.arange(8).reshape(2,4) print (&apos;原数组：&apos;)print (a)print (&apos;\n&apos;)# 默认按行 print (&apos;展开的数组：&apos;)print (a.flatten())print (&apos;\n&apos;) print (&apos;以 F 风格顺序展开的数组：&apos;)print (a.flatten(order = &apos;F&apos;))原数组：[[0 1 2 3] [4 5 6 7]]展开的数组：[0 1 2 3 4 5 6 7]以 F 风格顺序展开的数组：[0 4 1 5 2 6 3 7] numpy.ravel(a, order=’C’)numpy.ravel() 展平的数组元素，顺序通常是”C风格”，返回的是数组视图（view，有点类似 C/C++引用reference的意味），修改会影响原始数组。 参数说明： order：’C’ – 按行，’F’ – 按列，’A’ – 原顺序，’K’ – 元素在内存中的出现顺序。 123456789101112131415161718192021222324import numpy as np a = np.arange(8).reshape(2,4) print (&apos;原数组：&apos;)print (a)print (&apos;\n&apos;) print (&apos;调用 ravel 函数之后：&apos;)print (a.ravel())print (&apos;\n&apos;) print (&apos;以 F 风格顺序调用 ravel 函数之后：&apos;)print (a.ravel(order = &apos;F&apos;))原数组：[[0 1 2 3] [4 5 6 7]]调用 ravel 函数之后：[0 1 2 3 4 5 6 7]以 F 风格顺序调用 ravel 函数之后：[0 4 1 5 2 6 3 7] 翻转数组 函数 描述 transpose 对换数组的维度 ndarray.T 和 self.transpose() 相同 rollaxis 向后滚动指定的轴 swapaxes 对换数组的两个轴 numpy.transpose(a, axes=None)numpy.transpose 函数用于对换数组的维度 numpy.ndarray.T 类似 numpy.transpose 参数说明: arr：要操作的数组 axes：整数列表，对应维度，通常所有维度都会对换。 123456789101112131415161718192021import numpy as np a = np.arange(12).reshape(3,4) print (&apos;原数组：&apos;)print (a )print (&apos;\n&apos;) print (&apos;对换数组：&apos;)print (np.transpose(a))原数组：[[ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11]]对换数组：[[ 0 4 8] [ 1 5 9] [ 2 6 10] [ 3 7 11]]]]></content>
      <categories>
        <category>python</category>
        <category>module</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>module</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python random module]]></title>
    <url>%2Fpython%2Fmodule%2Fck9bgz7zw00a9qov7nqd3ic1r.html</url>
    <content type="text"><![CDATA[该模块实现了各种分布的伪随机数生成器。 不应将此模块的伪随机生成器用于安全目的。 有关安全性或加密用途，请参阅 secrets 模块。 源码： Lib/random.py random.seed(a=None, version=2)123456random.seed(a=None, version=2)1. 初始化随机数生成器2. 如果 a 被省略或为 None ，则使用当前系统时间。 如果操作系统提供随机源，则使用它们而不是系统时间。3. 如果 a 是 int 类型，则直接使用。4. 对于版本2（默认的），str 、 bytes 或 bytearray 对象转换为 int 并使用它的所有位 random.getstate()返回捕获生成器当前内部状态的对象。 这个对象可以传递给 setstate() 来恢复状态。 random.setstate(state)state 应该是从之前调用 getstate() 获得的，并且 setstate() 将生成器的内部状态恢复到 getstate() 被调用时的状态。 random.getrandbits(k)返回带有 k 位随机的Python整数。 此方法随 MersenneTwister 生成器一起提供，其他一些生成器也可以将其作为API的可选部分提供。 如果可用，getrandbits() 启用 randrange() 来处理任意大范围。 random.randrange1234random.randrange(stop)random.randrange(start, stop[, step])从 range(start, stop, step) 返回一个随机选择的元素。 这相当于 choice(range(start, stop, step)) ，但实际上并没有构建一个 range 对象。 random.randint(a, b)返回随机整数 N 满足 a &lt;= N &lt;= b。相当于 randrange(a, b+1)。 random.choice(seq)从非空序列 seq 返回一个随机元素。 如果 seq 为空，则引发 IndexError。 random.choicesrandom.choices(population, weights=None, *, cum_weights=None, k=1) 从population中选择替换，返回大小为 k 的元素列表。 如果 population 为空，则引发 IndexError。 random.shuffle(x[, random])将序列 x 随机打乱位置 random.sample(population, k)返回从总体序列或集合中选择的唯一元素的 k 长度列表。 用于无重复的随机抽样。 random.random()返回 [0.0, 1.0) 范围内的下一个随机浮点数。 random.uniform(a, b)返回一个随机浮点数 N ，当 a &lt;= b 时 a &lt;= N &lt;= b ，当 b &lt; a 时 b &lt;= N &lt;= a 。 取决于等式 a + (b-a) * random() 中的浮点舍入，终点 b 可以包括或不包括在该范围内。 random.triangular(low, high, mode)返回一个随机浮点数 N ，使得 low &lt;= N &lt;= high 并在这些边界之间使用指定的 mode 。 low 和 high 边界默认为零和一。 mode 参数默认为边界之间的中点，给出对称分布。 random.betavariate(alpha, beta)Beta 分布。 参数的条件是 alpha &gt; 0 和 beta &gt; 0。 返回值的范围介于 0 和 1 之间。 random.expovariate(lambd)指数分布。 lambd 是 1.0 除以所需的平均值，它应该是非零的。 （该参数本应命名为 “lambda” ，但这是 Python 中的保留字。）如果 lambd 为正，则返回值的范围为 0 到正无穷大；如果 lambd 为负，则返回值从负无穷大到 0。 random.gammavariate(alpha, beta)Gamma 分布。 （ 不是 gamma 函数！ ） 参数的条件是 alpha &gt; 0 和 beta &gt; 0。 概率分布函数是: 123 x ** (alpha - 1) * math.exp(-x / beta)pdf(x) = -------------------------------------- math.gamma(alpha) * beta ** alpha random.gauss(mu, sigma)高斯分布。 mu 是平均值，sigma 是标准差。 这比下面定义的 normalvariate() 函数略快。 random.lognormvariate(mu, sigma)对数正态分布。 如果你采用这个分布的自然对数，你将得到一个正态分布，平均值为 mu 和标准差为 sigma 。 mu 可以是任何值，sigma 必须大于零。 random.normalvariate(mu, sigma)正态分布。 mu 是平均值，sigma 是标准差。 random.vonmisesvariate(mu, kappa)mu 是平均角度，以弧度表示，介于0和 2pi* 之间，kappa 是浓度参数，必须大于或等于零。 如果 kappa 等于零，则该分布在0到 2pi* 的范围内减小到均匀的随机角度。 random.paretovariate(alpha)帕累托分布。 alpha 是形状参数。 random.weibullvariate(alpha, beta)威布尔分布。 alpha 是比例参数，beta 是形状参数。 参考：https://docs.python.org/zh-cn/3.7/library/random.html]]></content>
      <categories>
        <category>python</category>
        <category>module</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>module</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python numpy 快速入门]]></title>
    <url>%2Fpython%2Fmodule%2Fck9bgz83200d9qov7vlwrwg8h.html</url>
    <content type="text"><![CDATA[Numpy是一个功能强大的Python库，允许更高级的数据操作和数学计算。 基础篇理解 NumPyNumpy是一个功能强大的Python库，允许更高级的数据操作和数学计算。 什么是 NumPy?NumPy来源于两个单词 Numerical和Python，是一个功能强大的Python库，主要用于对多维数组执行计算。 NumPy 的安装pip install numpy NumPy 中的数组NumPy提供的最重要的数据结构是一个称为NumPy数组的强大对象。NumPy数组是通常的Python数组的扩展。NumPy数组配备了大量的函数和运算符，可以帮助我们快速编写各种类型计算的高性能代码。 一维Numpy数组定义:12345&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; my_array = np.array([1, 2, 3, 4, 5])&gt;&gt;&gt; print(my_array)[1 2 3 4 5] 创建指定个数元素为0的数组(np.zeros)1234567&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; np.zeros(5)array([0., 0., 0., 0., 0.])&gt;&gt;&gt; print(np.zeros(5))[0. 0. 0. 0. 0.] 创建指定个数元素为1的数组(np.ones)1234567&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; np.ones(5)array([1., 1., 1., 1., 1.])&gt;&gt;&gt; print(np.ones(5))[1. 1. 1. 1. 1.] 创建指定个数元素为n的数组(np.full)1234567&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; np.full(5, 2)array([2, 2, 2, 2, 2])&gt;&gt;&gt; print(np.full(5, 2))[2 2 2 2 2] 创建单位矩阵(np.eye)123456&gt;&gt;&gt; np.eye(5)array([[1., 0., 0., 0., 0.], [0., 1., 0., 0., 0.], [0., 0., 1., 0., 0.], [0., 0., 0., 1., 0.], [0., 0., 0., 0., 1.]]) NumPy中的数组操作使用NumPy，你可以轻松地在数组上执行数学运算。例如，你可以添加NumPy数组，你可以减去它们，你可以将它们相乘，甚至可以将它们分开。 以下是一些例子： 12345678910111213141516171819import numpy as np a = np.array([[1.0, 2.0], [3.0, 4.0]]) b = np.array([[5.0, 6.0], [7.0, 8.0]]) sum = a + b difference = a - b product = a * b quotient = a / b print "Sum = \n", sum print "Difference = \n", difference print "Product = \n", product print "Quotient = \n", quotient # The output will be as follows: Sum = [[ 6. 8.] [10. 12.]]Difference = [[-4. -4.] [-4. -4.]]Product = [[ 5. 12.] [21. 32.]]Quotient = [[0.2 0.33333333] [0.42857143 0.5 ]] 如你所见，乘法运算符执行逐元素乘法而不是矩阵乘法。 要执行矩阵乘法，你可以执行以下操作： 12matrix_product = a.dot(b) print "Matrix Product = ", matrix_product 输出将是： 12[[19. 22.][43. 50.]] NumPy 简单入门教程数组基础创建一个数组1234567891011# 1D Arraya = np.array([0, 1, 2, 3, 4])b = np.array((0, 1, 2, 3, 4))c = np.arange(5)d = np.linspace(0, 2*np.pi, 5)print(a) # &gt;&gt;&gt;[0 1 2 3 4]print(b) # &gt;&gt;&gt;[0 1 2 3 4]print(c) # &gt;&gt;&gt;[0 1 2 3 4]print(d) # &gt;&gt;&gt;[ 0. 1.57079633 3.14159265 4.71238898 6.28318531]print(a[3]) # &gt;&gt;&gt;3 12345678# MD Array,a = np.array([[11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25], [26, 27, 28 ,29, 30], [31, 32, 33, 34, 35]]) print(a[2,4]) # &gt;&gt;&gt;25 多维数组切片1234567# MD slicingprint(a[0, 1:4]) # &gt;&gt;&gt;[12 13 14]print(a[1:4, 0]) # &gt;&gt;&gt;[16 21 26]print(a[::2,::2]) # &gt;&gt;&gt;[[11 13 15] # [21 23 25] # [31 33 35]]print(a[:, 1]) # &gt;&gt;&gt;[12 17 22 27 32] 数组属性123456789101112131415161718192021# Array propertiesa = np.array([[11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25], [26, 27, 28 ,29, 30], [31, 32, 33, 34, 35]])print(type(a)) # &gt;&gt;&gt;&lt;class 'numpy.ndarray'&gt;print(a.dtype) # &gt;&gt;&gt;int64print(a.size) # &gt;&gt;&gt;25print(a.shape) # &gt;&gt;&gt;(5, 5)print(a.itemsize) # &gt;&gt;&gt;8print(a.ndim) # &gt;&gt;&gt;2print(a.nbytes) # &gt;&gt;&gt;200# dtype 数据类型# size 数组元素的个数# shape 数组行数和列数# itemsize 每个项占用的字节数# ndim 数组的维数# nbytes 数组中的所有数据消耗掉的字节数，实际开销将稍大。 使用数组基本操作符1234567891011121314151617# Basic Operatorsa = np.arange(25)a = a.reshape((5, 5))b = np.array([10, 62, 1, 14, 2, 56, 79, 2, 1, 45, 4, 92, 5, 55, 63, 43, 35, 6, 53, 24, 56, 3, 56, 44, 78])b = b.reshape((5,5))print(a + b)print(a - b)print(a * b)print(a / b)print(a ** 2)print(a &lt; b) print(a &gt; b)print(a.dot(b)) 除了 dot() 之外，这些操作符都是对数组进行逐元素运算。比如 (a, b, c) + (d, e, f) 的结果就是 (a+d, b+e, c+f)。它将分别对每一个元素进行配对，然后对它们进行运算。它返回的结果是一个数组。注意，当使用逻辑运算符比如 “&lt;” 和 “&gt;” 的时候，返回的将是一个布尔型数组。 dot() 函数计算两个数组的点积。它返回的是一个标量（只有大小没有方向的一个值）而不是数组。 数组特殊运算符123456789101112# dot, sum, min, max, cumsuma = np.arange(10)print(a.sum()) # &gt;&gt;&gt;45print(a.min()) # &gt;&gt;&gt;0print(a.max()) # &gt;&gt;&gt;9print(a.cumsum()) # &gt;&gt;&gt;[ 0 1 3 6 10 15 21 28 36 45]# sum() 所有元素相加# min() 最小元素# max() 最大元素# cumsum() 将第一个元素和第二个元素相加，并将计算结果存储在一个列表中，然后将该结果添加到第三个元素中，然后再将该结果存储在一个列表中。这将对数组中的所有元素执行此操作，并返回作为列表的数组之和的运行总数。 索引进阶花式索引(Fancy indexing)123456# Fancy indexinga = np.arange(0, 100, 10)indices = [1, 5, -1]b = a[indices]print(a) # &gt;&gt;&gt;[ 0 10 20 30 40 50 60 70 80 90]print(b) # &gt;&gt;&gt;[10 50 90] 布尔屏蔽(Boolean masking)布尔屏蔽是一个有用的功能，它允许我们根据我们指定的条件检索数组中的元素 1234567891011# Boolean maskingimport matplotlib.pyplot as plta = np.linspace(0, 2 * np.pi, 50)b = np.sin(a)plt.plot(a,b)mask = b &gt;= 0plt.plot(a[mask], b[mask], 'bo')mask = (b &gt;= 0) &amp; (a &lt;= np.pi / 2)plt.plot(a[mask], b[mask], 'go')plt.show() 位运算符 &amp; 按位与运算符：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0 (a &amp; b) 输出结果 12 ，二进制解释： 0000 1100 | 按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1。 (a | b) 输出结果 61 ，二进制解释： 0011 1101 ^ 按位异或运算符：当两对应的二进位相异时，结果为1 (a ^ b) 输出结果 49 ，二进制解释： 0011 0001 ~ 按位取反运算符：对数据的每个二进制位取反,即把1变为0,把0变为1 。~x 类似于 -x-1 (~a ) 输出结果 -61 ，二进制解释： 1100 0011，在一个有符号二进制数的补码形式。 &lt;&lt; 左移动运算符：运算数的各二进位全部左移若干位，由 &lt;&lt; 右边的数字指定了移动的位数，高位丢弃，低位补0。 a &lt;&lt; 2 输出结果 240 ，二进制解释： 1111 0000 &gt;&gt; 右移动运算符：把”&gt;&gt;”左边的运算数的各二进位全部右移若干位，&gt;&gt; 右边的数字指定了移动的位数 a &gt;&gt; 2 输出结果 15 ，二进制解释： 0000 1111 缺省索引(Incomplete Indexing)123456# Incomplete Indexinga = np.arange(0, 100, 10)b = a[:5]c = a[a &gt;= 50]print(b) # &gt;&gt;&gt;[ 0 10 20 30 40]print(c) # &gt;&gt;&gt;[50 60 70 80 90] Where 函数123456# Wherea = np.arange(0, 100, 10)b = np.where(a &lt; 50) c = np.where(a &gt;= 50)[0]print(b) # &gt;&gt;&gt;(array([0, 1, 2, 3, 4]),)print(c) # &gt;&gt;&gt;[5 6 7 8 9] Python、Numpy 教程数组(Arrays)numpy数组是一个值网格，所有类型都相同，并由非负整数元组索引。 维数是数组的排名; 数组的形状是一个整数元组，给出了每个维度的数组大小。 Numpy还提供了许多创建数组的函数 1234567891011121314151617181920import numpy as npa = np.zeros((2,2)) # Create an array of all zerosprint(a) # Prints "[[ 0. 0.] # [ 0. 0.]]"b = np.ones((1,2)) # Create an array of all onesprint(b) # Prints "[[ 1. 1.]]"c = np.full((2,2), 7) # Create a constant arrayprint(c) # Prints "[[ 7. 7.] # [ 7. 7.]]"d = np.eye(2) # Create a 2x2 identity matrixprint(d) # Prints "[[ 1. 0.] # [ 0. 1.]]"e = np.random.random((2,2)) # Create an array filled with random valuesprint(e) # Might print "[[ 0.91940167 0.08143941] # [ 0.68744134 0.87236687]]" 数组索引切片(Slicing)与Python列表类似，可以对numpy数组进行切片。由于数组可能是多维的，因此必须为数组的每个维指定一个切片 12345678910111213141516171819import numpy as np# Create the following rank 2 array with shape (3, 4)# [[ 1 2 3 4]# [ 5 6 7 8]# [ 9 10 11 12]]a = np.array([[1,2,3,4], [5,6,7,8], [9,10,11,12]])# Use slicing to pull out the subarray consisting of the first 2 rows# and columns 1 and 2; b is the following array of shape (2, 2):# [[2 3]# [6 7]]b = a[:2, 1:3]# A slice of an array is a view into the same data, so modifying it# will modify the original array.print(a[0, 1]) # Prints "2"b[0, 0] = 77 # b[0, 0] is the same piece of data as a[0, 1]print(a[0, 1]) # Prints "77" 整数数组索引使用切片索引到numpy数组时，生成的数组视图将始终是原始数组的子数组。 相反，整数数组索引允许你使用另一个数组中的数据构造任意数组 1234567891011121314151617import numpy as npa = np.array([[1,2], [3, 4], [5, 6]])# An example of integer array indexing.# The returned array will have shape (3,) andprint(a[[0, 1, 2], [0, 1, 0]]) # Prints "[1 4 5]"# The above example of integer array indexing is equivalent to this:print(np.array([a[0, 0], a[1, 1], a[2, 0]])) # Prints "[1 4 5]"# When using integer array indexing, you can reuse the same# element from the source array:print(a[[0, 0], [1, 1]]) # Prints "[2 2]"# Equivalent to the previous integer array indexing exampleprint(np.array([a[0, 1], a[0, 1]])) # Prints "[2 2]" 整数数组索引的一个有用技巧是从矩阵的每一行中选择或改变一个元素 1234567891011121314151617181920212223import numpy as np# Create a new array from which we will select elementsa = np.array([[1,2,3], [4,5,6], [7,8,9], [10, 11, 12]])print(a) # prints "array([[ 1, 2, 3], # [ 4, 5, 6], # [ 7, 8, 9], # [10, 11, 12]])"# Create an array of indicesb = np.array([0, 2, 0, 1])# Select one element from each row of a using the indices in bprint(a[np.arange(4), b]) # Prints "[ 1 6 7 11]"# Mutate one element from each row of a using the indices in ba[np.arange(4), b] += 10print(a) # prints "array([[11, 2, 3], # [ 4, 5, 16], # [17, 8, 9], # [10, 21, 12]]) 布尔数组索引布尔数组索引允许你选择数组的任意元素。通常，这种类型的索引用于选择满足某些条件的数组元素。 1234567891011121314151617181920import numpy as npa = np.array([[1,2], [3, 4], [5, 6]])bool_idx = (a &gt; 2) # Find the elements of a that are bigger than 2; # this returns a numpy array of Booleans of the same # shape as a, where each slot of bool_idx tells # whether that element of a is &gt; 2.print(bool_idx) # Prints "[[False False] # [ True True] # [ True True]]"# We use boolean array indexing to construct a rank 1 array# consisting of the elements of a corresponding to the True values# of bool_idxprint(a[bool_idx]) # Prints "[3 4 5 6]"# We can do all of the above in a single concise statement:print(a[a &gt; 2]) # Prints "[3 4 5 6]" 数组中的数学基本数学函数在数组上以元素方式运行，既可以作为运算符重载，也可以作为numpy模块中的函数 123456789101112131415161718192021222324252627282930313233import numpy as npx = np.array([[1,2],[3,4]], dtype=np.float64)y = np.array([[5,6],[7,8]], dtype=np.float64)# Elementwise sum; both produce the array# [[ 6.0 8.0]# [10.0 12.0]]print(x + y)print(np.add(x, y))# Elementwise difference; both produce the array# [[-4.0 -4.0]# [-4.0 -4.0]]print(x - y)print(np.subtract(x, y))# Elementwise product; both produce the array# [[ 5.0 12.0]# [21.0 32.0]]print(x * y)print(np.multiply(x, y))# Elementwise division; both produce the array# [[ 0.2 0.33333333]# [ 0.42857143 0.5 ]]print(x / y)print(np.divide(x, y))# Elementwise square root; produces the array# [[ 1. 1.41421356]# [ 1.73205081 2. ]]print(np.sqrt(x)) Numpy为在数组上执行计算提供了许多有用的函数；其中最有用的函数之一是 SUM： 1234567import numpy as npx = np.array([[1,2],[3,4]])print(np.sum(x)) # Compute sum of all elements; prints "10"print(np.sum(x, axis=0)) # Compute sum of each column; prints "[4 6]"print(np.sum(x, axis=1)) # Compute sum of each row; prints "[3 7]" 你可以在这篇文档中找到numpy提供的数学函数的完整列表。 除了使用数组计算数学函数外，我们经常需要对数组中的数据进行整形或其他操作。这种操作的最简单的例子是转置一个矩阵；要转置一个矩阵，只需使用一个数组对象的T属性： 123456789101112import numpy as npx = np.array([[1,2], [3,4]])print(x) # Prints "[[1 2] # [3 4]]"print(x.T) # Prints "[[1 3] # [2 4]]"# Note that taking the transpose of a rank 1 array does nothing:v = np.array([1,2,3])print(v) # Prints "[1 2 3]"print(v.T) # Prints "[1 2 3]" 广播(Broadcasting)广播是一种强大的机制，它允许numpy在执行算术运算时使用不同形状的数组。通常，我们有一个较小的数组和一个较大的数组，我们希望多次使用较小的数组来对较大的数组执行一些操作 例如，假设我们要向矩阵的每一行添加一个常数向量。我们可以这样做： 123456789101112131415161718import numpy as np# We will add the vector v to each row of the matrix x,# storing the result in the matrix yx = np.array([[1,2,3], [4,5,6], [7,8,9], [10, 11, 12]])v = np.array([1, 0, 1])y = np.empty_like(x) # Create an empty matrix with the same shape as x# Add the vector v to each row of the matrix x with an explicit loopfor i in range(4): y[i, :] = x[i, :] + v# Now y is the following# [[ 2 2 4]# [ 5 5 7]# [ 8 8 10]# [11 11 13]]print(y) 这会凑效; 但是当矩阵 x 非常大时，在Python中计算显式循环可能会很慢。注意，向矩阵 x 的每一行添加向量 v 等同于通过垂直堆叠多个 v 副本来形成矩阵 vv，然后执行元素的求和x 和 vv。 我们可以像如下这样实现这种方法： 12345678910111213141516import numpy as np# We will add the vector v to each row of the matrix x,# storing the result in the matrix yx = np.array([[1,2,3], [4,5,6], [7,8,9], [10, 11, 12]])v = np.array([1, 0, 1])vv = np.tile(v, (4, 1)) # Stack 4 copies of v on top of each otherprint(vv) # Prints "[[1 0 1] # [1 0 1] # [1 0 1] # [1 0 1]]"y = x + vv # Add x and vv elementwiseprint(y) # Prints "[[ 2 2 4 # [ 5 5 7] # [ 8 8 10] # [11 11 13]]" Numpy广播允许我们在不实际创建v的多个副本的情况下执行此计算。考虑这个需求，使用广播如下： 1234567891011import numpy as np# We will add the vector v to each row of the matrix x,# storing the result in the matrix yx = np.array([[1,2,3], [4,5,6], [7,8,9], [10, 11, 12]])v = np.array([1, 0, 1])y = x + v # Add v to each row of x using broadcastingprint(y) # Prints "[[ 2 2 4] # [ 5 5 7] # [ 8 8 10] # [11 11 13]]" y=x+v行即使x具有形状(4，3)和v具有形状(3,)，但由于广播的关系，该行的工作方式就好像v实际上具有形状(4，3)，其中每一行都是v的副本，并且求和是按元素执行的。 将两个数组一起广播遵循以下规则： 如果数组不具有相同的rank，则将较低等级数组的形状添加1，直到两个形状具有相同的长度。 如果两个数组在维度上具有相同的大小，或者如果其中一个数组在该维度中的大小为1，则称这两个数组在维度上是兼容的。 如果数组在所有维度上兼容，则可以一起广播。 广播之后，每个数组的行为就好像它的形状等于两个输入数组的形状的元素最大值。 在一个数组的大小为1且另一个数组的大小大于1的任何维度中，第一个数组的行为就像沿着该维度复制一样 创建 Numpy 数组的不同方式创建Numpy数组有三种不同的方法： 使用Numpy内部功能函数 从列表等其他Python的结构进行转换 使用特殊的库函数 使用Numpy内部功能函数Numpy具有用于创建数组的内置函数。 创建一个一维的数组12import Numpy as nparray = np.arange(20) 创建一个二维数组12import Numpy as nparray = np.arange(20).reshap(4,5) 创建三维数组及更多维度12import Numpy as nparray = np.arange(27).reshap(3,3,3) 创建一个填充零的数组12import numpy as nparray = np.zeros((2,4)) 创建一个填充1的数组12import numpy as nparray = np.ones((2,4)) 创建一个空的数组它的初始内容是随机的，取决于内存的状态 12import numpy as nparray = np.empty((2,3)) 创建一个填充给定值的数组12import numpy as nparray = np.full((2,2), 3) 创建一个单位矩阵 12import numpy as nparray = np.eye(3) 创建指定的时间间隔的数组12import numpy as nparray = np.linspace(0, 10, num=4) 从Python列表转换123import numpy as nparray1 = np.array([4,5,6])array2 = np.array([(1,2,3), (4,5,6)]) 使用特殊的库函数12import numpy as nparray = np.random.random((2,2)) 进阶篇NumPy数据分析问答导入numpy作为np，并查看版本12345import numpy as npnp.__version__# '1.15.4' 如何创建一维数组123arr = np.arange(10)# array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) 如何创建一个布尔数组12345678910# 创建一个numpy数组元素值全为True（真）的数组np.full((3, 3), True, dtype=bool)# &gt; array([[ True, True, True],# &gt; [ True, True, True],# &gt; [ True, True, True]], dtype=bool)# Alternate method:np.ones((3,3), dtype=bool) 如何从一维数组中提取满足指定条件的元素？123456# 从 arr 中提取所有的奇数arr = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])arr[arr % 2 == 1]# array([1, 3, 5, 7, 9]) 如何用numpy数组中的另一个值替换满足条件的元素项？123456# 将arr中的所有奇数替换为-1arr = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])arr[arr % 2 == 1] = -1# array([ 0, -1, 2, -1, 4, -1, 6, -1, 8, -1]) 如何在不影响原始数组的情况下替换满足条件的元素项？1234567# 将arr中的所有奇数替换为-1，而不改变arrarr = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])out = np.where(arr % 2 ==1, -1, arr)print(out)# [ 0 -1 2 -1 4 -1 6 -1 8 -1] 如何改变数组的形状？1234567# 将一维数组转换为2行的2维数组arr = np.arange(10)arr.reshape(2, -1) # Setting to -1 automatically decides the number of cols# array([[0, 1, 2, 3, 4],# [5, 6, 7, 8, 9]]) 如何垂直叠加两个数组？123456789101112131415161718# 垂直堆叠数组a和数组ba = np.arange(10).reshape(2,-1)b = np.repeat(1, 10).reshape(2,-1)# Answers# Method 1:np.concatenate((a, b), axis=0)# Method 2:np.vstack((a, b))# Method 3:np.r_[a, b][[0, 1, 2, 3, 4], [5, 6, 7, 8, 9], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]] 如何水平叠加两个数组?12345678910111213141516# 将数组a和数组b水平堆叠a = np.arange(10).reshape(2,-1)b = np.repeat(1, 10).reshape(2,-1)# Answers# Method 1:np.concatenate((a, b), axis=1)# Method 2:np.hstack((a, b))# Method 3:np.c_[a, b]# array([[0, 1, 2, 3, 4, 1, 1, 1, 1, 1],# [5, 6, 7, 8, 9, 1, 1, 1, 1, 1]]) 如何在无硬编码的情况下生成numpy中的自定义序列？12345678910111213# 创建以下模式而不使用硬编码。只使用numpy函数和下面的输入数组a。# 给定：# a = np.array([1,2,3])# 期望的输出：# array([1, 1, 1, 2, 2, 2, 3, 3, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3])# Method 1:np.r_[np.repeat(a, 3), np.tile(a, 3)]# Method 2:np.concatenate((np.repeat(a, 3), np.tile(a, 3)), axis=0)# array([1, 1, 1, 2, 2, 2, 3, 3, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3]) 如何获取两个numpy数组之间的公共项？123456789101112# 获取数组a和数组b之间的公共项。# 给定：# a = np.array([1,2,3,2,3,4,3,4,5,6])# b = np.array([7,2,10,2,7,4,9,4,9,8])# 期望的输出：# array([2, 4])a = np.array([1,2,3,2,3,4,3,4,5,6])b = np.array([7,2,10,2,7,4,9,4,9,8])np.intersect1d(a, b)# array([2, 4]) 如何从一个数组中删除存在于另一个数组中的项？12345678910111213# 从数组a中删除数组b中的所有项# 给定：# a = np.array([1,2,3,4,5])# b = np.array([5,6,7,8,9])# 期望的输出：# array([1,2,3,4])a = np.array([1,2,3,4,5])b = np.array([5,6,7,8,9])# From 'a' remove all of 'b'np.setdiff1d(a,b)# array([1, 2, 3, 4]) 如何得到两个数组元素匹配的位置？123456789101112# 获取a和b元素匹配的位置。# 给定：# a = np.array([1,2,3,2,3,4,3,4,5,6])# b = np.array([7,2,10,2,7,4,9,4,9,8])# 期望的输出：# (array([1, 3, 5, 7]),)a = np.array([1,2,3,2,3,4,3,4,5,6])b = np.array([7,2,10,2,7,4,9,4,9,8])np.where(a == b)# &gt; (array([1, 3, 5, 7]),) 如何从numpy数组中提取给定范围内的所有数字？123456789101112131415161718# 获取5到10之间的所有项目。# 给定：# a = np.array([2, 6, 1, 9, 10, 3, 27])# 期望的输出：# (array([6, 9, 10]),)# Method 1:index = np.where((a &gt;= 5 &amp; a &lt;= 10))a[index]# Method 2:a[np.where(np.logical_and(a&gt;=5, a&lt;=10))]# Method 3:a[(a &gt;= 5) &amp; (a &lt;= 10)]# Method 4:a[np.logical_and(a &gt;= 5, a &lt;= 10)] 如何创建一个python函数来处理scalars并在numpy数组上工作？123456789101112131415161718192021222324252627282930# 转换适用于两个标量的函数maxx，以处理两个数组。# 给定：# def maxx(x, y):# """Get the maximum of two items"""# if x &gt;= y:# return x# else:# return y# maxx(1, 5)# &gt; 5# 期望的输出：# a = np.array([5, 7, 9, 8, 6, 4, 5])# b = np.array([6, 3, 4, 8, 9, 7, 1])# pair_max(a, b)# &gt; array([ 6., 7., 9., 8., 9., 7., 5.])def maxx(x, y): """Get the maximum of two items""" if x &gt;= y: return x else: return ypair_max = np.vectorize(maxx, otypes=[float])a = np.array([5, 7, 9, 8, 6, 4, 5])b = np.array([6, 3, 4, 8, 9, 7, 1])pair_max(a, b)# &gt; array([ 6., 7., 9., 8., 9., 7., 5.]) 如何交换二维numpy数组中的两列？123456789101112# 在数组arr中交换列1和2。# Inputarr = np.arange(9).reshape(3,3)arr# Solutionarr[:, [1,0,2]]# &gt; array([[1, 0, 2],# &gt; [4, 3, 5],# &gt; [7, 6, 8]]) 如何交换二维numpy数组中的两行？12345678910# 交换数组arr中的第1和第2行# Inputarr = np.arange(9).reshape(3,3)# Solutionarr[[1,0,2], :]# &gt; array([[3, 4, 5],# &gt; [0, 1, 2],# &gt; [6, 7, 8]]) 如何反转二维数组的行？12345678910# 反转二维数组arr的行。# Inputarr = np.arange(9).reshape(3,3)# Solutionarr[::-1]array([[6, 7, 8], [3, 4, 5], [0, 1, 2]]) 如何反转二维数组的列12345678910# 反转二维数组arr的列# Inputarr = np.arange(9).reshape(3,3)# Solutionarr[:, ::-1]# &gt; array([[2, 1, 0],# &gt; [5, 4, 3],# &gt; [8, 7, 6]]) 如何创建包含5到10之间随机浮动的二维数组？12345678910111213141516# 创建一个形状为5x3的二维数组，以包含5到10之间的随机十进制数。# Inputarr = np.arange(9).reshape(3,3)# Solution Method 1:rand_arr = np.random.randint(low=5, high=10, size=(5,3)) + np.random.random((5,3))# print(rand_arr)# Solution Method 2:rand_arr = np.random.uniform(5,10, size=(5,3))print(rand_arr)# &gt; [[ 8.50061025 9.10531502 6.85867783]# &gt; [ 9.76262069 9.87717411 7.13466701]# &gt; [ 7.48966403 8.33409158 6.16808631]# &gt; [ 7.75010551 9.94535696 5.27373226]# &gt; [ 8.0850361 5.56165518 7.31244004]] 如何在numpy数组中只打印小数点后三位？只打印或显示numpy数组rand_arr的小数点后3位。 给定： 1rand_arr = np.random.random((5,3)) 答案： 12345678910111213# Inputrand_arr = np.random.random((5,3))# Create the random arrayrand_arr = np.random.random([5,3])# Limit to 3 decimal placesnp.set_printoptions(precision=3)rand_arr[:4]# &gt; array([[ 0.443, 0.109, 0.97 ],# &gt; [ 0.388, 0.447, 0.191],# &gt; [ 0.891, 0.474, 0.212],# &gt; [ 0.609, 0.518, 0.403]]) 如何通过e式科学记数法（如1e10）来打印一个numpy数组？问题：通过e式科学记数法来打印rand_arr（如1e10） 给定： 12345678# Create the random arraynp.random.seed(100)rand_arr = np.random.random([3,3])/1e3rand_arr# &gt; array([[ 5.434049e-04, 2.783694e-04, 4.245176e-04],# &gt; [ 8.447761e-04, 4.718856e-06, 1.215691e-04],# &gt; [ 6.707491e-04, 8.258528e-04, 1.367066e-04]]) 期望的输出： 123# &gt; array([[ 0.000543, 0.000278, 0.000425],# &gt; [ 0.000845, 0.000005, 0.000122],# &gt; [ 0.000671, 0.000826, 0.000137]]) 答案： 123456789101112131415# Reset printoptions to defaultnp.set_printoptions(suppress=False)# Create the random arraynp.random.seed(100)rand_arr = np.random.random([3,3])/1e3rand_arr# &gt; array([[ 5.434049e-04, 2.783694e-04, 4.245176e-04],# &gt; [ 8.447761e-04, 4.718856e-06, 1.215691e-04],# &gt; [ 6.707491e-04, 8.258528e-04, 1.367066e-04]])np.set_printoptions(suppress=True, precision=6) # precision is optionalrand_arr# &gt; array([[ 0.000543, 0.000278, 0.000425],# &gt; [ 0.000845, 0.000005, 0.000122],# &gt; [ 0.000671, 0.000826, 0.000137]]) 其他篇]]></content>
      <categories>
        <category>python</category>
        <category>module</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>module</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell 杂记]]></title>
    <url>%2Fshell%2Fck9bgz7s80082qov7toaasnpi.html</url>
    <content type="text"><![CDATA[shell 杂记主要记录shell使用的以下小技巧，及命令。 从给定的文件中查找最大数及最小数问题：从下述文件中找到最大值机最小值并打印。 12345678910111213[root@hadoop01 shell]# cat number.txt158 252 638915124485 781 256 4931249-1393 85 63145 863[root@hadoop01 shell]# 实现1234[root@hadoop01 shell]# cat number.txt | sed 's/ /\n/g' | grep -v '^$' | sort -nr | sed -n '1p;$p'6389-1393[root@hadoop01 shell]# 注： sed ‘s/ /\n/g’ 作用是将空格替换为换行符，是一个数字占一行 grep -v ‘^$’ 作用是过滤空行 sort -nr 作用是将每行数字倒序排序 sed -n ‘1p;$p’ 作用是输出第一行和最后一行 find命令玩法过滤指定类型的文件1# find . -maxdepth 1 -type f -name '*.txt' 过滤指定类型及大小的文件1# find . -maxdepth 1 -type f -size +50M -name '*.txt' 过滤10天以前的文件1# find . -maxdepth 1 -type f -mtime +10 -name '*.txt' 过滤最经10天的文件1# find . -maxdepth 1 -type f -mtime -10 -name '*.txt' 将匹配到的文件删除12# find . -maxdepth 1 -type f -mtime +30 -name '*.txt' -exec rm -rf &#123;&#125; \;# find . -maxdepth 1 -type f -mtime +30 -name '*.txt' | xargs rm -rf &#123;&#125; \; awk玩法输出指定列的内容12345678910111213141516171819[root@hadoop01 shell]# cat hostsmaster 192.168.10.11work1 192.168.10.12work2 192.168.10.13[root@hadoop01 shell]# cat hosts | awk '&#123;print $2&#125;'192.168.10.11192.168.10.12192.168.10.13[root@hadoop01 shell]# cat hosts | awk '&#123;print "IP is " $2&#125;'IP is 192.168.10.11IP is 192.168.10.12IP is 192.168.10.13[root@hadoop01 shell]# cat hosts | awk '&#123;print $2&#125;' | awk -F\. '&#123;print "IP first section " $1&#125;'IP first section 192IP first section 192IP first section 192 注： awk -F[sep] 该参数可重新指定列分割标识符 linux shell 中 %% *的含义定义了一个变量： 1file=/dir1/dir2/dir3/my.file.txt 可以用${ }分别替换得到不同的值： 1234567891011121314$&#123;file#*/&#125;：删掉第一个 / 及其左边的字符串：dir1/dir2/dir3/my.file.txt$&#123;file##*/&#125;：删掉最后一个 / 及其左边的字符串：my.file.txt$&#123;file#*.&#125;：删掉第一个 . 及其左边的字符串：file.txt$&#123;file##*.&#125;：删掉最后一个 . 及其左边的字符串：txt$&#123;file%/*&#125;：删掉最后一个 / 及其右边的字符串：/dir1/dir2/dir3$&#123;file%%/*&#125;：删掉第一个 / 及其右边的字符串：(空值)$&#123;file%.*&#125;：删掉最后一个 . 及其右边的字符串：/dir1/dir2/dir3/my.file$&#123;file%%.*&#125;：删掉第一个 . 及其右边的字符串：/dir1/dir2/dir3/my$&#123;file:0:5&#125;：提取最左边的 5 个字节：/dir1$&#123;file:5:5&#125;：提取第 5 个字节右边的连续5个字节：/dir2也可以对变量值里的字符串作替换：$&#123;file/dir/path&#125;：将第一个dir 替换为path：/path1/dir2/dir3/my.file.txt$&#123;file//dir/path&#125;：将全部dir 替换为 path：/path1/path2/path3/my.file.txt 记忆的方法为： #是 去掉左边（键盘上#在 $ 的左边） %是去掉右边（键盘上% 在$ 的右边） 单一符号是最小匹配 两个符号是最大匹配 shell read 用法read命令用于从标准输入中读取输入单行，并将读取的单行根据IFS变量分裂成多个字段，并将分割后的字段分别赋值给指定的变量列表var_name。第一个字段分配给第一个变量var_name1，第二个字段分配给第二个变量var_name2，依次到结束。如果指定的变量名少于字段数量，则多出的字段数量也同样分配给最后一个var_name，如果指定的变量命令多于字段数量，则多出的变量赋值为空。 如果没有指定任何var_name，则分割后的所有字段都存储在特定变量REPLY中。 1usage: read [-ers] [-a array] [-d delim] [-i text] [-n nchars] [-N nchars] [-p prompt] [-t timeout] [-u fd] [name ...] 参数说明12345678910选项说明：-a：将分裂后的字段依次存储到指定的数组中，存储的起始位置从数组的index=0开始。-d：指定读取行的结束符号。默认结束符号为换行符。-n：限制读取N个字符就自动结束读取，如果没有读满N个字符就按下回车或遇到换行符，则也会结束读取。-N：严格要求读满N个字符才自动结束读取，即使中途按下了回车或遇到了换行符也不结束。其中换行符或回车算一个字符。-p：给出提示符。默认不支持&quot;\n&quot;换行，要换行需要特殊处理，见下文示例。例如，&quot;-p 请输入密码：&quot;-r：禁止反斜线的转义功能。这意味着&quot;\&quot;会变成文本的一部分。-s：静默模式。输入的内容不会回显在屏幕上。-t：给出超时时间，在达到超时时间时，read退出并返回错误。也就是说不会读取任何内容，即使已经输入了一部分。-u：从给定文件描述符(fd=N)中读取数据。-u：后面跟fd，从文件描述符中读入 将读取的内容分配给数组变量，从索引号0开始分配(-a)12345678910[root@hadoop01 shell]# read -a arrunit as one to tackle tough Blessings[root@hadoop01 shell]# echo $arrunit[root@hadoop01 shell]# echo $&#123;arr[0]&#125;unit[root@hadoop01 shell]# echo $&#123;arr[1]&#125;as[root@hadoop01 shell]# echo $&#123;arr[@]&#125;unit as one to tackle tough Blessings 指定读取行的结束符号，而不再使用换行符(-d)123456[root@hadoop01 shell]# read -d q arrwhat is you name q # 输入完尾部的&quot;q&quot;，自动结束read# 由于没有指定var_name，所以通过$REPLY变量查看read读取的行。[root@hadoop01 shell]# echo $REPLYwhat is you name 限制输入字符(-n or -N)123456789101112131415161718# 长度为5时自动结束[root@hadoop01 shell]# read -n 5 arrabcde[root@hadoop01 shell]#[root@hadoop01 shell]# echo $arrabcde# 长度不到5时按&lt;Enter&gt;结束[root@hadoop01 shell]# read -n 5 arr 123[root@hadoop01 shell]# echo $arr123# 严格模式(-N),长度必须为5[root@hadoop01 shell]# read -N 5 arr123[root@hadoop01 shell]# echo $arr12 3 给出输入提示(-p)1234[root@hadoop01 shell]# read -p "Input your name: " NAMEInput your name: Jack[root@hadoop01 shell]# echo $NAMEJack “-p”选项默认不带换行功能，且也不支持”\n”换行。但通过$’string’的方式特殊处理，就可以实现换行的功能。 123[root@hadoop01 shell]# read -p $'Input your name: \n' NAMEInput your name:Jack 禁止转义(-r)12345[root@hadoop01 shell]# read -rwhat is you name \?[root@hadoop01 shell]# echo $REPLYwhat is you name \? 不回显输入的字符(-s)1234[root@hadoop01 shell]# read -sp "input password: "input password: [root@hadoop01 shell]#[root@hadoop01 shell]# echo $REPLY123456 将读取的行分割后赋值给变量1234[root@hadoop01 shell]# read year month day2020 01 30[root@hadoop01 shell]# echo $year-$month-$day2020-01-30 shell for 循环数字性循环列表for循环 123456789#!/bin/bashfor ((i=1; i&lt;=10; i++))do echo `expr $i \* 3 + 1` # echo $(expr $i \* 3 + 1) # echo (($i * 3 + 1)) # echo $[$i * 3 + 1]done 123456#!/bin/bashfor i in $(seq 1 10)do echo $(expr $i \* 3 + 1)done 123456#!/bin/bash for i in &#123;1..10..1&#125;do echo $(expr $i \* 3 + 1)done 123#!/bin/bash awk 'BEGIN&#123;for(i=1; i&lt;=10; i++) print i&#125;' 不带列表for循环 1234567891011121314# pra_for.sh#!/bin/bash echo "number of arguments is $#"echo "What you input is: "for argumentdo echo "$argument"done# pra_for.sh a b cabc 字符性循环12345678910111213#!/bin/bash list="rootfs usr data data2"for i in $list;do echo $i is appointdone# resultrootfs is appointusr is appointdata is appointdata2 is appoint 路径查找 123456#!/bin/bash for file in /proc/*;do echo $file is file path \!done 123456#!/bin/bash for file in $(ls *.sh)do echo $file is file path \!done shell while 循环shell until 循环shell select 循环select in 循环用来增强交互性，它可以显示出带编号的菜单，用户输入不同的编号就可以选择不同的菜单，并执行不同的功能。 Shell select in 循环的用法1234select variable in value_listdo statementsdone variable 表示变量， value_list 表示取值列表， in 是 Shell 中的关键字。 示例1234567#!/bin/bashecho "What is your favourite OS?"select name in "Linux" "Windows" "Mac OS" "UNIX" "Android"do echo "You have selected $name"done 12345678910111213141516171819#!/bin/kshPS3="Please make a selection =&gt; "select DRINK in tea cofee water juice appe all nonedo case $DRINK in tea|cofee|water|all) echo "Go to canteen" ;; juice|appe) echo "Available at home" ;; none) break ;; *) echo "ERROR: Invalid selection" ;; esacdone Shell 循环控制break/continuebreakbreak语句用于终止整个循环的执行 语法 12breakbreak n # n指第n个封闭的循环退出 示例 123456789101112131415161718#!/bin/shfor var1 in 1 2 3do for var2 in 0 5 do if [ $var1 -eq 2 -a $var2 -eq 0 ] then break 2 else echo &quot;$var1 $var2&quot; fi donedone# result1 01 5 continueontinue语句break命令类似，但它会导致当前迭代的循环退出，而不是整个循环。 这种参数是有用的，当一个错误已经发生，但你想尝试执行下一个循环迭代。 语法 12continuecontinue n # 这里n指定第n个封闭循环 continue 示例 1234567891011121314#!/bin/shNUMS="1 2 3 4 5 6 7"for NUM in $NUMSdo Q=`expr $NUM % 2` if [ $Q -eq 0 ] then echo "Number is an even number!!" continue fi echo "Found odd number"done 应用过滤docker日志]]></content>
      <categories>
        <category>shell</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell 脚本]]></title>
    <url>%2Fshell%2Fck9bgz84p00esqov763ixnzom.html</url>
    <content type="text"><![CDATA[第一个shell脚本123456#!/bin/bashecho "Hello World !"注： #! 是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种 Shell。 echo 命令用于向窗口输出文本。 运行 Shell 脚本有两种方法作为可执行程序12chmod +x ./shellName.sh #使脚本具有执行权限./shellName.sh #执行脚本 作为解释器参数123/bin/sh shellName.sh或/bin/bash shellName.sh Shell 注释单行注释以 # 开头的行就是注释，会被解释器忽略。 123456#--------------------------------------------# 这是一个注释# author：菜鸟教程# site：www.runoob.com# slogan：学的不仅是技术，更是梦想！#-------------------------------------------- 多行注释12345:&lt;&lt;EOF注释内容...注释内容...注释内容...EOF 注：EOF 也可以使用其他符号。 Shell 变量定义变量时，变量名不加美元符号（$，PHP语言中变量需要） 1your_name=&quot;runoob.com&quot; 注意，变量名和等号之间不能有空格。同时，变量名的命名须遵循如下规则： 命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。 中间不能有空格，可以使用下划线（_）。 不能使用标点符号。 不能使用bash里的关键字（可用help命令查看保留关键字）。 使用变量123your_name=&quot;qinjx&quot;echo $your_nameecho $&#123;your_name&#125; 只读变量readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变。 1234#!/bin/bashmyUrl=&quot;http://www.google.com&quot;readonly myUrlmyUrl=&quot;http://www.runoob.com&quot; 删除变量 unset 命令可以删除变量，变量被删除后不能再次使用。unset 命令不能删除只读变量。 1unset variable_name 变量类型 1) 局部变量 局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。 2) 环境变量 所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。 3) shell变量 shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行 Shell 传递参数我们可以在执行 Shell 脚本时，向脚本传递参数，脚本内获取参数的格式为：$n。n 代表一个数字，0为当前执行脚本的文件名，1 为执行脚本的第一个参数，2 为执行脚本的第二个参数，以此类推…… 123456789101112131415$0 执行脚本的名字$1 执行脚本的第一个参数$2 执行脚本的第二个参数...$n 执行脚本的第n个参数$# 传递到脚本的参数个数$* 以一个单字符串显示所有向脚本传递的参数。 如&quot;$*&quot;用「&quot;」括起来的情况、以&quot;$1 $2 … $n&quot;的形式输出所有参数。$$ 脚本运行的当前进程ID号$! 后台运行的最后一个进程的ID号$@ 与$*相同，但是使用时加引号，并在引号中返回每个参数。 如&quot;$@&quot;用「&quot;」括起来的情况、以&quot;$1&quot; &quot;$2&quot; … &quot;$n&quot; 的形式输出所有参数。$- 显示Shell使用的当前选项，与set命令功能相同。$? 显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。 Shell 字符串字符串可以用单引号，也可以用双引号，也可以不用引号。 单引号1str=&apos;this is a string&apos; 单引号字符串的限制： 单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的； 单引号字串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。 双引号123your_name=&apos;runoob&apos;str=&quot;Hello, I know you are \&quot;$your_name\&quot;! \n&quot;echo -e $str 输出结果为： 1Hello, I know you are &quot;runoob&quot;! 双引号的优点： 双引号里可以有变量 双引号里可以出现转义字符 拼接字符串123456789your_name=&quot;runoob&quot;# 使用双引号拼接greeting=&quot;hello, &quot;$your_name&quot; !&quot;greeting_1=&quot;hello, $&#123;your_name&#125; !&quot;echo $greeting $greeting_1# 使用单引号拼接greeting_2=&apos;hello, &apos;$your_name&apos; !&apos;greeting_3=&apos;hello, $&#123;your_name&#125; !&apos;echo $greeting_2 $greeting_3 输出结果为： 12hello, runoob ! hello, runoob !hello, runoob ! hello, $&#123;your_name&#125; ! 获取字符串长度12string=&quot;abcd&quot;echo $&#123;#string&#125; #输出 4 提取子字符串以下实例从字符串第 2 个字符开始截取 4 个字符： 12string=&quot;runoob is a great site&quot;echo $&#123;string:1:4&#125; # 输出 unoo 查找子字符串查找字符 i 或 o 的位置，下标从1开始。(哪个字母先出现就计算哪个)： 12string=&quot;runoob is a great site&quot;echo `expr index &quot;$string&quot; io` # 输出 4 注意： 以上脚本中 ` 是反引号，而不是单引号 ‘，不要看错了哦。 Shell 数组bash支持一维数组（不支持多维数组），并且没有限定数组的大小。 类似于 C 语言，数组元素的下标由 0 开始编号。获取数组中的元素要利用下标，下标可以是整数或算术表达式，其值应大于或等于 0 定义数组在 Shell 中，用括号来表示数组，数组元素用”空格”符号分割开。定义数组的一般形式为： 12345678array_name=(value0 value1 value2 value3)或者array_name=(value0value1value2value3) 还可以单独定义数组的各个分量： 123array_name[0]=value0array_name[1]=value1array_name[n]=valuen 可以不使用连续的下标，而且下标的范围没有限制。 读取数组读取数组元素值的一般格式是： 1$&#123;数组名[下标]&#125; 例如： 1valuen=$&#123;array_name[n]&#125; 使用 @ 符号可以获取数组中的所有元素，例如： 1echo $&#123;array_name[@]&#125; 获取数组的长度获取数组长度的方法与获取字符串长度的方法相同，例如： 123456# 取得数组元素的个数length=$&#123;#array_name[@]&#125;# 或者length=$&#123;#array_name[*]&#125;# 取得数组单个元素的长度lengthn=$&#123;#array_name[n]&#125; Shell 基本运算符Shell 和其他编程语言一样，支持多种运算符，包括： 算数运算符 关系运算符 布尔运算符 字符串运算符 文件测试运算符 原生bash不支持简单的数学运算，但是可以通过其他命令来实现，例如 awk 和 expr，expr 最常用。 expr 是一款表达式计算工具，使用它能完成表达式的求值操作。 例如，两个数相加(注意使用的是反引号 ` 而不是单引号 ‘) 1234#!/bin/bashval=`expr 2 + 2`echo &quot;两数之和为 : $val&quot; 两点注意： 表达式和运算符之间要有空格，例如 2+2 是不对的，必须写成 2 + 2，这与我们熟悉的大多数编程语言不一样。 完整的表达式要被 包含，注意这个字符不是常用的单引号，在 Esc 键下边。 算术运算符下表列出了常用的算术运算符，假定变量 a 为 10，变量 b 为 20： 运算符 说明 举例 + 加法 expr $a + $b 结果为 30。 - 减法 expr $a - $b 结果为 -10。 * 乘法 expr $a \* $b 结果为 200。 / 除法 expr $b / $a 结果为 2。 % 取余 expr $b % $a 结果为 0。 = 赋值 a=$b 将把变量 b 的值赋给 a。 == 相等。用于比较两个数字，相同则返回 true。 [ $a == $b ] 返回 false。 != 不相等。用于比较两个数字，不相同则返回 true。 [ $a != $b ] 返回 true。 注意：条件表达式要放在方括号之间，并且要有空格，例如: [$a==$b] 是错误的，必须写成 [ $a == $b ]。 关系运算符关系运算符只支持数字，不支持字符串，除非字符串的值是数字。 下表列出了常用的关系运算符，假定变量 a 为 10，变量 b 为 20： 运算符 说明 举例 -eq 检测两个数是否相等，相等返回 true。 [ $a -eq $b ] 返回 false。 -ne 检测两个数是否不相等，不相等返回 true。 [ $a -ne $b ] 返回 true。 -gt 检测左边的数是否大于右边的，如果是，则返回 true。 [ $a -gt $b ] 返回 false。 -lt 检测左边的数是否小于右边的，如果是，则返回 true。 [ $a -lt $b ] 返回 true。 -ge 检测左边的数是否大于等于右边的，如果是，则返回 true。 [ $a -ge $b ] 返回 false。 -le 检测左边的数是否小于等于右边的，如果是，则返回 true。 [ $a -le $b ] 返回 true。 布尔运算符下表列出了常用的布尔运算符，假定变量 a 为 10，变量 b 为 20： 运算符 说明 举例 ! 非运算，表达式为 true 则返回 false，否则返回 true。 [ ! false ] 返回 true。 -o 或运算，有一个表达式为 true 则返回 true。 [ $a -lt 20 -o $b -gt 100 ] 返回 true。 -a 与运算，两个表达式都为 true 才返回 true。 [ $a -lt 20 -a $b -gt 100 ] 返回 false。 逻辑运算符以下介绍 Shell 的逻辑运算符，假定变量 a 为 10，变量 b 为 20: 运算符 说明 举例 &amp;&amp; 逻辑的 AND [[ $a -lt 100 &amp;&amp; $b -gt 100 ]] 返回 false || 逻辑的 OR [[ $a -lt 100 || $b -gt 100 ]] 返回 true 字符串运算符下表列出了常用的字符串运算符，假定变量 a 为 “abc”，变量 b 为 “efg”： 运算符 说明 举例 = 检测两个字符串是否相等，相等返回 true。 [ $a = $b ] 返回 false。 != 检测两个字符串是否相等，不相等返回 true。 [ $a != $b ] 返回 true。 -z 检测字符串长度是否为0，为0返回 true。 [ -z $a ] 返回 false。 -n 检测字符串长度是否为0，不为0返回 true。 [ -n “$a” ] 返回 true。 $ 检测字符串是否为空，不为空返回 true。 [ $a ] 返回 true。 文件测试运算符文件测试运算符用于检测 Unix 文件的各种属性。 属性检测描述如下： 操作符 说明 举例 -b file 检测文件是否是块设备文件，如果是，则返回 true。 [ -b $file ] 返回 false。 -c file 检测文件是否是字符设备文件，如果是，则返回 true。 [ -c $file ] 返回 false。 -d file 检测文件是否是目录，如果是，则返回 true。 [ -d $file ] 返回 false。 -f file 检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。 [ -f $file ] 返回 true。 -g file 检测文件是否设置了 SGID 位，如果是，则返回 true。 [ -g $file ] 返回 false。 -k file 检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。 [ -k $file ] 返回 false。 -p file 检测文件是否是有名管道，如果是，则返回 true。 [ -p $file ] 返回 false。 -u file 检测文件是否设置了 SUID 位，如果是，则返回 true。 [ -u $file ] 返回 false。 -r file 检测文件是否可读，如果是，则返回 true。 [ -r $file ] 返回 true。 -w file 检测文件是否可写，如果是，则返回 true。 [ -w $file ] 返回 true。 -x file 检测文件是否可执行，如果是，则返回 true。 [ -x $file ] 返回 true。 -s file 检测文件是否为空（文件大小是否大于0），不为空返回 true。 [ -s $file ] 返回 true。 -e file 检测文件（包括目录）是否存在，如果是，则返回 true。 [ -e $file ] 返回 true。 其他检查符： -S: 判断某文件是否 socket。 -L: 检测文件是否存在并且是一个符号链接。 Shell echo命令Shell 的 echo 指令与 PHP 的 echo 指令类似，都是用于字符串的输出。命令格式： 1echo string 显示普通字符串:1echo &quot;It is a test&quot; 这里的双引号完全可以省略，以下命令与上面实例效果一致： 1echo It is a test 显示转义字符1echo &quot;\&quot;It is a test\&quot;&quot; 结果将是: 1&quot;It is a test&quot; 同样，双引号也可以省略 显示变量read 命令从标准输入中读取一行,并把输入行的每个字段的值指定给 shell 变量 123#!/bin/shread name echo &quot;$name It is a test&quot; 以上代码保存为 test.sh，name 接收标准输入的变量，结果将是: 123[root@www ~]# sh test.shOK #标准输入OK It is a test #输出 显示换行12echo -e &quot;OK! \n&quot; # -e 开启转义echo &quot;It is a test&quot; 输出结果： 123OK!It is a test 显示不换行123#!/bin/shecho -e &quot;OK! \c&quot; # -e 开启转义 \c 不换行echo &quot;It is a test&quot; 输出结果： 1OK! It is a test 显示结果定向至文件1echo &quot;It is a test&quot; &gt; myfile 原样输出字符串，不进行转义或取变量(用单引号)1echo &apos;$name\&quot;&apos; 输出结果： 1$name\&quot; 显示命令执行结果1echo `date` 注意： 这里使用的是反引号 `, 而不是单引号 ‘。 结果将显示当前日期 1Thu Jul 24 10:08:46 CST 2014 Shell printf 命令上一章节我们学习了 Shell 的 echo 命令，本章节我们来学习 Shell 的另一个输出命令 printf。 printf 命令模仿 C 程序库（library）里的 printf() 程序。 printf 由 POSIX 标准所定义，因此使用 printf 的脚本比使用 echo 移植性好。 printf 使用引用文本或空格分隔的参数，外面可以在 printf 中使用格式化字符串，还可以制定字符串的宽度、左右对齐方式等。默认 printf 不会像 echo 自动添加换行符，我们可以手动添加 \n。 printf 命令的语法： 1printf format-string [arguments...] 参数说明： format-string: 为格式控制字符串 arguments: 为参数列表。 实例如下： 12345$ echo &quot;Hello, Shell&quot;Hello, Shell$ printf &quot;Hello, Shell\n&quot;Hello, Shell$ 接下来,我来用一个脚本来体现printf的强大功能： 12345678#!/bin/bash# author:菜鸟教程# url:www.runoob.com printf &quot;%-10s %-8s %-4s\n&quot; 姓名 性别 体重kg printf &quot;%-10s %-8s %-4.2f\n&quot; 郭靖 男 66.1234 printf &quot;%-10s %-8s %-4.2f\n&quot; 杨过 男 48.6543 printf &quot;%-10s %-8s %-4.2f\n&quot; 郭芙 女 47.9876 执行脚本，输出结果如下所示： 1234姓名 性别 体重kg郭靖 男 66.12杨过 男 48.65郭芙 女 47.99 %s %c %d %f都是格式替代符 %-10s 指一个宽度为10个字符（-表示左对齐，没有则表示右对齐），任何字符都会被显示在10个字符宽的字符内，如果不足则自动以空格填充，超过也会将内容全部显示出来。 %-4.2f 指格式化为小数，其中.2指保留2位小数。 更多实例： 12345678910111213141516171819202122#!/bin/bash# author:菜鸟教程# url:www.runoob.com # format-string为双引号printf &quot;%d %s\n&quot; 1 &quot;abc&quot;# 单引号与双引号效果一样 printf &apos;%d %s\n&apos; 1 &quot;abc&quot; # 没有引号也可以输出printf %s abcdef# 格式只指定了一个参数，但多出的参数仍然会按照该格式输出，format-string 被重用printf %s abc defprintf &quot;%s\n&quot; abc defprintf &quot;%s %s %s\n&quot; a b c d e f g h i j# 如果没有 arguments，那么 %s 用NULL代替，%d 用 0 代替printf &quot;%s and %d \n&quot; 执行脚本，输出结果如下所示： 1234567891 abc1 abcabcdefabcdefabcdefa b cd e fg h ij and 0 printf的转义序列 序列 说明 \a 警告字符，通常为ASCII的BEL字符 \b 后退 \c 抑制（不显示）输出结果中任何结尾的换行字符（只在%b格式指示符控制下的参数字符串中有效），而且，任何留在参数里的字符、任何接下来的参数以及任何留在格式字符串中的字符，都被忽略 \f 换页（formfeed） \n 换行 \r 回车（Carriage return） \t 水平制表符 \v 垂直制表符 \ 一个字面上的反斜杠字符 \ddd 表示1到3位数八进制值的字符。仅在格式字符串中有效 \0ddd 表示1到3位的八进制值字符 实例 123456789$ printf &quot;a string, no processing:&lt;%s&gt;\n&quot; &quot;A\nB&quot;a string, no processing:&lt;A\nB&gt;$ printf &quot;a string, no processing:&lt;%b&gt;\n&quot; &quot;A\nB&quot;a string, no processing:&lt;AB&gt;$ printf &quot;www.runoob.com \a&quot;www.runoob.com $ #不换行 Shell test 命令Shell中的 test 命令用于检查某个条件是否成立，它可以进行数值、字符和文件三个方面的测试。 数值测试 参数 说明 -eq 等于则为真 -ne 不等于则为真 -gt 大于则为真 -ge 大于等于则为真 -lt 小于则为真 -le 小于等于则为真 实例演示： 12345678num1=100num2=100if test $[num1] -eq $[num2]then echo &apos;两个数相等！&apos;else echo &apos;两个数不相等！&apos;fi 输出结果： 1两个数相等！ 代码中的 [] 执行基本的算数运算，如： 1234567#!/bin/basha=5b=6result=$[a+b] # 注意等号两边不能有空格echo &quot;result 为： $result&quot; 结果为: 1result 为： 11 字符串测试 参数 说明 = 等于则为真 != 不相等则为真 -z 字符串 字符串的长度为零则为真 -n 字符串 字符串的长度不为零则为真 实例演示： 12345678num1=&quot;ru1noob&quot;num2=&quot;runoob&quot;if test $num1 = $num2then echo &apos;两个字符串相等!&apos;else echo &apos;两个字符串不相等!&apos;fi 输出结果： 1两个字符串不相等! 文件测试 参数 说明 -e 文件名 如果文件存在则为真 -r 文件名 如果文件存在且可读则为真 -w 文件名 如果文件存在且可写则为真 -x 文件名 如果文件存在且可执行则为真 -s 文件名 如果文件存在且至少有一个字符则为真 -d 文件名 如果文件存在且为目录则为真 -f 文件名 如果文件存在且为普通文件则为真 -c 文件名 如果文件存在且为字符型特殊文件则为真 -b 文件名 如果文件存在且为块特殊文件则为真 实例演示： 1234567cd /binif test -e ./bashthen echo &apos;文件已存在!&apos;else echo &apos;文件不存在!&apos;fi 输出结果： 1文件已存在! 另外，Shell还提供了与( -a )、或( -o )、非( ! )三个逻辑操作符用于将测试条件连接起来，其优先级为：”!”最高，”-a”次之，”-o”最低。例如： 1234567cd /binif test -e ./notFile -o -e ./bashthen echo &apos;至少有一个文件存在!&apos;else echo &apos;两个文件都不存在&apos;fi 输出结果： 1至少有一个文件存在! Shell 流程控制-ififif 语句语法格式： 1234567if conditionthen command1 command2 ... commandN fi 写成一行（适用于终端命令提示符）： 1if [ $(ps -ef | grep -c &quot;ssh&quot;) -gt 1 ]; then echo &quot;true&quot;; fi 末尾的fi就是if倒过来拼写，后面还会遇到类似的。 if elseif else 语法格式： 123456789if conditionthen command1 command2 ... commandNelse commandfi if else-if elseif else-if else 语法格式： 123456789if condition1then command1elif condition2 then command2else commandNfi 以下实例判断两个变量是否相等： 1234567891011121314a=10b=20if [ $a == $b ]then echo &quot;a 等于 b&quot;elif [ $a -gt $b ]then echo &quot;a 大于 b&quot;elif [ $a -lt $b ]then echo &quot;a 小于 b&quot;else echo &quot;没有符合的条件&quot;fi 输出结果： 1a 小于 b if else语句经常与test命令结合使用，如下所示： 12345678num1=$[2*3]num2=$[1+5]if test $[num1] -eq $[num2]then echo &apos;两个数字相等!&apos;else echo &apos;两个数字不相等!&apos;fi 输出结果： 1两个数字相等! Shell 流程控制-for 循环与其他编程语言类似，Shell支持for循环。 for循环一般格式为： 1234567for var in item1 item2 ... itemNdo command1 command2 ... commandNdone 写成一行： 1for var in item1 item2 ... itemN; do command1; command2… done; 当变量值在列表里，for循环即执行一次所有命令，使用变量名获取列表中的当前取值。命令可为任何有效的shell命令和语句。in列表可以包含替换、字符串和文件名。 in列表是可选的，如果不用它，for循环使用命令行的位置参数。 例如，顺序输出当前列表中的数字： 1234for loop in 1 2 3 4 5do echo &quot;The value is: $loop&quot;done 输出结果： 12345The value is: 1The value is: 2The value is: 3The value is: 4The value is: 5 顺序输出字符串中的字符： 1234for str in &apos;This is a string&apos;do echo $strdone 输出结果： 1This is a string Shell 流程控制-while 语句while循环用于不断执行一系列命令，也用于从输入文件中读取数据；命令通常为测试条件。其格式为： 1234while conditiondo commanddone 以下是一个基本的while循环，测试条件是：如果int小于等于5，那么条件返回真。int从0开始，每次循环处理时，int加1。运行上述脚本，返回数字1到5，然后终止。 1234567#!/bin/bashint=1while(( $int&lt;=5 ))do echo $int let &quot;int++&quot;done 运行脚本，输出： 1234512345 以上实例使用了 Bash let 命令，它用于执行一个或多个表达式，变量计算中不需要加上 $ 来表示变量，具体可查阅：Bash let 命令 。 while循环可用于读取键盘信息。下面的例子中，输入信息被设置为变量FILM，按结束循环。 123456echo &apos;按下 &lt;CTRL-D&gt; 退出&apos;echo -n &apos;输入你最喜欢的网站名: &apos;while read FILMdo echo &quot;是的！$FILM 是一个好网站&quot;done 运行脚本，输出类似下面： 123按下 &lt;CTRL-D&gt; 退出输入你最喜欢的网站名:菜鸟教程是的！菜鸟教程 是一个好网站 until 循环until 循环执行一系列命令直至条件为 true 时停止。 until 循环与 while 循环在处理方式上刚好相反。 一般 while 循环优于 until 循环，但在某些时候—也只是极少数情况下，until 循环更加有用。 until 语法格式: 1234until conditiondo commanddone condition 一般为条件表达式，如果返回值为 false，则继续执行循环体内的语句，否则跳出循环。 以下实例我们使用 until 命令来输出 0 ~ 9 的数字： 123456789#!/bin/basha=0until [ ! $a -lt 10 ]do echo $a a=`expr $a + 1`done 运行结果： 输出结果为： 123456789100123456789 caseShell case语句为多选择语句。可以用case语句匹配一个值与一个模式，如果匹配成功，执行相匹配的命令。case语句格式如下： 1234567891011121314case 值 in模式1) command1 command2 ... commandN ;;模式2） command1 command2 ... commandN ;;esac case工作方式如上所示。取值后面必须为单词in，每一模式必须以右括号结束。取值可以为变量或常数。匹配发现取值符合某一模式后，其间所有命令开始执行直至 ;;。 取值将检测匹配的每一个模式。一旦模式匹配，则执行完匹配模式相应命令后不再继续其他模式。如果无一匹配模式，使用星号 * 捕获该值，再执行后面的命令。 下面的脚本提示输入1到4，与每一种模式进行匹配： 123456789101112131415echo &apos;输入 1 到 4 之间的数字:&apos;echo &apos;你输入的数字为:&apos;read aNumcase $aNum in 1) echo &apos;你选择了 1&apos; ;; 2) echo &apos;你选择了 2&apos; ;; 3) echo &apos;你选择了 3&apos; ;; 4) echo &apos;你选择了 4&apos; ;; *) echo &apos;你没有输入 1 到 4 之间的数字&apos; ;;esac 输入不同的内容，会有不同的结果，例如： 1234输入 1 到 4 之间的数字:你输入的数字为:3你选择了 3 跳出循环在循环过程中，有时候需要在未达到循环结束条件时强制跳出循环，Shell使用两个命令来实现该功能：break和continue。 break命令break命令允许跳出所有循环（终止执行后面的所有循环）。 下面的例子中，脚本进入死循环直至用户输入数字大于5。要跳出这个循环，返回到shell提示符下，需要使用break命令。 12345678910111213#!/bin/bashwhile :do echo -n &quot;输入 1 到 5 之间的数字:&quot; read aNum case $aNum in 1|2|3|4|5) echo &quot;你输入的数字为 $aNum!&quot; ;; *) echo &quot;你输入的数字不是 1 到 5 之间的! 游戏结束&quot; break ;; esacdone 执行以上代码，输出结果为： 1234输入 1 到 5 之间的数字:3你输入的数字为 3!输入 1 到 5 之间的数字:7你输入的数字不是 1 到 5 之间的! 游戏结束 continuecontinue命令与break命令类似，只有一点差别，它不会跳出所有循环，仅仅跳出当前循环。 对上面的例子进行修改： 1234567891011121314#!/bin/bashwhile :do echo -n &quot;输入 1 到 5 之间的数字: &quot; read aNum case $aNum in 1|2|3|4|5) echo &quot;你输入的数字为 $aNum!&quot; ;; *) echo &quot;你输入的数字不是 1 到 5 之间的!&quot; continue echo &quot;游戏结束&quot; ;; esacdone 运行代码发现，当输入大于5的数字时，该例中的循环不会结束，语句 echo “游戏结束” 永远不会被执行。 case … esaccase … esac 与其他语言中的 switch … case 语句类似，是一种多分枝选择结构，每个 case 分支用右圆括号开始，用两个分号 ;; 表示 break，即执行结束，跳出整个 case … esac 语句，esac（就是 case 反过来）作为结束标记。 case … esac 语法格式如下： 1234567891011121314151617case 值 in模式1) command1 command2 command3 ;;模式2） command1 command2 command3 ;;*) command1 command2 command3 ;;esac case 后为取值，值可以为变量或常数。 值后为关键字 in，接下来是匹配的各种模式，每一模式最后必须以右括号结束，模式支持正则表达式。 实例 #!/bin/sh site=”runoob” case “$site” in “runoob”) echo “菜鸟教程” ;; “google”) echo “Google 搜索” ;; “taobao”) echo “淘宝网” ;;esac 输出结果为： 1菜鸟教程 Shell 函数linux shell 可以用户定义函数，然后在shell脚本中可以随便调用。 shell中函数的定义格式如下： 123456789[ function ] funname [()]&#123; action; [return int;]&#125; 说明： 1、可以带function fun() 定义，也可以直接fun() 定义,不带任何参数。 2、参数返回，可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值n(0-255 下面的例子定义了一个函数并进行调用： 12345678910#!/bin/bash# author:菜鸟教程# url:www.runoob.comdemoFun()&#123; echo &quot;这是我的第一个 shell 函数!&quot;&#125;echo &quot;-----函数开始执行-----&quot;demoFunecho &quot;-----函数执行完毕-----&quot; 输出结果： 123-----函数开始执行-----这是我的第一个 shell 函数!-----函数执行完毕----- 下面定义一个带有return语句的函数： 123456789101112131415#!/bin/bash# author:菜鸟教程# url:www.runoob.comfunWithReturn()&#123; echo &quot;这个函数会对输入的两个数字进行相加运算...&quot; echo &quot;输入第一个数字: &quot; read aNum echo &quot;输入第二个数字: &quot; read anotherNum echo &quot;两个数字分别为 $aNum 和 $anotherNum !&quot; return $(($aNum+$anotherNum))&#125;funWithReturnecho &quot;输入的两个数字之和为 $? !&quot; 输出类似下面： 1234567这个函数会对输入的两个数字进行相加运算...输入第一个数字: 1输入第二个数字: 2两个数字分别为 1 和 2 !输入的两个数字之和为 3 ! 函数返回值在调用该函数后通过 $? 来获得。 注意：所有函数在使用前必须定义。这意味着必须将函数放在脚本开始部分，直至shell解释器首次发现它时，才可以使用。调用函数仅使用其函数名即可。 函数参数在Shell中，调用函数时可以向其传递参数。在函数体内部，通过 $n 的形式来获取参数的值，例如，$1表示第一个参数，$2表示第二个参数… 带参数的函数示例： 1234567891011121314#!/bin/bash# author:菜鸟教程# url:www.runoob.comfunWithParam()&#123; echo &quot;第一个参数为 $1 !&quot; echo &quot;第二个参数为 $2 !&quot; echo &quot;第十个参数为 $10 !&quot; echo &quot;第十个参数为 $&#123;10&#125; !&quot; echo &quot;第十一个参数为 $&#123;11&#125; !&quot; echo &quot;参数总数有 $# 个!&quot; echo &quot;作为一个字符串输出所有参数 $* !&quot;&#125;funWithParam 1 2 3 4 5 6 7 8 9 34 73 输出结果： 1234567第一个参数为 1 !第二个参数为 2 !第十个参数为 10 !第十个参数为 34 !第十一个参数为 73 !参数总数有 11 个!作为一个字符串输出所有参数 1 2 3 4 5 6 7 8 9 34 73 ! 注意，$10 不能获取第十个参数，获取第十个参数需要${10}。当n&gt;=10时，需要使用${n}来获取参数。 另外，还有几个特殊字符用来处理参数： 参数处理 说明 $# 传递到脚本或函数的参数个数 $* 以一个单字符串显示所有向脚本传递的参数 $$ 脚本运行的当前进程ID号 $! 后台运行的最后一个进程的ID号 $@ 与$*相同，但是使用时加引号，并在引号中返回每个参数。 $- 显示Shell使用的当前选项，与set命令功能相同。 $? 显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。]]></content>
      <categories>
        <category>shell</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python zipfile module]]></title>
    <url>%2Fpython%2Fmodule%2Fck9bgz83u00dyqov79knnw4zs.html</url>
    <content type="text"><![CDATA[简介zipfile是python里用来做zip格式编码的压缩和解压缩的 zipfile里有两个非常重要的class, 分别是ZipFile和ZipInfo, 在绝大多数的情况下，我们只需要使用这两个class就ok了 ZipFile是主要的类，用来创建和读取zip文件 ZipInfo是存储的zip文件的每个文件的信息的 用法模块定义了以下内容： exception zipfile.BadZipFile为损坏的 ZIP 文件抛出的错误。 exception zipfile.BadZipfileBadZipFile的别名，与旧版本 Python 保持兼容性，3.2 版后已移除.。 exception zipfile.LargeZipFile当 ZIP 文件需要 ZIP64 功能但是未启用时会抛出此错误。 class zipfile.ZipFile用于读写 ZIP 文件的类。 1234567891011121314class zipfile.ZipFile(file, mode=&apos;r&apos;, compression=ZIP_STORED, allowZip64=True, compresslevel=None) 作用：打开一个 ZIP 文件 形参： file： 一个指向文件的路径（字符串），一个类文件对象或者一个 path-like object mode： &apos;r&apos; 读取一个存在的文件； &apos;w&apos; 来截断并写入新的文件； &apos;a&apos; 来添加到一个存在的文件，如果 mode 为 &apos;a&apos; 且 file 为已存在的文件，则格外的文件将被加入，如果 mode 为 &apos;a&apos; 并且文件不存在， 则会新建。； &apos;x&apos; 来仅新建并写入新的文件。如果 mode 为 &apos;x&apos; 并且 file 指向已经存在的文件，则抛出FileExistsError； 如果 mode 为 &apos;r&apos; 或 &apos;a&apos;， 则文件应当可定位。 compression：默认ZIP_STORED，可选 ZIP_STORED, ZIP_DEFLATED, ZIP_BZIP2 or ZIP_LZMA; allowZip64： 默认True，如果allowZip64为真，则zipfile将在zipfile大于4 GiB时创建使用ZIP64扩展名的ZIP文件。如果是false，则当ZIP文件需要ZIP64扩展名时将引发异常； compresslevel： 控制写入归档文件时使用的压缩级别。若使用ZIP_STORED或ZIP_LZMA没有效果。当使用ZIP_DEFLATED时可选0到9。使用ZIP_BZIP2时可选1到9。 ZipFile.namelist()Return a list of archive members by name. 1234567import zipfilewith zipfile.ZipFile(&apos;D:\\Github\\test_comprese.zip&apos;) as my_zip: name_list = my_zip.namelist()&gt;&gt;&gt; name_list[&apos;test_comprese/&apos;, &apos;test_comprese/csv/&apos;, &apos;test_comprese/csv/iris.csv&apos;, &apos;test_comprese/tips.csv&apos;] ZipFile.infolist()返回包含每个存档成员的ZipInfo对象的列表。对象的顺序与它们在磁盘上实际ZIP文件相同。 12345678910import zipfilewith zipfile.ZipFile(&apos;D:\\Github\\test_comprese.zip&apos;) as my_zip: file_info_list = my_zip.infolist()&gt;&gt;&gt; file_info_list[&lt;ZipInfo filename=&apos;test_comprese/&apos; external_attr=0x10&gt;, &lt;ZipInfo filename=&apos;test_comprese/csv/&apos; external_attr=0x10&gt;, &lt;ZipInfo filename=&apos;test_comprese/csv/iris.csv&apos; compress_type=deflate external_attr=0x20 file_size=4600 compress_size=862&gt;, &lt;ZipInfo filename=&apos;test_comprese/tips.csv&apos; compress_type=deflate external_attr=0x20 file_size=7943 compress_size=1695&gt;] ZipFile.getinfo(name)返回关于name信息的ZipInfo对象。若name不在该zip文件中，引发 KeyError。 1234567891011121314151617import zipfilewith zipfile.ZipFile(&apos;D:\\Github\\test_comprese.zip&apos;) as my_zip: file_info = my_zip.getinfo(&apos;test_comprese/&apos;)&gt;&gt;&gt; file_info&lt;ZipInfo filename=&apos;test_comprese/&apos; external_attr=0x10&gt;&gt;&gt;&gt; file_info.is_dir()True&gt;&gt;&gt; file_info.filename&apos;test_comprese/&apos;&gt;&gt;&gt; file_info.date_time(2019, 12, 29, 14, 15, 16)注： file_info 可用方法参考目录 class zipfile.ZipInfo ZipFile.open(name, mode=’r’, pwd=None, *, force_zip64=False)Access a member of the archive as a binary file-like object. name can be either the name of a file within the archive or a ZipInfo object. mode must be ‘r’ (the default) or ‘w’. With mode ‘r’ the file-like object (ZipExtFile) is read-only and provides the following methods: read(), readline(), readlines(), seek(), tell(), iter(), next(). These objects can operate independently of the ZipFile. With mode=’w’, a writable file handle is returned, which supports the write() method. While a writable file handle is open, attempting to read or write other files in the ZIP file will raise a ValueError. pwd is the password used to decrypt encrypted ZIP files. force_zip64, when writing a file, if the file size is not known in advance but may exceed 2 GiB, pass force_zip64=True to ensure that the header format is capable of supporting large files. If the file size is known in advance, construct a ZipInfo object with file_size set, and use that as the name parameter. 123with ZipFile(&apos;D:\\Github\\test_comprese.zip&apos;) as myzip: with myzip.open(&apos;test_comprese/csv/iris.csv&apos;) as myfile: print(myfile.read()) ZipFile.extract(member, path=None, pwd=None)Extract a member from the archive to the current working directory; member must be its full name or a ZipInfo object. Its file information is extracted as accurately as possible. path specifies a different directory to extract to. pwd is the password used for encrypted files. Returns the normalized path created (a directory or new file). 12with zipfile.ZipFile(&apos;D:\\Github\\test_comprese.zip&apos;) as my_zip: my_zip.extract(&apos;test_comprese/csv/iris.csv&apos;, &quot;D:\\my_dir&quot;) ZipFile.extractall(path=None, members=None, pwd=None)Extract all members from the archive to the current working directory. path specifies a different directory to extract to. members is optional and must be a subset of the list returned by namelist(). pwd is the password used for encrypted files. 12with zipfile.ZipFile(&apos;D:\\Github\\test_comprese.zip&apos;) as my_zip: my_zip.extractall(&quot;D:\\my_dir&quot;) ZipFile.printdir()Print a table of contents for the archive to sys.stdout. 123456789with zipfile.ZipFile(&apos;D:\\Github\\test_comprese.zip&apos;) as my_zip: my_zip.printdir()&gt;&gt;&gt;File Name Modified Sizetest_comprese/ 2019-12-29 14:15:16 0test_comprese/csv/ 2019-12-29 14:15:16 0test_comprese/csv/iris.csv 2018-07-01 23:41:02 4600test_comprese/tips.csv 2018-07-01 23:41:02 7943 ZipFile.setpassword(pwd)Set pwd as default password to extract encrypted files. ZipFile.read(name, pwd=None)Return the bytes of the file name in the archive. name is the name of the file in the archive, or a ZipInfo object. The archive must be open for read or append. pwd is the password used for encrypted files and, if specified, it will override the default password set with setpassword(). Calling read() on a ZipFile that uses a compression method other than ZIP_STORED, ZIP_DEFLATED, ZIP_BZIP2 or ZIP_LZMA will raise a NotImplementedError. An error will also be raised if the corresponding compression module is not available. 12with zipfile.ZipFile(&apos;D:\\Github\\test_comprese.zip&apos;) as my_zip: content = my_zip.read(&apos;test_comprese/csv/iris.csv&apos;) ZipFile.write(filename, arcname=None, compress_type=None, compresslevel=None)Write the file named filename to the archive, giving it the archive name arcname (by default, this will be the same as filename, but without a drive letter and with leading path separators removed). If given, compress_type overrides the value given for the compression parameter to the constructor for the new entry. Similarly, compresslevel will override the constructor if given. The archive must be open with mode ‘w’, ‘x’ or ‘a’. ZipFile.writestr(zinfo_or_arcname, data, compress_type=None, compresslevel=None)Write a file into the archive. The contents is data, which may be either a str or a bytes instance; if it is a str, it is encoded as UTF-8 first. zinfo_or_arcname is either the file name it will be given in the archive, or a ZipInfo instance. If it’s an instance, at least the filename, date, and time must be given. If it’s a name, the date and time is set to the current date and time. The archive must be opened with mode ‘w’, ‘x’ or ‘a’. If given, compress_type overrides the value given for the compression parameter to the constructor for the new entry, or in the zinfo_or_arcname (if that is a ZipInfo instance). Similarly, compresslevel will override the constructor if given. ZipFile.testzip()Read all the files in the archive and check their CRC’s and file headers. Return the name of the first bad file, or else return None. ZipFile.filenameName of the ZIP file. ZipFile.debugThe level of debug output to use. This may be set from 0 (the default, no output) to 3 (the most output). Debugging information is written to sys.stdout. ZipFile.commentThe comment associated with the ZIP file as a bytes object. If assigning a comment to a ZipFile instance created with mode ‘w’, ‘x’ or ‘a’, it should be no longer than 65535 bytes. Comments longer than this will be truncated. ZipFile.close()class zipfile.PyZipFile用于创建包含 Python 库的 ZIP 归档的类。 class zipfile.ZipInfo1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class zipfile.ZipInfo(filename='NoName', date_time=(1980, 1, 1, 0, 0, 0))ZipInfo.is_dir() Return True if this archive member is a directory. This uses the entry's name: directories should always end with /.ZipInfo.filename Name of the file in the archive.ZipInfo.date_time The time and date of the last modification to the archive member.ZipInfo.compress_type Type of compression for the archive member. ZipInfo.comment Comment for the individual archive member as a bytes object. ZipInfo.extra Expansion field data. The PKZIP Application Note contains some comments on the internal structure of the data contained in this bytes object. ZipInfo.create_system System which created ZIP archive. ZipInfo.create_version PKZIP version which created ZIP archive. ZipInfo.extract_version PKZIP version needed to extract archive. ZipInfo.flag_bits ZIP flag bits.ZipInfo.volume Volume number of file header.ZipInfo.internal_attr Internal attributes.ZipInfo.external_attr External file attributes.ZipInfo.header_offset Byte offset to the file header.ZipInfo.CRC CRC-32 of the uncompressed file.ZipInfo.compress_size Size of the compressed data.ZipInfo.file_size Size of the uncompressed file. 用于表示档案内一个成员信息的类。 此类的实例会由 ZipFile 对象的 getinfo() 和 infolist() 方法返回。 大多数 zipfile 模块的用户都不必创建它们，只需使用此模块所创建的实例。 filename 应当是档案成员的全名，date_time 应当是包含六个字段的描述最近修改时间的元组；这些字段的描述请参阅 ZipInfo Objects。 zipfile.is_zipfile(filename)根据文件的 Magic Number，如果 filename 是一个有效的 ZIP 文件则返回 True，否则返回 False。 filename 也可能是一个文件或类文件对象。 zipfile.ZIP_STORED未被压缩的归档成员的数字常数。 zipfile.ZIP_DEFLATED常用的 ZIP 压缩方法的数字常数。需要 zlib 模块。 zipfile.ZIP_BZIP2BZIP2 压缩方法的数字常数。需要 bz2 模块。 zipfile.ZIP_LZMALZMA 压缩方法的数字常数。需要 lzma 模块。 命令行界面The zipfilemodule provides a simple command-line interface to interact with ZIP archives. If you want to create a new ZIP archive, specify its name after the -c option and then list the filename(s) that should be included: 1$ python -m zipfile -c monty.zip spam.txt eggs.txt Passing a directory is also acceptable: 1$ python -m zipfile -c monty.zip life-of-brian_1979/ If you want to extract a ZIP archive into the specified directory, use the -e option: 1$ python -m zipfile -e monty.zip target-dir/ For a list of the files in a ZIP archive, use the -l option: 1$ python -m zipfile -l monty.zip 命令行选项 -l`` &lt;zipfile&gt; --list`` &lt;zipfile&gt; List files in a zipfile. -c`` &lt;zipfile&gt; &lt;source1&gt; ... &lt;sourceN&gt; --create`` &lt;zipfile&gt; &lt;source1&gt; ... &lt;sourceN&gt; Create zipfile from source files. -e`` &lt;zipfile&gt; &lt;output_dir&gt; --extract`` &lt;zipfile&gt; &lt;output_dir&gt; Extract zipfile into target directory. -t`` &lt;zipfile&gt; --test`` &lt;zipfile&gt; Test whether the zipfile is valid or not. 参考https://docs.python.org/3.7/library/zipfile.html#zipinfo-objects]]></content>
      <categories>
        <category>python</category>
        <category>module</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>module</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python起一个固定端口]]></title>
    <url>%2Fpython%2Fck9bgz7o60058qov7wrv1xups.html</url>
    <content type="text"><![CDATA[python3python -m http.serve [port] 1234567891011121314151617# python -m http.server --help[root@hadoop01 ~]# python3 -m http.server --helpusage: server.py [-h] [--cgi] [--bind ADDRESS] [--directory DIRECTORY] [port]positional arguments: port Specify alternate port [default: 8000]optional arguments: -h, --help show this help message and exit --cgi Run as CGI Server --bind ADDRESS, -b ADDRESS Specify alternate bind address [default: all interfaces] --directory DIRECTORY, -d DIRECTORY Specify alternative directory [default:current directory] python2python -m SimpleHTTPServer [port]]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>bigdata</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[YAML基本语法]]></title>
    <url>%2Fyaml%2Fck9bgz7oi005kqov7jwabt8h7.html</url>
    <content type="text"><![CDATA[YAML:以数据为中心，比json、xml等更适合做配置文件,yaml必须遵守的三个规则 缩进 yaml使用一个固定的缩进风格表示数据层结构关系，Saltstack需要每个缩进级别由两个空格组成。一定不能使用tab键 冒号 每个冒号后面一定要有一个空格（以冒号结尾不需要空格，表示文件路径的模版可以不需要空格） 短横线 想要表示列表项，使用一个短横杠加一个空格。多个项使用同样的缩进级别作为同一个列表的一部分 基本语法规则： 大小写敏感 使用缩进表示层级关系 缩进时不允许使用Tab键，只允许使用空格。 缩进的空格数目不重要，只要相同层级的元素左侧对齐即可 支持的数据结构 对象：键值对的集合，又称为映射（mapping）/ 哈希（hashes） / 字典（dictionary） 数组：一组按次序排列的值，又称为序列（sequence） / 列表（list） 字面量（数字、字符串、布尔值）：单个的、不可再分的值 具体写法 字面量（数字、字符串、布尔值）k: v :字面量直接写，字符串默认不用加上单引号或者双引号双引号：会转义特殊字符单引号：不会转义字符串里边的特殊字符；特殊字符会作为本身想表示的意思 123name: zhangsanage: 20isBoss: false 数组 多行写法使用- 值来表示数组中的一个元素，需要注意缩进；单行使用[值，值] 来表示一个数组 12345678#多行结构friends: - zhangsan - lisi - wangwu#单行结构friend: [zhangsan,lisi,wangwu] 对象多行写法：key：value的形式，使用多行写法需要注意缩进单行写法：使用{key:value}的形式书写 1234567#多行结构friend: name:zhangsan age:20#单行结构friend: &#123;name:zhangsan,age:20&#125; .properties文件和.yml文件之间的不同 .properties文件中的写法 123456789person.last-name=\u674E\u56DBperson.age=12person.birth=2017/12/15person.boss=falseperson.maps.k1=v1person.maps.k2=14person.lists=a,b,cperson.dog.name=dogperson.dog.age=1 .yml文件中的写法 12345678910person： last-name: zhangsan age: 20 birth: 2017/12/15 boss: false maps:&#123;key1:value1,key2:value2&#125; lists:[a,b,c] dog: name: dog age: 1 参考： YAML 语法]]></content>
      <categories>
        <category>yaml</category>
      </categories>
      <tags>
        <tag>yaml</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[minio mc使用]]></title>
    <url>%2Fminio%2Fck9bgz7l6002nqov7995q32ur.html</url>
    <content type="text"><![CDATA[简述MinIO Client (mc)为ls，cat，cp，mirror，diff，find等UNIX命令提供了一种替代方案。它支持文件系统和兼容Amazon S3的云存储服务（AWS Signature v2和v4）。 1234567891011121314151617181920212223242526272829303132333435NAME: mc - MinIO Client for cloud storage and filesystems.USAGE: mc [FLAGS] COMMAND [COMMAND FLAGS | -h] [ARGUMENTS...]COMMANDS:ls 列出文件和文件夹。mb 创建一个存储桶或一个文件夹。cat 显示文件和对象内容。pipe 将一个STDIN重定向到一个对象或者文件或者STDOUT。share 生成用于共享的URL。cp 拷贝文件和对象。mirror 给存储桶和文件夹做镜像。find 基于参数查找文件。diff 对两个文件夹或者存储桶比较差异。rm 删除文件和对象。events 管理对象通知。watch 监听文件和对象的事件。policy 管理访问策略。session 为cp命令管理保存的会话。config 管理mc配置文件。update 检查软件更新。version 输出版本信息。GLOBAL FLAGS: --autocompletion install auto-completion for your shell --config-dir value, -C value path to configuration folder (default: &quot;/root/.mc&quot;) --quiet, -q disable progress bar display --no-color disable color theme --json enable JSON formatted output --debug enable debug output --insecure disable SSL certificate verification --help, -h show help --version, -v print the version 客户端下载Docker容器稳定版 12Copydocker pull minio/mcdocker run minio/mc ls play 尝鲜版 12Copydocker pull minio/mc:edgedocker run minio/mc:edge ls play 注意: 上述示例默认使用MinIO演示环境做演示，如果想用mc操作其它S3兼容的服务，采用下面的方式来启动容器： 1Copydocker run -it --entrypoint=/bin/sh minio/mc 然后使用mc config命令。 GNU/Linux 平台 CPU架构 URL GNU/Linux 64-bit Intel https://dl.min.io/client/mc/release/linux-amd64/mc 12chmod +x mc./mc --help Microsoft Windows 平台 CPU架构 URL Microsoft Windows 64-bit Intel https://dl.min.io/client/mc/release/windows-amd64/mc.exe 1Copymc.exe --help 添加云存储服务mc将所有的配置信息都存储在~/.mc/config.json文件中 1mc config host add &lt;ALIAS&gt; &lt;YOUR-S3-ENDPOINT&gt; &lt;YOUR-ACCESS-KEY&gt; &lt;YOUR-SECRET-KEY&gt; &lt;API-SIGNATURE&gt; 别名就是给你的云存储服务起了一个短点的外号。S3 endpoint,access key和secret key是你的云存储服务提供的。API签名是可选参数，默认情况下，它被设置为”S3v4”。 示例-MinIO云存储 从MinIO服务获得URL、access key和secret key。 1mc config host add minio http://192.168.1.51 BKIKJAA5BMMU2RHO6IBB V7f1CwQqAcwo80UEIJEjc5gVQUSSx5ohQ9GSrr12 S3v4 配置下载策略1mc policy public minio/base 这个命令的作用是将 server 端的 base 桶设置为开放管理，可以直接通过 url 进行下载。 错误处理执行以下命令： mc config host add minio http://172.17.0.3 AKIAIOSFODNN7EXAMPLE wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY S3v4 产生如下错误： mc: Unable to initialize new config from the provided credentials. Get http://172.17.0.3/probe-bucket-sign-mtwaqfha50la/?location=: dial tcp 172.17.0.3:80: connect: connection refused. 处理方式： 暂无 参考MinIO客户端快速入门指南]]></content>
      <categories>
        <category>minio</category>
      </categories>
      <tags>
        <tag>bigdata</tag>
        <tag>minio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python操作minio]]></title>
    <url>%2Fpython%2Fmodule%2Fck9bgz7qs007lqov70dldobxa.html</url>
    <content type="text"><![CDATA[前言python版本：3.7 minio版本：5.0.5 1234567# 使用pip安装pip install minio# 使用源码安装git clone https://github.com/minio/minio-pycd minio-pypython setup.py install 参考文档： 快速入门：https://docs.min.io/cn/python-client-quickstart-guide.html 完整文档：https://docs.min.io/cn/python-client-api-reference.html API示例：https://github.com/minio/minio-py/tree/master/examples 初始化MinIO Client1234567from minio import Miniofrom minio.error import ResponseErrorminioClient = Minio(endpoint=&apos;play.min.io&apos;, access_key=&apos;Q3AM3UQ867SPQQA43P2F&apos;, secret_key=&apos;zuf+tfteSlswRu7BJ86wekitnifILbZam1KYY3TG&apos;, secure=True) 操作存储桶创建一个存储桶make_bucket(bucket_name, location=’us-east-1’) -&gt; None 1234567891011121314try: minioClient.make_bucket(bucket_name=&quot;mybucket&quot;, location=&quot;us-east-1&quot;)except MaxRetryError as err: print(&quot;connect minio server fail, %s&quot; % err) raiseexcept ResponseError as err: print(&quot;minio server response fail, %s&quot; % err) raiseexcept (BucketAlreadyOwnedByYou, BucketAlreadyExists) as err: passexcept InvalidBucketError as err: print(err)except Exception as err: print(err) 列出所有的存储桶list_buckets() -&gt; list 123456789101112try: buckets = minioClient.list_buckets() for bucket in buckets: print(bucket.name, bucket.creation_date)except MaxRetryError as err: print(&quot;connect minio server fail, %s&quot; % err) raiseexcept ResponseError as err: print(&quot;minio server response fail, %s&quot; % err) raiseexcept Exception as err: print(err) 检查存储桶是否存在bucket_exists(bucket_name) -&gt; bool 12345678910111213try: result = minioClient.bucket_exists(bucket_name=&quot;mybucket&quot;) print(result)except MaxRetryError as err: print(&quot;connect minio server fail, %s&quot; % err) raiseexcept ResponseError as err: print(&quot;minio server response fail, %s&quot; % err) raiseexcept InvalidBucketError as err: print(err)except Exception as err: print(err) 删除存储桶remove_bucket(bucket_name) -&gt; None 1234567891011121314try: minioClient.remove_bucket(bucket_name=&quot;mybucket&quot;)except MaxRetryError as err: print(&quot;connect minio server fail, %s&quot; % err) raiseexcept ResponseError as err: print(&quot;minio server response fail, %s&quot; % err) raiseexcept InvalidBucketError as err: print(err)except NoSuchBucket as err: print(err)except Exception as err: print(err) 列出存储桶中所有对象list_objects(bucket_name, prefix=None, recursive=False) -&gt; Iterator 12345678910111213141516try: objects = minioClient.list_objects(&quot;mybucket&quot;) for obj in objects: print(obj.bucket_name, obj.object_name.encode(&apos;utf-8&apos;), obj.is_dir, obj.size, obj.etag, obj.last_modified, obj.content_type, obj.metadata)except MaxRetryError as err: print(&quot;connect minio server fail, %s&quot; % err) raiseexcept ResponseError as err: print(&quot;minio server response fail, %s&quot; % err) raiseexcept InvalidBucketError as err: print(err)except Exception as err: print(err) 列出存储桶中未完整上传的对象list_incomplete_uploads(bucket_name, prefix, recursive=False) -&gt; Iterator 1234567891011121314151617try: # List all object paths in bucket that begin with my-prefixname. uploads = minioClient.list_incomplete_uploads(&apos;mybucket&apos;, prefix=&apos;my-prefixname&apos;, recursive=True) for obj in uploads: print(obj.bucket_name, obj.object_name, obj.upload_id, obj.size)except MaxRetryError as err: print(&quot;connect minio server fail, %s&quot; % err) raiseexcept ResponseError as err: print(&quot;minio server response fail, %s&quot; % err) raiseexcept InvalidBucketError as err: print(err)except Exception as err: print(err) 获取存储桶的当前策略get_bucket_policy(bucket_name, prefix) -&gt; Policy枚举 1234# Get current policy of all object paths in bucket that begin with my-prefixname.policy = minioClient.get_bucket_policy(&apos;mybucket&apos;, &apos;my-prefixname&apos;)print(policy) 给指定的存储桶设置存储桶策略set_bucket_policy(bucket_name, prefix, policy) -&gt; Policy枚举 1234# Set policy Policy.READ_ONLY to all object paths in bucket that begin with my-prefixname.minioClient.set_bucket_policy(&apos;mybucket&apos;, &apos;my-prefixname&apos;, Policy.READ_ONLY) 获取存储桶上的通知配置get_bucket_notification(bucket_name) -&gt; dict 1234# Get the notifications configuration for a bucket.notification = minioClient.get_bucket_notification(&apos;mybucket&apos;)# If no notification is present on the bucket:# notification == &#123;&#125; 给存储桶设置通知配置set_bucket_notification(bucket_name, notification) -&gt; 删除存储桶上配置的所有通知remove_all_bucket_notification(bucket_name) 监听存储桶上的通知，可以额外提供前缀、后缀和时间类型来进行过滤listen_bucket_notification(bucket_name, prefix, suffix, events) 12345678# Put a file with default content-type.events = minioClient.listen_bucket_notification(&apos;my-bucket&apos;, &apos;my-prefix/&apos;, &apos;.my-suffix&apos;, [&apos;s3:ObjectCreated:*&apos;, &apos;s3:ObjectRemoved:*&apos;, &apos;s3:ObjectAccessed:*&apos;])for event in events: print event 操作对象下载一个对象get_object(bucket_name, object_name, request_headers=None) 12345678# Get a full object.try: data = minioClient.get_object(&apos;mybucket&apos;, &apos;myobject&apos;) with open(&apos;my-testfile&apos;, &apos;wb&apos;) as file_data: for d in data.stream(32*1024): file_data.write(d)except ResponseError as err: print(err) 下载一个对象的指定区间的字节数组get_partial_object(bucket_name, object_name, offset=0, length=0, request_headers=None) 12345678# Offset the download by 2 bytes and retrieve a total of 4 bytes.try: data = minioClient.get_partial_object(&apos;mybucket&apos;, &apos;myobject&apos;, 2, 4) with open(&apos;my-testfile&apos;, &apos;wb&apos;) as file_data: for d in data: file_data.write(d)except ResponseError as err: print(err) 下载并将文件保存到本地get_object(bucket_name, object_name, file_path, request_headers=None) 12345# Get a full object and prints the original object stat information.try: print(minioClient.fget_object(&apos;mybucket&apos;, &apos;myobject&apos;, &apos;/tmp/myobject&apos;))except ResponseError as err: print(err) 拷贝对象存储服务上的源对象到一个新对象copy_object(bucket_name, object_name, object_source, copy_conditions=None, metadata=None) 1234567891011121314151617181920212223242526272829import timefrom datetime import datetimefrom minio import CopyConditionscopy_conditions = CopyConditions()# Set modified condition, copy object modified since 2014 April.t = (2014, 4, 0, 0, 0, 0, 0, 0, 0)mod_since = datetime.utcfromtimestamp(time.mktime(t))copy_conditions.set_modified_since(mod_since)# Set unmodified condition, copy object unmodified since 2014 April.copy_conditions.set_unmodified_since(mod_since)# Set matching ETag condition, copy object which matches the following ETag.copy_conditions.set_match_etag(&quot;31624deb84149d2f8ef9c385918b653a&quot;)# Set matching ETag except condition, copy object which does not match the following ETag.copy_conditions.set_match_etag_except(&quot;31624deb84149d2f8ef9c385918b653a&quot;)# Set metadatametadata = &#123;&quot;test-key&quot;: &quot;test-data&quot;&#125;try: copy_result = minioClient.copy_object(&quot;mybucket&quot;, &quot;myobject&quot;, &quot;/my-sourcebucketname/my-sourceobjectname&quot;, copy_conditions,metadata=metadata) print(copy_result)except ResponseError as err: print(err) 添加一个新的对象到对象存储服务put_object(bucket_name, object_name, data, length, content_type=’application/octet-stream’, metadata=None) 123456789101112131415161718import os# Put a file with default content-type, upon success prints the etag identifier computed by server.try: with open(&apos;my-testfile&apos;, &apos;rb&apos;) as file_data: file_stat = os.stat(&apos;my-testfile&apos;) print(minioClient.put_object(&apos;mybucket&apos;, &apos;myobject&apos;, file_data, file_stat.st_size))except ResponseError as err: print(err)# Put a file with &apos;application/csv&apos;.try: with open(&apos;my-testfile.csv&apos;, &apos;rb&apos;) as file_data: file_stat = os.stat(&apos;my-testfile.csv&apos;) minioClient.put_object(&apos;mybucket&apos;, &apos;myobject.csv&apos;, file_data, file_stat.st_size, content_type=&apos;application/csv&apos;)except ResponseError as err: print(err) 通过文件上传到对象中fput_object(bucket_name, object_name, file_path, content_type=’application/octet-stream’, metadata=None) 1234567891011121314# Put an object &apos;myobject&apos; with contents from &apos;/tmp/otherobject&apos;, upon success prints the etag identifier computed by server.try: print(minioClient.fput_object(&apos;mybucket&apos;, &apos;myobject&apos;, &apos;/tmp/otherobject&apos;))except ResponseError as err: print(err)# Put on object &apos;myobject.csv&apos; with contents from# &apos;/tmp/otherobject.csv&apos; as &apos;application/csv&apos;.try: print(minioClient.fput_object(&apos;mybucket&apos;, &apos;myobject.csv&apos;, &apos;/tmp/otherobject.csv&apos;, content_type=&apos;application/csv&apos;))except ResponseError as err: print(err) 获取对象的元数据stat_object(bucket_name, object_name) 12345# Fetch stats on your object.try: print(minioClient.stat_object(&apos;mybucket&apos;, &apos;myobject&apos;))except ResponseError as err: print(err) 删除一个对象remove_object(bucket_name, object_name) 12345# Remove an object.try: minioClient.remove_object(&apos;mybucket&apos;, &apos;myobject&apos;)except ResponseError as err: print(err) 删除存储桶中的多个对象remove_objects(bucket_name, objects_iter) 123456789# Remove multiple objects in a single library call.try: objects_to_delete = [&apos;myobject-1&apos;, &apos;myobject-2&apos;, &apos;myobject-3&apos;] # force evaluation of the remove_objects() call by iterating over # the returned value. for del_err in minioClient.remove_objects(&apos;mybucket&apos;, objects_to_delete): print(&quot;Deletion Error: &#123;&#125;&quot;.format(del_err))except ResponseError as err: print(err) 删除一个未完整上传的对象remove_incomplete_upload(bucket_name, object_name) 12345# Remove an partially uploaded object.try: minioClient.remove_incomplete_upload(&apos;mybucket&apos;, &apos;myobject&apos;)except ResponseError as err: print(err) Presigned操作生成一个用于HTTP GET操作的presigned URLpresigned_get_object(bucket_name, object_name, expiry=timedelta(days=7)) 12345678from datetime import timedelta# presigned get object URL for object name, expires in 2 days.try: print(minioClient.presigned_get_object(&apos;mybucket&apos;, &apos;myobject&apos;, expires=timedelta(days=2)))# Response error is still possible since internally presigned does get bucket location.except ResponseError as err: print(err) 生成一个用于HTTP PUT操作的presigned URLpresigned_put_object(bucket_name, object_name, expires=timedelta(days=7)) 1234567891011from datetime import timedelta# presigned Put object URL for an object name, expires in 3 days.try: print(minioClient.presigned_put_object(&apos;mybucket&apos;, &apos;myobject&apos;, expires=timedelta(days=3)))# Response error is still possible since internally presigned does get# bucket location.except ResponseError as err: print(err) 允许给POST操作的presigned URL设置策略条件presigned_post_policy(PostPolicy)]]></content>
      <categories>
        <category>python</category>
        <category>module</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>bigdata</tag>
        <tag>minio</tag>
        <tag>module</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cassandra相关操作]]></title>
    <url>%2Fdatabase%2Fck9bgz7kx002fqov71b87gpuz.html</url>
    <content type="text"><![CDATA[用法示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687# -*- coding: utf-8 -*-from cassandra.auth import PlainTextProviderfrom cassandra.cluster import Clusterfrom cassandra.cqlengine import columns, connectionfrom cassandra.cqlengine.models import Modelfrom cassandra.query import dict_factoryhosts = [&quot;192.168.10.10&quot;, &quot;192.168.10.11&quot;]username = &quot;username&quot;password = &quot;password&quot;port = 9042keyspace = &quot;mykeyspace&quot;auth_provider = PlainTextProvider(username=username, password=password)cluser_conf_dict = dict(port=port, auth_provider=auth_provider)connection.setup(hosts, keyspace, **cluser_conf_dict)cluster = connection.get_cluster()session = connection.get_session()session.set_keyspace(keyspace)session.default_fetch_size = 10000session.default_timeout = 120class ExapleModel(Models): partition_1 = columns.Text(partition_key=True, primary_key=True) partition_2 = columns.Text(partition_key=True, primary_key=True) primary_1 = columns.Text(primary_key=True) primary_2 = columns.Text(primary_key=True) str_type = columns.Text() boolean_type = columns.Boolean() int_type = columns.Integer() bigint_type = columns.BigInt() float_type = columns.Float() datatime_type = columns.DataTime() list_str_type = columns.List(columns.Text) set_str_type = columns.Set(columns.Text) set_int_type = columns.Set(columns.Integer) set_bigint_type = columns.Set(columns.Bigint) map_type = columns.Map(columns.Text, columns.Float)# create db statementCREATE TABLE mykeyspace.examplemodel ( partition_1 text, partition_2 text, primary_1 text, primary_2 text, str_type text, boolean_type boolea, int_type int, bigint_type bigint, float_type float, datatime_type timestamp, list_str_type list&lt;text&gt;, set_str_type set&lt;text&gt;, set_int_type set&lt;int&gt;, set_bigint_type set&lt;bigint&gt;, map_type map&lt;text, float&gt;, PRIMARY KEY((partition_1, partition_2), primary_1, primary_2)) WITH CLUSTERING ORDER BY (primary_1 ASC, primary_2 ASC) AND gc_grace_seconds = 0;def connect_db(hosts, username, password, port, keyspace, timeout=120, default_size=10000): auth_provider = PlainTextProvider(username=username, password=password) cluster = Cluster(contact_points=hosts, port=port, auth_provider=auth_provider) session = cluster.connect(keyspace) # set session session.default_fetch_size = default_size session.default_timeout = timeout session.row_factory = dict_factory return cluster, sessiondef close_db(cluster, session): session.shutdown() cluster.shutdown()def exec_sql(sql, **kwargs): try: cluster, session =connect_db(hosts, username, password, port, keyspace) future = session.execute(sql, kwargs) close_db(cluster, session) except Execption as e: close_db(cluster, session) future = [] return future]]></content>
      <categories>
        <category>database</category>
      </categories>
      <tags>
        <tag>database</tag>
        <tag>cassandra</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pycharm2018.1激活教程]]></title>
    <url>%2Fpython%2Fck9bgz7ao000bqov733k821e2.html</url>
    <content type="text"><![CDATA[补丁下载下载补丁：JetbrainsCrack-release-enc.jar 配置文件 下载的补丁保存到PyCharm安装目录下的\bin目录下 1E:\PyCharm 2018.1.1\bin\JetbrainsCrack-release-enc.jar 修改配置文件 123# 在PyCharm安装目录下的\bin目录中找到pycharm.exe.vmoptions和pycharm64.exe.vmoptions, 添加：-javaagent:E:\PyCharm 2018.1.1\bin\JetbrainsCrack-release-enc.jar 启动pycharm,输入激活码, Help-&gt;Register-&gt;Activation code 12345678910111213141516171819202122232425// An highlighted blockThisCrackLicenseId-&#123;“licenseId”:”11011”,“licenseeName”:”Wechat”,“assigneeName”:”IT--Pig”,“assigneeEmail”:”1113449881@qq.com”,“licenseRestriction”:””,“checkConcurrentUse”:false,“products”:[&#123;“code”:”II”,”paidUpTo”:”2099-12-31”&#125;,&#123;“code”:”DM”,”paidUpTo”:”2099-12-31”&#125;,&#123;“code”:”AC”,”paidUpTo”:”2099-12-31”&#125;,&#123;“code”:”RS0”,”paidUpTo”:”2099-12-31”&#125;,&#123;“code”:”WS”,”paidUpTo”:”2099-12-31”&#125;,&#123;“code”:”DPN”,”paidUpTo”:”2099-12-31”&#125;,&#123;“code”:”RC”,”paidUpTo”:”2099-12-31”&#125;,&#123;“code”:”PS”,”paidUpTo”:”2099-12-31”&#125;,&#123;“code”:”DC”,”paidUpTo”:”2099-12-31”&#125;,&#123;“code”:”RM”,”paidUpTo”:”2099-12-31”&#125;,&#123;“code”:”CL”,”paidUpTo”:”2099-12-31”&#125;,&#123;“code”:”PC”,”paidUpTo”:”2099-12-31”&#125;],“hash”:”2911276/0”,“gracePeriodDays”:7,“autoProlongated”:false&#125; 查看有效期 1Help-&gt;About]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>pycharm</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spark常见错误处理]]></title>
    <url>%2Fbigdata%2Fck9bgz7la002rqov75bcz0uac.html</url>
    <content type="text"><![CDATA[参考：spark常见错误汇总]]></content>
      <categories>
        <category>bigdata</category>
      </categories>
      <tags>
        <tag>bigdata</tag>
        <tag>spark</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spark web信息获取]]></title>
    <url>%2Fbigdata%2Fck9bgz7ll0032qov71ns4r46v.html</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576# -*- coding: utf-8 -*-import reimport requestsdef _get_requests(url): response = requests.get(url) content = &quot;&quot; if response.status_code == 200: content = response.content.decode() return contentdef _get_spark_common(st): s = re.findall(r&apos;&lt;ul class=&quot;unstyled&quot;.*&lt;/ul&gt;&apos;, body, re.S)[0] s = re.sub(r&apos;\s&#123;2,&#125;|&lt;a.*?&gt;|&lt;/a&gt;&apos;, &apos; &apos;, s) print_format = &quot;&#123;:15&#125;&#123;&#125;&quot;.format print(&quot;********************************&quot;) info = re.findall(r&apos;&lt;strong&gt;(.*?)&lt;/strong&gt;\s*(.*?)\s*&lt;/li&gt;&apos;, s) for k, v in info: print(print_format(k, v)) else: print(&quot;\n&quot;) def _get_spark_works(st): s = re.findall(r&apos;&lt;div class=&quot;aggregated-workers collapsible-table&quot;.*?&lt;/div&gt;&apos;, body, re.S)[0] s = re.sub(r&apos;&lt;a.*&gt;|&lt;/a&gt;&apos;, &quot;&quot;, s) s = re.sub(r&apos;\s+&apos;, &quot; &quot;, s) head = re.findall(r&apos;&lt;th .*?&gt;(.*?)&lt;/th&gt;&apos;, s) work_info = [re.findall(r&apos;&lt;td.*?&gt;\s*(.*?)\s*&lt;/td&gt;&apos;, x) for x in re.findall(r&apos;&lt;tr&gt;.*?&lt;/tr&gt;&apos;, s)] work_info.insert(0, head) print_format = &quot;&#123;:&lt;46&#125;&#123;:25&#125;&#123;:10&#125;&#123;:15&#125;&#123;&#125;&quot;.format print(&quot;****************Workers (%s)****************&quot; % (len(work_info) - 1)) for row in work_info: print(print_format(*row)) else: print(&quot;\n&quot;) def _get_spark_running_applications(st): s = re.findall(r&apos;&lt;div class=&quot;aggregated-activeApps.*?&lt;/div&gt;&apos;, body, re.S)[0] s = re.sub(r&apos;\s+&apos;, &quot; &quot;, s) s = re.sub(r&apos;&lt;a.*?&gt;|&lt;/a&gt;|&lt;form.*?&gt;.*&lt;/form&gt;&apos;, &quot;&quot;, s, re.S) head = re.findall(r&apos;&lt;th .*?&gt;(.*?)&lt;/th&gt;&apos;, s) run_work_info = [re.findall(r&apos;&lt;td.*?&gt;\s*(.*?)\s*&lt;/td&gt;&apos;, x) for x in re.findall(r&apos;&lt;tr&gt;.*?&lt;/tr&gt;&apos;, s)] run_work_info.insert(0, head) print_format = &quot;&#123;:&lt;28&#125;&#123;:20&#125;&#123;:10&#125;&#123;:25&#125;&#123;:25&#125;&#123;:10&#125;&#123;:13&#125;&#123;&#125;&quot;.format print(&quot;****************Running Applications (%s)***************&quot; % (len(run_work_info) - 1)) for row in run_work_info: print(print_format(*row)) else: print(&quot;\n&quot;)def _get_spark_completed_applications(st): s = re.findall(r&apos;&lt;div class=&quot;aggregated-completedApps.*?&lt;/div&gt;&apos;, body, re.S)[0] s = re.sub(r&apos;\s+&apos;, &quot; &quot;, s) s = re.sub(r&apos;&lt;a.*?&gt;|&lt;/a&gt;|&lt;form.*?&gt;.*&lt;/form&gt;&apos;, &quot;&quot;, s, re.S) head = re.findall(r&apos;&lt;th .*?&gt;(.*?)&lt;/th&gt;&apos;, s) run_work_info = [re.findall(r&apos;&lt;td.*?&gt;\s*(.*?)\s*&lt;/td&gt;&apos;, x) for x in re.findall(r&apos;&lt;tr&gt;.*?&lt;/tr&gt;&apos;, s)] run_work_info.insert(0, head) print_format = &quot;&#123;:&lt;28&#125;&#123;:20&#125;&#123;:10&#125;&#123;:25&#125;&#123;:25&#125;&#123;:10&#125;&#123;:13&#125;&#123;&#125;&quot;.format print(&quot;****************Completed Applications (%s)****************&quot; % (len(run_work_info) - 1)) for row in run_work_info: print(print_format(*row)) else: print(&quot;\n&quot;)if __name__ == &quot;__main__&quot;: url = &quot;http://192.168.100.10:8080/&quot; body = _get_requests(url) spark_common_info = _get_spark_common(body) _get_spark_works(body) _get_spark_running_applications(body) _get_spark_completed_applications(body)]]></content>
      <categories>
        <category>bigdata</category>
      </categories>
      <tags>
        <tag>bigdata</tag>
        <tag>spark</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spark standalone集群搭建]]></title>
    <url>%2Fbigdata%2Fck9bgz7ld002uqov7fp4fr2vl.html</url>
    <content type="text"><![CDATA[下载软件java JDK-1.8 spark 安装软件及配置安装jdk123456789101112131415# 解压 jdk-8u171-linux-x64.tar.gztar xf jdk-8u171-linux-x64.tar.gz /opt# 配置环境变量vim /etc/profileexport JAVA_HOME=/opt/jdk-8u171export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarexport PATH=$JAVA_HOME/bin:$PATH# 激活profilesource /etc/profile# 检查jdk版本,看是否安装成功java -version 安装spark12345678# 解压spark-2.4.3-bin-hadoop2.7.tgztar xf spark-2.4.3-bin-hadoop2.7.tgz /opt# 配置环境变量vim /etc/profileexport SPARK_HOME=/opt/spark-2.4.3-bin-hadoop2.7export PATH=$PATH:$SPARK_HOME/bin 配置spark123456789101112131415161718# cd $&#123;SPARK_HOME&#125;/confcp spark-env.sh.template spark-env.shslaves.template slaves# 配置conf/spark_env.shvim spark_env.shexport JAVA_HOME=/opt/jdk-8u171export SPARK_MASTER_HOST=hostnameexport SPARK_MASTER_IP=hostnameexport SPARK_MASTER_PORT=7077# 配置slavesvim slaveshostname1hostname2... spark_env.sh配置参数：http://spark.apache.org/docs/latest/spark-standalone.html#cluster-launch-scripts 配置hosts1234567vim /etc/hostsip1 hostname1ip2 hostname2...注：ip用本机物理ip，不用配置静态或浮动ip 配置主机间免密登陆12ssh-keygen -t rsa # 一路Enterssh-copy-id root@hostname 启动spark集群一般来说,Standalone模式的Spark集群的启动有以下的几种方式： 1. master,slave一起启动： 12cd $SPARK_HOME./sbin/start-all.sh 2. master,slave节点分开启动 12345cd $SPARK_HOME# 先启动 master,在启动slave./sbin/start-master.sh -h 192.168.100.10./sbin/start-slave.sh 192.168.100.10:7077 停止spark集群12cd $SPARK_HOME./sbin/stop-all.sh Spark配置参数详解Spark提供三个位置用来配置系统： Spark属性：控制大部分的应用程序参数，可以用SparkConf对象或者Java系统属性设置 环境变量：可以通过每个节点的conf/spark-env.sh脚本设置。例如IP地址、端口等信息 日志配置：可以通过log4j.properties配置 参考：https://www.cnblogs.com/yangcx666/p/8723826.html Referencehttps://spark.apache.org/docs/latest/configuration.html]]></content>
      <categories>
        <category>bigdata</category>
      </categories>
      <tags>
        <tag>bigdata</tag>
        <tag>spark</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣题库（python解法）]]></title>
    <url>%2FdataStructure%2Fck9bgz7wn008hqov7vy6u7x4u.html</url>
    <content type="text"><![CDATA[1.两数之和链接https://leetcode-cn.com/problems/two-sum/ 问题给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例1234给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 解法分析方法一：暴力法暴力法很简单，遍历每个元素 xx，并查找是否存在一个值与 target - xtarge*t−*x 相等的目标元素。 12345678class Solution: def twoSum(self, nums: List[int], target: int) -&gt; List[int]: hash_dict = &#123;v:i for i, v in enumerate(nums)&#125; for index1, value in enumerate(nums): v = target - value index2 = hash_dict.get(v) if v in hash_dict and index1 != index2: return [index1, index2] 复杂度分析： 时间复杂度：O(n^2)对于每个元素，我们试图通过遍历数组的其余部分来寻找它所对应的目标元素，这将耗费 O(n)O(n) 的时间。因此时间复杂度为 O(n^2)。 空间复杂度：O(1)。 方法二：两遍哈希表为了对运行时间复杂度进行优化，我们需要一种更有效的方法来检查数组中是否存在目标元素。如果存在，我们需要找出它的索引。保持数组中的每个元素与其索引相互对应的最好方法是什么？哈希表。 通过以空间换取速度的方式，我们可以将查找时间从 O(n)降低到 O(1)。哈希表正是为此目的而构建的，它支持以 近似 恒定的时间进行快速查找。我用“近似”来描述，是因为一旦出现冲突，查找用时可能会退化到 O(n)。但只要你仔细地挑选哈希函数，在哈希表中进行查找的用时应当被摊销为 O(1)。 一个简单的实现使用了两次迭代。在第一次迭代中，我们将每个元素的值和它的索引添加到表中。然后，在第二次迭代中，我们将检查每个元素所对应的目标元素（target - nums[i]）是否存在于表中。注意，该目标元素不能是 nums[i] 本身！ 12345678class Solution: def twoSum(self, nums: List[int], target: int) -&gt; List[int]: hash_dict = &#123;v:i for i, v in enumerate(nums)&#125; for index1, value in enumerate(nums): v = target - value index2 = hash_dict.get(v) if v in hash_dict and index1 != index2: return [index1, index2] 复杂度分析： 时间复杂度：O(n)，我们把包含有 n 个元素的列表遍历两次。由于哈希表将查找时间缩短到 O(1) ，所以时间复杂度为 O(n)。 空间复杂度：O(n)，所需的额外空间取决于哈希表中存储的元素数量，该表中存储了 n 个元素。 方法三：一遍哈希表事实证明，我们可以一次完成。在进行迭代并将元素插入到表中的同时，我们还会回过头来检查表中是否已经存在当前元素所对应的目标元素。如果它存在，那我们已经找到了对应解，并立即将其返回. 12345678class Solution: def twoSum(self, nums: List[int], target: int) -&gt; List[int]: hash_dict = &#123;&#125; for index1, value in enumerate(nums): v = target - value if v in hash_dict: return [hash_dict[v], index1] hash_dict[value] = index1 复杂度分析： 时间复杂度：O(n)，我们只遍历了包含有 n 个元素的列表一次。在表中进行的每次查找只花费 O(1)的时间。 空间复杂度：O(n)，所需的额外空间取决于哈希表中存储的元素数量，该表最多需要存储 nn 个元素。 2.两数相加链接https://leetcode-cn.com/problems/add-two-numbers/ 问题给出两个非空的链表用来表示两个非负的整数。其中，它们各自的位数是按照逆序的方式存储的，并且它们的每个节点只能存储 一位 数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例123输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 代码示例：12345678910111213141516171819202122232425# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode: init_value = ListNode(0) tmp = init_value array = 0 while l1 or l2: x, y = l1.val if l1 else 0, l2.val if l2 else 0 sum = x + y + array array = sum // 10 tmp.next = ListNode(sum % 10) tmp = tmp.next if l1 is not None: l1 = l1.next if l2 is not None: l2 = l2.next if array: tmp.next = ListNode(array) return init_value.next 200.岛屿数量链接来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/number-of-islands 问题给定一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。 示例示例 1: 1234567输入:11110110101100000000输出: 1 示例 2: 1234567输入:11000110000010000011输出: 3 代码示例分析：https://leetcode-cn.com/problems/number-of-islands/solution/dao-yu-shu-liang-by-leetcode/ https://leetcode-cn.com/problems/number-of-islands/solution/dfs-bfs-bing-cha-ji-python-dai-ma-java-dai-ma-by-l/ 方法一：深度优先搜索1234567891011121314151617181920212223242526272829from typing import Listclass Solution: def numIslands(self, grid: List[List[str]]) -&gt; int: count = 0 self.m = len(grid) if self.m == 0: return count self.n = len(grid[0]) for row, v1 in enumerate(grid): for column, v2 in enumerate(v1): if v2 == &quot;1&quot;: count += 1 self._dfs(row, column, grid) return count def _dfs(self, row, column, grid): grid[row][column] = &quot;0&quot; for x, y in [(row - 1, column), (row, column + 1), (row + 1, column), (row, column - 1)]: if 0 &lt;= x &lt; self.m and 0&lt;= y &lt; self.n and grid[x][y] == &quot;1&quot;: self._dfs(x, y, grid)if __name__ == &quot;__main__&quot;: lst = [[&quot;1&quot;, &quot;1&quot;, &quot;1&quot;, &quot;1&quot;, &quot;0&quot;], [&quot;1&quot;, &quot;1&quot;, &quot;0&quot;, &quot;1&quot;, &quot;0&quot;], [&quot;1&quot;, &quot;1&quot;, &quot;0&quot;, &quot;0&quot;, &quot;0&quot;], [&quot;0&quot;, &quot;0&quot;, &quot;0&quot;, &quot;0&quot;, &quot;0&quot;]] obj = Solution() count = obj.numIslands(lst) print(count) 1234567891011121314151617181920212223# DFSclass Solution: def numIslands(self, grid: List[List[str]]) -&gt; int: if not grid: return 0 row = len(grid) col = len(grid[0]) cnt = 0 def dfs(i, j): grid[i][j] = &quot;0&quot; for x, y in [[-1, 0], [1, 0], [0, -1], [0, 1]]: tmp_i = i + x tmp_j = j + y if 0 &lt;= tmp_i &lt; row and 0 &lt;= tmp_j &lt; col and grid[tmp_i][tmp_j] == &quot;1&quot;: dfs(tmp_i, tmp_j) for i in range(row): for j in range(col): if grid[i][j] == &quot;1&quot;: dfs(i, j) cnt += 1 return cnt 方法二：广度优先遍历1234567891011121314151617181920212223242526272829# BFSclass Solution: def numIslands(self, grid: List[List[str]]) -&gt; int: from collections import deque if not grid: return 0 row = len(grid) col = len(grid[0]) cnt = 0 def bfs(i, j): queue = deque() queue.appendleft((i, j)) grid[i][j] = &quot;0&quot; while queue: i, j = queue.pop() for x, y in [[-1, 0], [1, 0], [0, -1], [0, 1]]: tmp_i = i + x tmp_j = j + y if 0 &lt;= tmp_i &lt; row and 0 &lt;= tmp_j &lt; col and grid[tmp_i][tmp_j] == &quot;1&quot;: grid[tmp_i][tmp_j] = &quot;0&quot; queue.appendleft((tmp_i, tmp_j)) for i in range(row): for j in range(col): if grid[i][j] == &quot;1&quot;: bfs(i, j) cnt += 1 return cnt 方法三：并查集1234567891011121314151617181920212223242526272829303132class Solution: def numIslands(self, grid: List[List[str]]) -&gt; int: f = &#123;&#125; def find(x): f.setdefault(x, x) if f[x] != x: f[x] = find(f[x]) return f[x] def union(x, y): f[find(x)] = find(y) if not grid: return 0 row = len(grid) col = len(grid[0]) for i in range(row): for j in range(col): if grid[i][j] == &quot;1&quot;: for x, y in [[-1, 0], [0, -1]]: tmp_i = i + x tmp_j = j + y if 0 &lt;= tmp_i &lt; row and 0 &lt;= tmp_j &lt; col and grid[tmp_i][tmp_j] == &quot;1&quot;: union(tmp_i * row + tmp_j, i * row + j) # print(f) res = set() for i in range(row): for j in range(col): if grid[i][j] == &quot;1&quot;: res.add(find((i * row + j))) return len(res) 622.设计循环队列链接来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/design-circular-queue 问题设计你的循环队列实现。 循环队列是一种线性数据结构，其操作表现基于 FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称为“环形缓冲器”。 循环队列的一个好处是我们可以利用这个队列之前用过的空间。在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。但是使用循环队列，我们能使用这些空间去存储新的值。 你的实现应该支持如下操作： MyCircularQueue(k): 构造器，设置队列长度为 k 。 Front: 从队首获取元素。如果队列为空，返回 -1 。 Rear: 获取队尾元素。如果队列为空，返回 -1 。 enQueue(value): 向循环队列插入一个元素。如果成功插入则返回真。 deQueue(): 从循环队列中删除一个元素。如果成功删除则返回真。 isEmpty(): 检查循环队列是否为空。 isFull(): 检查循环队列是否已满。 示例12345678# Your MyCircularQueue object will be instantiated and called as such:# obj = MyCircularQueue(k)# param_1 = obj.enQueue(value)# param_2 = obj.deQueue()# param_3 = obj.Front()# param_4 = obj.Rear()# param_5 = obj.isEmpty()# param_6 = obj.isFull() 代码示例：示例一（数组实现）： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667class MyCircularQueue: def __init__(self, k: int): &quot;&quot;&quot; Initialize your data structure here. Set the size of the queue to be k. &quot;&quot;&quot; self.queue = [0] * k self.head_index = 0 self.count = 0 self.capacity = k def enQueue(self, value: int) -&gt; bool: &quot;&quot;&quot; Insert an element into the circular queue. Return true if the operation is successful. &quot;&quot;&quot; if self.count == self.capacity: return False self.queue[(self.head_index + self.count) % self.capacity] = value self.count += 1 return True def deQueue(self) -&gt; bool: &quot;&quot;&quot; Delete an element from the circular queue. Return true if the operation is successful. &quot;&quot;&quot; if self.count == 0: return False self.head_index = (self.head_index + 1) % self.capacity self.count -= 1 return True def Front(self) -&gt; int: &quot;&quot;&quot; Get the front item from the queue. &quot;&quot;&quot; if self.count == 0: return -1 return self.queue[self.head_index] def Rear(self) -&gt; int: &quot;&quot;&quot; Get the last item from the queue. &quot;&quot;&quot; if self.count == 0: return -1 return self.queue[(self.head_index + self.count - 1) % self.capacity] def isEmpty(self) -&gt; bool: &quot;&quot;&quot; Checks whether the circular queue is empty or not. &quot;&quot;&quot; return self.count == 0 def isFull(self) -&gt; bool: &quot;&quot;&quot; Checks whether the circular queue is full or not. &quot;&quot;&quot; return self.count == self.capacity# Your MyCircularQueue object will be instantiated and called as such:# obj = MyCircularQueue(k)# param_1 = obj.enQueue(value)# param_2 = obj.deQueue()# param_3 = obj.Front()# param_4 = obj.Rear()# param_5 = obj.isEmpty()# param_6 = obj.isFull() 示例二（链表实现）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980class Node: def __init__(self, value, next_node=None): self.value = value self.next_node = next_node class MyCircularQueue: def __init__(self, k: int): &quot;&quot;&quot; Initialize your data structure here. Set the size of the queue to be k. &quot;&quot;&quot; self.head = None self.tail = None self.count = 0 self.capacity = k def enQueue(self, value: int) -&gt; bool: &quot;&quot;&quot; Insert an element into the circular queue. Return true if the operation is successful. &quot;&quot;&quot; if self.count == self.capacity: return False if self.count == 0: self.head = Node(value) self.tail = self.head else: self.tail.next_node = Node(value) self.tail = self.tail.next_node self.count += 1 return True def deQueue(self) -&gt; bool: &quot;&quot;&quot; Delete an element from the circular queue. Return true if the operation is successful. &quot;&quot;&quot; if self.count == 0: return False self.head = self.head.next_node self.count -= 1 return True def Front(self) -&gt; int: &quot;&quot;&quot; Get the front item from the queue. &quot;&quot;&quot; if self.count == 0: return -1 return self.head.value def Rear(self) -&gt; int: &quot;&quot;&quot; Get the last item from the queue. &quot;&quot;&quot; if self.count == 0: return -1 return self.tail.value def isEmpty(self) -&gt; bool: &quot;&quot;&quot; Checks whether the circular queue is empty or not. &quot;&quot;&quot; return self.count == 0 def isFull(self) -&gt; bool: &quot;&quot;&quot; Checks whether the circular queue is full or not. &quot;&quot;&quot; return self.count == self.capacity # Your MyCircularQueue object will be instantiated and called as such:# obj = MyCircularQueue(k)# param_1 = obj.enQueue(value)# param_2 = obj.deQueue()# param_3 = obj.Front()# param_4 = obj.Rear()# param_5 = obj.isEmpty()# param_6 = obj.isFull() 892. 三维形体的表面积链接https://leetcode-cn.com/problems/surface-area-of-3d-shapes/ 问题在 N * N 的网格上，我们放置一些 1 * 1 * 1 的立方体。每个值 v = grid[i][j] 表示 v 个正方体叠放在对应单元格 (i, j) 上。请你返回最终形体的表面积。 提示： 1 &lt;= N &lt;= 500 &lt;= grid[i][j] &lt;= 50 示例示例 1： 12输入：[[2]]输出：10 示例 2： 12输入：[[1,2],[3,4]]输出：34 示例 3： 12输入：[[1,0],[0,2]]输出：16 示例 4： 12输入：[[1,1,1],[1,0,1],[1,1,1]]输出：32 示例 5： 12输入：[[2,2,2],[2,1,2],[2,2,2]]输出：46 解法分析方法：分步累加思路我们单独计算每一个 v = grid[i][j] 所贡献的表面积，再将所有的 v 值相加就能得到最终形体的表面积： 对于顶面和底面的表面积，如果 v &gt; 0，那么顶面和底面各贡献了 1 的表面积，总计 2 的表面积； 对于四个侧面的表面积，只有在相邻位置的高度小于 v 时，对应的那个侧面才会贡献表面积，且贡献的数量为 v - nv，其中 nv 是相邻位置的高度。我们可以将其写成 max(v - nv, 0)。 举一个例子，对于网格 121 56 7 而言，位置 grid[0][1] 的高度为 5：因为 5 &gt; 0，所以贡献了 2 的顶面和底面表面积；该位置的上方和右侧没有单元格，可以看成高度为 0，所以分别贡献了 max(5 - 0, 0) = 5 的表面积；该位置的左侧高度为 1，所以贡献了 max(5 - 1, 0) = 4 的表面积；该位置的下方高度为 7，所以贡献了 max(5 - 7, 0) = 0 的表面积。 因此 grid[0][1] 贡献的表面积总和为 2 + 5 + 5 + 4 + 0 = 16。 算法对于每个 v = grid[r][c] &gt; 0，计算 ans += 2，对于 grid[r][c] 四个方向的每个相邻值 nv 还要加上 max(v - nv, 0)。 复杂度分析 时间复杂度：O(N^2)，其中 N 是 grid 中的行和列的数目。 空间复杂度：O(1)O(1)。 python3代码示例12345678910111213class Solution: def surfaceArea(self, grid: List[List[int]]) -&gt; int: N = len(grid) ans = 0 for r in range(N): for c in range(N): if grid[r][c] &gt; 0: ans += 2 for nr, nc in ((r - 1, c), (r + 1, c), (r, c - 1), (r, c + 1)): nval = grid[nr][nc] if 0 &lt;= nr &lt; N and 0 &lt;= nc &lt; N else 0 ans += max(grid[r][c] - nval, 0) return ans 盘子装苹果问题题目描述 把M个同样的苹果放在N个同样的盘子里，允许有的盘子空着不放，问共有多少种不同的分法？（用K表示）5，1，1和1，5，1 是同一种分法。 输入每个用例包含二个整数M和N。0&lt;=m&lt;=10，1&lt;=n&lt;=10。 样例输入7 3 样例输出8 1234567891011121314151617181920212223242526272829303132# 解题分析：# 设f(m,n) 为m个苹果，n个盘子的放法数目，则先对n作讨论，# 当n&gt;m：必定有n-m个盘子永远空着，去掉它们对摆放苹果方法数目不产生影响。即if(n&gt;m) f(m,n) = f(m,m) # 当n&lt;=m：不同的放法可以分成两类：# 1、有至少一个盘子空着，即相当于f(m,n) = f(m,n-1); # 2、所有盘子都有苹果，相当于可以从每个盘子中拿掉一个苹果，不影响不同放法的数目，即f(m,n) = f(m-n,n).# 而总的放苹果的放法数目等于两者的和，即 f(m,n) =f(m,n-1)+f(m-n,n)# 递归出口条件说明：# 当n=1时，所有苹果都必须放在一个盘子里，所以返回１；# 当没有苹果可放时，定义为１种放法；# 递归的两条路，第一条n会逐渐减少，终会到达出口n==1;# 第二条m会逐渐减少，因为n&gt;m时，我们会return f(m,m) 所以终会到达出口m==0．def fn(m, n): if n == 1 or m == 0: return 1 elif n &gt; m: return fn(m, m) else: return fn(m, n-1) + fn(m-n, n)while True: try: m, n = map(int, input().strip().split()) count = 0 if not (1 &lt;= m &lt;= 10 and 1 &lt;= n &lt;= 10): print(-1) else: print(fn(m, n)) except Exception as e: break 合唱队问题链接：https://www.nowcoder.com/questionTerminal/6d9d69e3898f45169a441632b325c7b4?answerType=1&amp;f=discussion 问题：计算最少出列多少位同学，使得剩下的同学排成合唱队形 说明： N位同学站成一排，音乐老师要请其中的(N-K)位同学出列，使得剩下的K位同学排成合唱队形。合唱队形是指这样的一种队形：设K位同学从左到右依次编号为1，2…，K，他们的身高分别为T1，T2，…，TK，则他们的身高满足存在i（1&lt;=i&lt;=K）使得T1&lt;T2&lt;……&lt;Ti-1Ti+1&gt;……&gt;TK。你的任务是，已知所有N位同学的身高，计算最少需要几位同学出列，可以使得剩下的同学排成合唱队形。请注意处理多组输入输出！ 示例：输入 128186 186 150 200 160 130 197 200 输出 14 思路： 对于题目，所有人都已经站好位，不能再改变位置了，只能从当中去掉人组成合唱队。同时，可以考虑中间的人两边没有人的情况（比如两头的两个人，或者这个人太矮周围的人都比他高的情况），但是这种情况基本被pass掉。计算出每个人左边能出现的最多的人数：比如题中所给出的示例：186 186 150 200 160 130 197 200。首先如果第一个数186在中间，左边没有数，就自己一个人，所以是1；第二个数186因为左边那个人跟他一边高，没有比他矮的了，所以也是1；第三个数150，左边的人都比他高，他如果是中间的话左边也他自己一个人，所以还是1；第四个数200，因为不能换位置，所以只能留186或者150，加上自己，就是2…最后再以197为例，左边保留150,160是左边人最多的情况，再加上自己，就是3。所以每个人左边人最多的情况（加上自己）就是（186）1 1 1 2 2 1 3 4（200）。同理，看一下每个人右边可能出现最多的人，这时我们从后往前看。200在最右面，所以自己一个人，是1；197最右面没有比他矮的，自己，是1…160左边一个比他矮的，所以算上自己是2，以此类推。所以每个人右边人做多的情况（加上自己）就是（186）3 3 2 3 2 1 1 1（200）所以将上面两个划横线的对应相加，就可以得到自己如果是中间的那个人，可以得到的最大的合唱队人数。当然，自己加了两遍，所以得减掉一个自己。另外题目问的是最少去掉的人，所以最后的结果：总人数 - 该数所在队列人数 = 需要出队的人数 代码示例： 1234567891011121314151617181920# -*- coding:utf-8 -*-def get_left_max(lst): tmp = [1] * len(lst) for i in range(len(lst)): for j in range(i): if lst[j] &lt; lst[i] and tmp[i] &lt; tmp[j] + 1: tmp[i] += 1 return tmpwhile True: try: num = int(input().strip()) team_list = list(map(int, input().strip().split())) index_l = get_left_max(team_list) index_r = get_left_max(team_list[::-1])[::-1] rst = num - max(x + y for x, y in zip(index_l, index_r)) + 1 print(rst) except Exception as e: break 1234567891011121314151617181920212223242526# -*- coding:utf-8 -*-import bisectdef get_left_max(lst): tmp = [1] dp = [] for x in lst: if not dp: dp.append(x) else: index = bisect.bisect_left(dp, x) dp[index: index + 1] = [x] tmp.append(index + 1) return tmpwhile True: try: num = int(input().strip()) team_list = list(map(int, input().strip().split())) index_l = get_left_max(team_list) index_r = get_left_max(team_list[::-1])[::-1] rst = num - max(x + y for x, y in zip(index_l, index_r)) + 1 print(rst) except Exception as e: break]]></content>
      <categories>
        <category>dataStructure</category>
      </categories>
      <tags>
        <tag>dataStructure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树]]></title>
    <url>%2FdataStructure%2Fck9bgz7lp0036qov70gp40a4h.html</url>
    <content type="text"><![CDATA[介绍树 是一种经常用到的数据结构，用来模拟具有树状结构性质的数据集合。 树里的每一个节点有一个根植和一个包含所有子节点的列表。从图的观点来看，树也可视为一个拥有N 个节点和N-1 条边的一个有向无环图。 二叉树是一种更为典型的树树状结构。如它名字所描述的那样，二叉树是每个节点最多有两个子树的树结构，通常子树被称作“左子树”和“右子树”。 树的遍历以二叉树为例，示例如下: 12345678输入: [1,null,2,3] 1 \ 2 / 3 输出: [1,2,3] 前序遍历 前序遍历首先访问根节点，然后遍历左子树，最后遍历右子树。 python3 代码实现： 123456789101112131415161718# Definition for a binary tree node.class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = Noneclass Solution: def preorderTraversal(self, root: TreeNode) -&gt; List[int]: ret, stack = [], [root] while stack: node = stack.pop() if node: ret.append(node.val) #注意压入栈的顺序,先压入右孩子，再压入左孩子 stack.append(node.right) stack.append(node.left) return ret 中序遍历 中序遍历是先遍历左子树，然后访问根节点，然后遍历右子树。 通常来说，对于二叉搜索树，我们可以通过中序遍历得到一个递增的有序序列。 后序遍历 后序遍历是先遍历左子树，然后遍历右子树，最后访问树的根节点。 值得注意的是，当你删除树中的节点时，删除过程将按照后序遍历的顺序进行。 也就是说，当你删除一个节点时，你将首先删除它的左节点和它的右边的节点，然后再删除节点本身。 递归和迭代递归或迭代方法实现算法。 递归(recursion)是程序调用自身的编程技巧。 迭代（iteration） 是重复反馈过程的活动，其目的通常是为了逼近所需目标或结果。每一次对过程的重复称为一次“迭代”，而每一次迭代得到的结果会作为下一次迭代的初始值。]]></content>
      <categories>
        <category>dataStructure</category>
      </categories>
      <tags>
        <tag>dataStructure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript Array]]></title>
    <url>%2Fweb%2FJavaScript%2Fck9bgz7oe005gqov7gfyz2akw.html</url>
    <content type="text"><![CDATA[数组对象的作用是：使用单独的变量名来存储一系列的值。]]></content>
      <categories>
        <category>web</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue 安装]]></title>
    <url>%2Fweb%2Fvue%2Fck9bgz81000bbqov79qtny0hb.html</url>
    <content type="text"><![CDATA[独立版本我们可以在 Vue.js 的官网上直接下载 vue.min.js 并用 &lt;script&gt; 标签引入。Vue.js下载地址 1&lt;script src=&quot;path/to/vue.min.js&quot;&gt;&lt;/script&gt; 使用 CDN 方 Staticfile CDN（国内） : https://cdn.staticfile.org/vue/2.2.2/vue.min.js 1&lt;script src=&quot;https://cdn.staticfile.org/vue/2.2.2/vue.min.js&quot;&gt;&lt;/script&gt; unpkg：https://unpkg.com/vue/dist/vue.js, 会保持和 npm 发布的最新的版本一致。 1&lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; cdnjs : https://cdnjs.cloudflare.com/ajax/libs/vue/2.1.8/vue.min.js 1&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/vue/2.1.8/vue.min.js&quot;&gt;&lt;/script&gt; NPM 方法若安装速度较慢，可使用淘宝的镜像及其命令 cnpm，安装使用介绍参照：使用淘宝 NPM 镜像。npm 版本需要大于 3.0，如果低于此版本需要升级它： 123456789# 查看版本$ npm -v2.3.0#升级 npmcnpm install npm -g# 升级或安装 cnpmnpm install cnpm -g 在用 Vue.js 构建大型应用时推荐使用 NPM 安装： 12# 最新稳定版$ npm install vue 命令行工具Vue.js 提供一个官方命令行工具，可用于快速搭建大型单页应用。 12# 全局安装 vue-cli$ npm install --global vue-cli 安装vue-cli]]></content>
      <categories>
        <category>web</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python subprocess module]]></title>
    <url>%2Fpython%2Fmodule%2Fck9bgz80000adqov7c0ir9yys.html</url>
    <content type="text"><![CDATA[源代码: Lib/subprocess.py 参考： 官方文档 Python subprocess模块详细解读]]></content>
      <categories>
        <category>python</category>
        <category>module</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>module</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql简介]]></title>
    <url>%2Fmysql%2Fck9bgz87p00guqov7uzrcb4bt.html</url>
    <content type="text"><![CDATA[简介MySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，属于 Oracle 旗下产品。MySQL 是最流行的关系型数据库管理系统之一，在 WEB 应用方面，MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件之一。 MySQL是一种关系型数据库管理系统，关系数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。 MySQL所使用的 SQL 语言是用于访问数据库的最常用标准化语言。MySQL 软件采用了双授权政策，分为社区版和商业版，由于其体积小、速度快、总体拥有成本低，尤其是开放源码这一特点，一般中小型网站的开发都选择 MySQL 作为网站数据库。 数据库是什么？数据库的概念基本命令登陆数据库服务器命令：$ mysql -uroot -p123456 1234567891011C:\Users\Mr wang&gt;mysql -uroot -p123456mysql: [Warning] Using a password on the command line interface can be insecure.Welcome to the MySQL monitor. Commands end with ; or \g.Your MySQL connection id is 6Server version: 5.7.20-log MySQL Community Server (GPL)Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.mysql&gt; 查询所有的数据库在 MySQL 中，可使用 SHOW DATABASES 语句来查看或显示当前用户权限范围以内的数据库。查看数据库的语法格式为： 1SHOW DATABASES [LIKE '数据库名']; 语法说明如下： LIKE 从句是可选项，用于匹配指定的数据库名称。LIKE 从句可以部分匹配，也可以完全匹配。 数据库名由单引号&#39; &#39;包围。 123456789101112mysql&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema || query_test || sys || test |+--------------------+6 rows in set (0.00 sec) 使用 LIKE 从句示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748先创建三个数据库，名字分别为 test_db、db_test、db_test_db:create database if not exists test_db;create database if not exists db_test;create database if not exists db_test_db;# 使用 LIKE 从句，查看与 test_db 完全匹配的数据库：mysql&gt; SHOW DATABASES LIKE &apos;test_db&apos;;+--------------------+| Database (test_db) |+--------------------+| test_db |+--------------------+1 row in set (0.03 sec)# 使用 LIKE 从句，查看名字中包含 test 的数据库：mysql&gt; SHOW DATABASES LIKE &apos;%test%&apos;;+--------------------+| Database (%test%) |+--------------------+| db_test |+--------------------+| db_test_db |+--------------------+| test_db |+--------------------+3 row in set (0.03 sec)# 使用 LIKE 从句，查看名字以 db 开头的数据库：mysql&gt; SHOW DATABASES LIKE &apos;db%&apos;;+----------------+| Database (db%) |+----------------+| db_test |+----------------+| db_test_db |+----------------+2 row in set (0.03 sec)# 使用 LIKE 从句，查看名字以 db 结尾的数据库：mysql&gt; SHOW DATABASES LIKE &apos;%db&apos;;+----------------+| Database (%db) |+----------------+| db_test_db |+----------------+| test_db |+----------------+2 row in set (0.03 sec) 退出数据库命令：$ exit; 12mysql&gt; exit;Bye 创建数据库在 MySQL 中，可以使用 CREATE DATABASE 语句创建数据库，语法格式如下： 123CREATE DATABASE [IF NOT EXISTS] &lt;数据库名&gt;[[DEFAULT] CHARACTER SET &lt;字符集名&gt;] [[DEFAULT] COLLATE &lt;校对规则名&gt;]; [ ]中的内容是可选的。语法说明如下：&lt;数据库名&gt;：创建数据库的名称。MySQL 的数据存储区将以目录方式表示 MySQL 数据库，因此数据库名称必须符合操作系统的文件夹命名规则，不能以数字开头，尽量要有实际意义。注意在 MySQL 中不区分大小写。IF NOT EXISTS：在创建数据库之前进行判断，只有该数据库目前尚不存在时才能执行操作。此选项可以用来避免数据库已经存在而重复创建的错误。[DEFAULT] CHARACTER SET：指定数据库的字符集。指定字符集的目的是为了避免在数据库中存储的数据出现乱码的情况。如果在创建数据库时不指定字符集，那么就使用系统的默认字符集。[DEFAULT] COLLATE：指定字符集的默认校对规则。MySQL 的字符集（CHARACTER）和校对规则（COLLATION）是两个不同的概念。字符集是用来定义 MySQL 存储字符串的方式，校对规则定义了比较字符串的方式 示例1：最简单的创建 MySQL 数据库的语句 1234567mysql&gt; create database test;Query OK, 1 row affected (0.00 sec)注：“Query OK” 表示上面的命令执行成功“1 row affected” 表示操作只影响了数据库中一行的记录“0.00 sec” 记录了操作执行的时间 12mysql&gt; create database if not exists test;Query OK, 1 row affected, 1 warning (0.00 sec) 示例2：创建 MySQL 数据库时指定字符集和校对规则 1234mysql&gt; create database if not exists test2 -&gt; default character set utf8 -&gt; default collate utf8_general_ci;Query OK, 1 row affected (0.00 sec) 查看数据库的定义声明使用SHOW CREATE DATABASE查看相应数据库的定义声明 命令：$ show create database {dbName}; 1234567mysql&gt; show create database test;+----------+---------------------------------------------------------------+| Database | Create Database |+----------+---------------------------------------------------------------+| test | CREATE DATABASE `test` /*!40100 DEFAULT CHARACTER SET utf8 */ |+----------+---------------------------------------------------------------+1 row in set (0.00 sec) 修改数据库在 MySQL数据库中只能对数据库使用的字符集和校对规则进行修改，数据库的这些特性都储存在 db.opt 文件中。下面我们来介绍一下修改数据库的基本操作。 在 MySQL 中，可以使用 ALTER DATABASE 来修改已经被创建或者存在的数据库的相关参数。修改数据库的语法格式为： 123ALTER DATABASE [数据库名] &#123; [ DEFAULT ] CHARACTER SET &lt;字符集名&gt; |[ DEFAULT ] COLLATE &lt;校对规则名&gt;&#125; 语法说明如下： ALTER DATABASE 用于更改数据库的全局特性。 使用 ALTER DATABASE 需要获得数据库 ALTER 权限。 数据库名称可以忽略，此时语句对应于默认数据库。 CHARACTER SET 子句用于更改默认的数据库字符集。 示例： 123456789101112mysql&gt; alter database test -&gt; default character set gb2312 -&gt; default collate gb2312_chinese_ci;Query OK, 1 row affected (0.00 sec)mysql&gt; show create database test;+----------+-----------------------------------------------------------------+| Database | Create Database |+----------+-----------------------------------------------------------------+| test | CREATE DATABASE `test` /*!40100 DEFAULT CHARACTER SET gb2312 */ |+----------+-----------------------------------------------------------------+1 row in set (0.00 sec) 删除数据库在 MySQL 中，当需要删除已创建的数据库时，可以使用 DROP DATABASE 语句。其语法格式为： 1DROP DATABASE [ IF EXISTS ] &lt;数据库名&gt;; 语法说明如下： &lt;数据库名&gt;：指定要删除的数据库名。 IF EXISTS：用于防止当数据库不存在时发生错误。 DROP DATABASE：删除数据库中的所有表格并同时删除数据库。使用此语句时要非常小心，以免错误删除。如果要使用 DROP DATABASE，需要获得数据库 DROP 权限。 注意：MySQL 安装后，系统会自动创建名为 information_schema 和 mysql 的两个系统数据库，系统数据库存放一些和数据库相关的信息，如果删除了这两个数据库，MySQL 将不能正常工作。 示例： 12345678910111213141516171819202122232425262728293031mysql&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema || query_test || sys || test || test2 |+--------------------+7 rows in set (0.00 sec)mysql&gt; drop database if exists test;Query OK, 0 rows affected (0.00 sec)mysql&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema || query_test || sys || test2 |+--------------------+6 rows in set (0.00 sec)mysql&gt; 使用 DROP DATABASE 命令时要非常谨慎，在执行该命令后，MySQL 不会给出任何提示确认信息。DROP DATABASE 删除数据库后，数据库中存储的所有数据表和数据也将一同被删除，而且不能恢复。因此最好在删除数据库之前先将数据库进行备份。 切换数据库命令：$ use &lt;dbName&gt;; 12mysql&gt; use test;Database changed 错误示例： 12mysql&gt; use tests;ERROR 1049 (42000): Unknown database 'tests' 查看数据库引擎 数据库存储引擎是数据库底层软件组件，数据库管理系统使用数据引擎进行创建、查询、更新和删除数据操作。不同的存储引擎提供不同的存储机制、索引技巧、锁定水平等功能，使用不同的存储引擎还可以获得特定的功能。 现在许多数据库管理系统都支持多种不同的存储引擎。MySQL 的核心就是存储引擎。 MySQL 支持多种类型的数据库引擎，可分别根据各个引擎的功能和特性为不同的数据库处理任务提供各自不同的适应性和灵活性。在 MySQL 中，可以利用 SHOW ENGINES 语句来显示可用的数据库引擎和默认引擎。 MySQL 提供了多个不同的存储引擎，包括处理事务安全表的引擎和处理非事务安全表的引擎。在 MySQL 中，不需要在整个服务器中使用同一种存储引擎，针对具体的要求，可以对每一个表使用不同的存储引擎。 123456789101112131415mysql&gt; show engines;+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+| Engine | Support | Comment | Transactions | XA | Savepoints |+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+| InnoDB | DEFAULT | Supports transactions, row-level locking, and foreign keys | YES | YES | YES || MRG_MYISAM | YES | Collection of identical MyISAM tables | NO | NO | NO || MEMORY | YES | Hash based, stored in memory, useful for temporary tables | NO | NO | NO || BLACKHOLE | YES | /dev/null storage engine (anything you write to it disappears) | NO | NO | NO || MyISAM | YES | MyISAM storage engine | NO | NO | NO || CSV | YES | CSV storage engine | NO | NO | NO || ARCHIVE | YES | Archive storage engine | NO | NO | NO || PERFORMANCE_SCHEMA | YES | Performance Schema | NO | NO | NO || FEDERATED | NO | Federated MySQL storage engine | NULL | NULL | NULL |+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+9 rows in set (0.00 sec) 注：Support 列的值表示某种引擎是否能使用，YES表示可以使用，NO表示不能使用，DEFAULT表示该引擎为当前默认的存储引擎。 修改默认引擎InnoDB 是系统的默认引擎，支持可靠的事务处理。使用下面的语句可以修改数据库临时的默认存储引擎 1SET default_storage_engine=&lt; 存储引擎名 &gt;; 示例： 123456789101112131415161718mysql&gt; set default_storage_engine=MyISAM;Query OK, 0 rows affected (0.00 sec)mysql&gt; show engines;+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+| Engine | Support | Comment | Transactions | XA | Savepoints |+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+| InnoDB | YES | Supports transactions, row-level locking, and foreign keys | YES | YES | YES || MRG_MYISAM | YES | Collection of identical MyISAM tables | NO | NO | NO || MEMORY | YES | Hash based, stored in memory, useful for temporary tables | NO | NO | NO || BLACKHOLE | YES | /dev/null storage engine (anything you write to it disappears) | NO | NO | NO || MyISAM | DEFAULT | MyISAM storage engine | NO | NO | NO || CSV | YES | CSV storage engine | NO | NO | NO || ARCHIVE | YES | Archive storage engine | NO | NO | NO || PERFORMANCE_SCHEMA | YES | Performance Schema | NO | NO | NO || FEDERATED | NO | Federated MySQL storage engine | NULL | NULL | NULL |+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+9 rows in set (0.00 sec) 此时，可以发现 MySQL 的默认存储引擎已经变成了 MyISAM。但是当再次重启客户端时，默认存储引擎仍然是 InnoDB。 查询当前数据库下所有表命令：$ show tables; 12345678910mysql&gt; show tables;+----------------+| Tables_in_test |+----------------+| classes || students || use2 || user |+----------------+4 rows in set (0.00 sec) 数据类型简介MySQL 的数据类型有大概可以分为 5 种，分别是整数类型、浮点数类型和定点数类型、日期和时间类型、字符串类型、二进制类型等。 数值类型 整数类型：TININT、SMALLINT、MEDIUMINT、INT、BIGINT 浮点数类型：FLOAT、DOUBLE 定点数类型：DECIMAL 日期时间类型 YEAR、TIME、DATA、DATATIM和TIMESTAMP 字符串类型 CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM 和 SET 等。 二进制类型 BIT、BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB。 创建数据表所谓创建数据表，指的是在已经创建的数据库中建立新表。 创建数据表的过程是规定数据列的属性的过程，同时也是实施数据完整性（包括实体完整性、引用完整性和域完整性）约束的过程。 基本语法在 MySQL 中，可以使用 CREATE TABLE 语句创建表。其语法格式为： 1CREATE TABLE &lt;表名&gt; ([表定义选项])[表选项][分区选项]; 其中，[表定义选项]的格式为： 1&lt;列名1&gt; &lt;类型1&gt; [,…] &lt;列名n&gt; &lt;类型n&gt; CREATE TABLE 命令语法比较多，其主要是由表创建定义（create-definition）、表选项（table-options）和分区选项（partition-options）所组成的。 CREATE TABLE 语句的主要语法及使用说明如下： CREATE TABLE：用于创建给定名称的表，必须拥有表CREATE的权限。 &lt;表名&gt;：指定要创建表的名称，在 CREATE TABLE 之后给出，必须符合标识符命名规则。表名称被指定为 db_name.tbl_name，以便在特定的数据库中创建表。无论是否有当前数据库，都可以通过这种方式创建。在当前数据库中创建表时，可以省略 db-name。如果使用加引号的识别名，则应对数据库和表名称分别加引号。例如，’mydb’.’mytbl’ 是合法的，但 ‘mydb.mytbl’ 不合法。 &lt;表定义选项&gt;：表创建定义，由列名（col_name）、列的定义（column_definition）以及可能的空值说明、完整性约束或表索引组成。 默认的情况是，表被创建到当前的数据库中。若表已存在、没有当前数据库或者数据库不存在，则会出现错误。 提示：使用 CREATE TABLE 创建表时，必须指定以下信息： 要创建的表的名称不区分大小写，不能使用SQL语言中的关键字，如DROP、ALTER、INSERT等。 数据表中每个列（字段）的名称和数据类型，如果创建多个列，要用逗号隔开。 在指定的数据库中创建表创建 test_db 数据库 123mysql&gt; create database if not exists test_db -&gt; default character set utf8;Query OK, 1 row affected (0.01 sec) 进入 test_db 数据库 12mysql&gt; use test_db;Database changed 创建员工表 tb_emp1，结构如下表所示。 字段名称 数据类型 备注 id INT(ll) 员工编号 name VARCHAR(25) 员工名称 deptld INT(ll) 所在部门编号 salary FLOAT 工资 123456789101112131415mysql&gt; create table tb_emp1( -&gt; id int(11), -&gt; name varchar(25), -&gt; deptld int(11), -&gt; salary float -&gt; );Query OK, 0 rows affected (0.09 sec)mysql&gt; show tables;+-------------------+| Tables_in_test_db |+-------------------+| tb_emp1 |+-------------------+1 row in set (0.00 sec) 查看表结构DESCRIBE/DESC 语句可以查看表的字段信息，包括字段名、字段数据类型、是否为主键、是否有默认值等，语法规则如下： 1DESCRIBE &lt;表名&gt;; 或简写成： 1DESC &lt;表名&gt;; 示例： 12345678910mysql&gt; describe tb_emp1;+--------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+--------+-------------+------+-----+---------+-------+| id | int(11) | YES | | NULL | || name | varchar(25) | YES | | NULL | || deptld | int(11) | YES | | NULL | || salary | float | YES | | NULL | |+--------+-------------+------+-----+---------+-------+4 rows in set (0.00 sec) 其中，各个字段的含义如下： Null：表示该列是否可以存储 NULL 值。 Key：表示该列是否已编制索引。PRI 表示该列是表主键的一部分，UNI 表示该列是 UNIQUE 索引的一部分，MUL 表示在列中某个给定值允许出现多次。 Default：表示该列是否有默认值，如果有，值是多少。 Extra：表示可以获取的与给定列有关的附加信息，如 AUTO_INCREMENT 等。 查看建表语句SHOW CREATE TABLE语句可以用来显示创建表时的CREATE TABLE语句，语法格式如下： 1SHOW CREATE TABLE &lt;表名&gt;\G； 提示：使用 SHOW CREATE TABLE 语句不仅可以查看创建表时的详细语句，而且可以查看存储引擎和字符编码。如果不加“\G”参数，显示的结果可能非常混乱，加上“\G”参数之后，可使显示的结果更加直观，易于查看。 12345678910mysql&gt; show create table tb_emp1\G;*************************** 1. row *************************** Table: tb_emp1Create Table: CREATE TABLE `tb_emp1` ( `id` int(11) DEFAULT NULL, `name` varchar(25) DEFAULT NULL, `deptld` int(11) DEFAULT NULL, `salary` float DEFAULT NULL) ENGINE=MyISAM DEFAULT CHARSET=utf81 row in set (0.00 sec) 修改表结构在 MySQL 中可以使用 ALTER TABLE 语句来改变原有表的结构，例如增加或删减列、创建或取消索引、更改原有列类型、重新命名列或表等。 修改表指的是修改数据库中已经存在的数据表的结构。MySQL 使用 ALTER TABLE 语句修改表。常用的修改表的操作有修改表名、修改字段数据类型或字段名、增加和删除字段、修改字段的排列位置、更改表的存储引擎、删除表的外键约束等。 语法1ALTER TABLE &lt;表名&gt; [修改选项]; 修改选项的语法格式如下： 123456&#123; ADD COLUMN &lt;列名&gt; &lt;类型&gt;| CHANGE COLUMN &lt;旧列名&gt; &lt;新列名&gt; &lt;新列类型&gt;| ALTER COLUMN &lt;列名&gt; &#123; SET DEFAULT &lt;默认值&gt; | DROP DEFAULT &#125;| MODIFY COLUMN &lt;列名&gt; &lt;类型&gt;| DROP COLUMN &lt;列名&gt;| RENAME TO &lt;新表名&gt; &#125; 添加字段随着业务的变化，可能需要在已经存在的表中添加新的字段，一个完整的字段包括字段名、数据类型、完整性约束。添加字段的语法格式如下： 1ALTER TABLE &lt;表名&gt; ADD &lt;新字段名&gt; &lt;数据类型&gt; [约束条件] [FIRST|AFTER 已存在的字段名]； 新字段名为需要添加的字段的名称；FIRST 为可选参数，其作用是将新添加的字段设置为表的第一个字段；AFTER 为可选参数，其作用是将新添加的字段添加到指定的已存在的字段名的后面。 12345678910111213141516mysql&gt; alter table tb_emp1 -&gt; add col1 int first;Query OK, 0 rows affected (0.11 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; desc tb_emp1;+--------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+--------+-------------+------+-----+---------+-------+| col1 | int(11) | YES | | NULL | || id | int(11) | YES | | NULL | || name | varchar(25) | YES | | NULL | || deptld | int(11) | YES | | NULL | || salary | float | YES | | NULL | |+--------+-------------+------+-----+---------+-------+5 rows in set (0.00 sec) 提示：“FIRST 或 AFTER 已存在的字段名”用于指定新增字段在表中的位置，如果 SQL 语句中没有这两个参数，则默认将新添加的字段设置为数据表的最后列。 修改字段数据类型修改字段的数据类型就是把字段的数据类型转换成另一种数据类型。在 MySQL 中修改字段数据类型的语法规则如下： 1ALTER TABLE &lt;表名&gt; MODIFY &lt;字段名&gt; &lt;数据类型&gt;; 其中，表名指要修改数据类型的字段所在表的名称，字段名指需要修改的字段，数据类型指修改后字段的新数据类型。 123456789101112131415mysql&gt; alter table tb_emp1 -&gt; modify name varchar(30);Query OK, 0 rows affected (0.09 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; desc tb_emp1;+--------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+--------+-------------+------+-----+---------+-------+| col1 | int(11) | YES | | NULL | || id | int(11) | YES | | NULL | || name | varchar(30) | YES | | NULL | || deptld | int(11) | YES | | NULL | || salary | float | YES | | NULL | |+--------+-------------+------+-----+---------+-------+ 删除字段删除字段是将数据表中的某个字段从表中移除，语法格式如下： 1ALTER TABLE &lt;表名&gt; DROP &lt;字段名&gt;； 其中，字段名指需要从表中删除的字段的名称。 123456789101112131415mysql&gt; alter table tb_emp1 -&gt; drop col1;Query OK, 0 rows affected (0.41 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; desc tb_emp1;+--------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+--------+-------------+------+-----+---------+-------+| id | int(11) | YES | | NULL | || name | varchar(30) | YES | | NULL | || deptld | int(11) | YES | | NULL | || salary | float | YES | | NULL | |+--------+-------------+------+-----+---------+-------+4 rows in set (0.00 sec) 修改字段名称MySQL 中修改表字段名的语法规则如下： 1ALTER TABLE &lt;表名&gt; CHANGE &lt;旧字段名&gt; &lt;新字段名&gt; &lt;新数据类型&gt;； 其中，旧字段名指修改前的字段名；新字段名指修改后的字段名；新数据类型指修改后的数据类型，如果不需要修改字段的数据类型，可以将新数据类型设置成与原来一样，但数据类型不能为空。 12345678910111213141516171819202122232425262728mysql&gt; desc tb_emp1;+--------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+--------+-------------+------+-----+---------+-------+| id | int(11) | YES | | NULL | || name | varchar(30) | YES | | NULL | || age | smallint(6) | YES | | NULL | || deptld | int(11) | YES | | NULL | || salary | float | YES | | NULL | |+--------+-------------+------+-----+---------+-------+5 rows in set (0.00 sec)mysql&gt; alter table tb_emp1 -&gt; change age age1 int;Query OK, 0 rows affected (0.15 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; desc tb_emp1;+--------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+--------+-------------+------+-----+---------+-------+| id | int(11) | YES | | NULL | || name | varchar(30) | YES | | NULL | || age1 | int(11) | YES | | NULL | || deptld | int(11) | YES | | NULL | || salary | float | YES | | NULL | |+--------+-------------+------+-----+---------+-------+5 rows in set (0.00 sec) CHANGE 也可以只修改数据类型，实现和 MODIFY 同样的效果，方法是将 SQL 语句中的“新字段名”和“旧字段名”设置为相同的名称，只改变“数据类型”。 提示：由于不同类型的数据在机器中的存储方式及长度并不相同，修改数据类型可能会影响数据表中已有的数据记录，因此，当数据表中已经有数据时，不要轻易修改数据类型。 修改表名MySQL 通过 ALTER TABLE 语句来实现表名的修改，语法规则如下： 1ALTER TABLE &lt;旧表名&gt; RENAME [TO] &lt;新表名&gt;； 其中，TO 为可选参数，使用与否均不影响结果。 123456789101112131415161718mysql&gt; show tables;+-------------------+| Tables_in_test_db |+-------------------+| tb_emp1 |+-------------------+1 row in set (0.00 sec)mysql&gt; alter table tb_emp1 rename tb_emp2;Query OK, 0 rows affected (0.01 sec)mysql&gt; show tables;+-------------------+| Tables_in_test_db |+-------------------+| tb_emp2 |+-------------------+1 row in set (0.00 sec) 删除数据表在 MySQL 数据库中，对于不再需要的数据表，我们可以将其从数据库中删除。 在删除表的同时，表的结构和表中所有的数据都会被删除，因此在删除数据表之前最好先备份，以免造成无法挽回的损失。 使用 DROP TABLE 语句可以删除一个或多个数据表，语法格式如下： 1DROP TABLE [IF EXISTS] 表名1 [ ,表名2, 表名3 ...]; 对语法格式的说明如下： 表名1, 表名2, 表名3 ...表示要被删除的数据表的名称。DROP TABLE 可以同时删除多个表，只要将表名依次写在后面，相互之间用逗号隔开即可。 IF EXISTS 用于在删除数据表之前判断该表是否存在。如果不加 IF EXISTS，当数据表不存在时 MySQL 将提示错误，中断 SQL 语句的执行；加上 IF EXISTS 后，当数据表不存在时 SQL 语句可以顺利执行，但是会发出警告（warning）。 两点注意： 用户必须拥有执行 DROP TABLE 命令的权限，否则数据表不会被删除。 表被删除时，用户在该表上的权限不会自动删除。 1234567891011121314mysql&gt; show tables;+-------------------+| Tables_in_test_db |+-------------------+| tb_emp2 |+-------------------+1 row in set (0.00 sec)mysql&gt;mysql&gt; drop table if exists tb_emp1, tb_emp2;Query OK, 0 rows affected, 1 warning (0.00 sec)mysql&gt; show tables;Empty set (0.00 sec) 主键约束（PRIMARY KEY）“主键（PRIMARY KEY）”的完整称呼是“主键约束”。MySQL 主键约束是一个列或者列的组合，其值能唯一地标识表中的每一行。这样的一列或多列称为表的主键，通过它可以强制表的实体完整性。 选取设置主键约束的字段主键约束即在表中定义一个主键来唯一确定表中每一行数据的标识符。主键可以是表中的某一列或者多列的组合，其中由多列组合的主键称为复合主键。主键应该遵守下面的规则： 每个表只能定义一个主键。 主键值必须唯一标识表中的每一行，且不能为 NULL，即表中不可能存在两行数据有相同的主键值。这是唯一性原则。 一个列名只能在复合主键列表中出现一次。 复合主键不能包含不必要的多余列。当把复合主键的某一列删除后，如果剩下的列构成的主键仍然满足唯一性原则，那么这个复合主键是不正确的。这是最小化原则。 在创建表时设置主键约束在 CREATE TABLE 语句中，主键是通过 PRIMARY KEY 关键字来指定的。 在定义列的同时指定主键，语法规则如下： 1&lt;字段名&gt; &lt;数据类型&gt; PRIMARY KEY [默认值] 示例： 1234567891011121314151617mysql&gt; CREATE TABLE tb_emp3( -&gt; id INT(11) PRIMARY KEY, -&gt; name VARCHAR(25), -&gt; deptId INT(11), -&gt; salary FLOAT -&gt; );Query OK, 0 rows affected (0.37 sec)mysql&gt; DESC tb_emp3;+--------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+--------+-------------+------+-----+---------+-------+| id | int(11) | NO | PRI | NULL | || name | varchar(25) | YES | | NULL | || deptId | int(11) | YES | | NULL | || salary | float | YES | | NULL | |+--------+-------------+------+-----+---------+-------+4 rows in set (0.14 sec) 在定义完所有列之后，指定主键的语法格式为： 1[CONSTRAINT &lt;约束名&gt;] PRIMARY KEY [字段名] 12345678910111213141516171819mysql&gt; CREATE TABLE tb_emp4 -&gt; ( -&gt; id INT(11), -&gt; name VARCHAR(25), -&gt; deptId INT(11), -&gt; salary FLOAT, -&gt; PRIMARY KEY(id) -&gt; );Query OK, 0 rows affected (0.37 sec)mysql&gt; DESC tb_emp4;+--------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+--------+-------------+------+-----+---------+-------+| id | int(11) | NO | PRI | NULL | || name | varchar(25) | YES | | NULL | || deptId | int(11) | YES | | NULL | || salary | float | YES | | NULL | |+--------+-------------+------+-----+---------+-------+4 rows in set (0.14 sec) 在创建表时设置复合主键主键由多个字段联合组成，语法规则如下： 1PRIMARY KEY [字段1，字段2，…,字段n] 示例： 1234567891011121314151617mysql&gt; CREATE TABLE tb_emp5 -&gt; ( -&gt; name VARCHAR(25), -&gt; deptId INT(11), -&gt; salary FLOAT, -&gt; PRIMARY KEY(id,deptId) -&gt; );Query OK, 0 rows affected (0.37 sec)mysql&gt; DESC tb_emp5;+--------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+--------+-------------+------+-----+---------+-------+| name | varchar(25) | NO | PRI | NULL | || deptId | int(11) | NO | PRI | NULL | || salary | float | YES | | NULL | |+--------+-------------+------+-----+---------+-------+3 rows in set (0.14 sec) 在修改表时添加主键约束在修改数据表时添加主键约束的语法规则为： 1ALTER TABLE &lt;数据表名&gt; ADD PRIMARY KEY(&lt;列名&gt;); 示例： 1234567891011121314mysql&gt; ALTER TABLE tb_emp2 -&gt; ADD PRIMARY KEY(id);Query OK, 0 rows affected (0.94 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; DESC tb_emp2;+--------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+--------+-------------+------+-----+---------+-------+| id | int(11) | NO | PRI | NULL | || name | varchar(30) | YES | | NULL | || deptId | int(11) | YES | | NULL | || salary | float | YES | | NULL | |+--------+-------------+------+-----+---------+-------+4 rows in set (0.12 sec) 外键约束（FOREIGN KEY）MySQL 外键约束（FOREIGN KEY）用来在两个表的数据之间建立链接，它可以是一列或者多列。一个表可以有一个或多个外键。 外键是表的一个字段，不是本表的主键，但对应另一个表的主键。定义外键后，不允许删除另一个表中具有关联关系的行。 主表（父表）：对于两个具有关联关系的表而言，相关联字段中主键所在的表就是主表。 从表（子表）：对于两个具有关联关系的表而言，相关联字段中外键所在的表就是从表。 选取设置 MySQL 外键约束的字段定义一个外键时，需要遵守下列规则： 父表必须已经存在于数据库中，或者是当前正在创建的表。如果是后一种情况，则父表与子表是同一个表，这样的表称为自参照表，这种结构称为自参照完整性。 必须为父表定义主键。 主键不能包含空值，但允许在外键中出现空值。也就是说，只要外键的每个非空值出现在指定的主键中，这个外键的内容就是正确的。 在父表的表名后面指定列名或列名的组合。这个列或列的组合必须是父表的主键或候选键。 外键中列的数目必须和父表的主键中列的数目相同。 外键中列的数据类型必须和父表主键中对应列的数据类型相同。 在创建表时设置外键约束在数据表中创建外键使用 FOREIGN KEY 12[CONSTRAINT &lt;外键名&gt;] FOREIGN KEY 字段名 [，字段名2，…]REFERENCES &lt;主表名&gt; 主键列1 [，主键列2，…] 其中：外键名为定义的外键约束的名称，一个表中不能有相同名称的外键；字段名表示子表需要添加外健约束的字段列；主表名即被子表外键所依赖的表的名称；主键列表示主表中定义的主键列或者列组合。 示例： 创建 tb_dept1 的 SQL 语句运行结果如下所示: 123456mysql&gt; create table if not exists tb_dept1( -&gt; id int primary key, -&gt; name varchar(22) not null, -&gt; location varchar(22) -&gt; );Query OK, 0 rows affected (0.10 sec) 创建数据表 tb_emp1，并在表 tb_emp1 上创建外键约束，让它的键 deptId 作为外键关联到表 tb_dept1 的主键 id，输入的 SQL 语句和运行结果如下所示。 123456789101112131415161718192021mysql&gt; create table tb_emp1( -&gt; id int(11), -&gt; name varchar(25), -&gt; deptId int(11), -&gt; salary float, -&gt; constraint fk_emp_dept1 -&gt; foreign key(deptId) references tb_dept1(id), -&gt; primary key(id) -&gt; );Query OK, 0 rows affected (0.09 sec)mysql&gt; desc tb_emp1;+--------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+--------+-------------+------+-----+---------+-------+| id | int(11) | NO | PRI | NULL | || name | varchar(25) | YES | | NULL | || deptId | int(11) | YES | MUL | NULL | || salary | float | YES | | NULL | |+--------+-------------+------+-----+---------+-------+4 rows in set (0.01 sec) 提示：关联指的是关系数据库中，相关表之间的联系。它是通过相同的属性或属性组来表示的。子表的外键必须关联父表的主键，且关联字段的数据类型必须匹配，如果类型不一样，则创建子表时会出现错误“ERROR 1005(HY000)：Can’t create table’database.tablename’(errno：150)”。 在修改表时添加外键约束在修改数据表时添加外键约束的语法规则为： 12ALTER TABLE &lt;数据表名&gt; ADD CONSTRAINT &lt;索引名&gt;FOREIGN KEY(&lt;列名&gt;) REFERENCES &lt;主表名&gt; (&lt;列名&gt;); 删除外键约束对于数据库中定义的外键，如果不再需要，可以将其删除。外键一旦删除，就会解除主表和从表间的关联关系，MySQL 中删除外键的语法格式如下： 1ALTER TABLE &lt;表名&gt; DROP FOREIGN KEY &lt;外键约束名&gt;; 唯一约束（UNIQUE KEY）MySQL唯一约束（Unique Key）要求该列唯一，允许为空，但只能出现一个空值。唯一约束可以确保一列或者几列不出现重复值。 在创建表时设置唯一约束在定义完列之后直接使用 UNIQUE 1&lt;字段名&gt; &lt;数据类型&gt; UNIQUE 示例： 12345678910111213141516mysql&gt; CREATE TABLE tb_dept2 -&gt; ( -&gt; id INT(11) PRIMARY KEY, -&gt; name VARCHAR(22) UNIQUE, -&gt; location VARCHAR(50) -&gt; );Query OK, 0 rows affected (0.37 sec)mysql&gt; DESC tb_dept2;+----------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+----------+-------------+------+-----+---------+-------+| id | int(11) | NO | PRI | NULL | || name | varchar(40) | YES | UNI | NULL | || location | varchar(50) | YES | | NULL | |+----------+-------------+------+-----+---------+-------+3 rows in set (0.08 sec) 提示：UNIQUE 和 PRIMARY KEY 的区别：一个表可以有多个字段声明为 UNIQUE，但只能有一个 PRIMARY KEY 声明；声明为 PRIMAY KEY 的列不允许有空值，但是声明为 UNIQUE 的字段允许空值的存在。 在修改表时添加唯一约束在修改表时添加唯一约束的语法格式为： 1ALTER TABLE &lt;数据表名&gt; ADD CONSTRAINT &lt;唯一约束名&gt; UNIQUE(&lt;列名&gt;); 示例： 12345678910111213mysql&gt; ALTER TABLE tb_dept1 -&gt; ADD CONSTRAINT unique_name UNIQUE(name);Query OK, 0 rows affected (0.63 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; DESC tb_dept1;+----------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+----------+-------------+------+-----+---------+-------+| id | int(11) | NO | PRI | NULL | || name | varchar(22) | NO | UNI | NULL | || location | varchar(50) | YES | | NULL | |+----------+-------------+------+-----+---------+-------+3 rows in set (0.00 sec) 删除唯一约束在 MySQL 中删除唯一约束的语法格式如下： 1ALTER TABLE &lt;表名&gt; DROP INDEX &lt;唯一约束名&gt;; 示例： 12345678910111213mysql&gt; ALTER TABLE tb_dept1 -&gt; DROP INDEX unique_name;Query OK, 0 rows affected (0.20 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; DESC tb_dept1;+----------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+----------+-------------+------+-----+---------+-------+| id | int(11) | NO | PRI | NULL | || name | varchar(22) | NO | | NULL | || location | varchar(50) | YES | | NULL | |+----------+-------------+------+-----+---------+-------+3 rows in set (0.00 sec) 检查约束（CHECK）MySQL 检查约束（CHECK）可以通过 CREATE TABLE 或 ALTER TABLE 语句实现，根据用户实际的完整性要求来定义。它可以分别对列或表实施 CHECK 约束。 选取设置检查约束的字段检查约束使用 CHECK 关键字，具体的语法格式如下： 1CHECK &lt;表达式&gt; 其中：&lt;表达式&gt;若将 CHECK 约束子句置于表中某个列的定义之后，则这种约束也称为基于列的 CHECK 约束。 注意：若将 CHECK 约束子句置于所有列的定义以及主键约束和外键定义之后，则这种约束也称为基于表的 CHECK 约束。该约束可以同时对表中多个列设置限定条件。 在创建表时设置检查约束创建表时设置检查约束的语法规则如下： 1CHECK(&lt;检查约束&gt;) 示例： 12345678910mysql&gt; CREATE TABLE tb_emp7 -&gt; ( -&gt; id INT(11) PRIMARY KEY, -&gt; name VARCHAR(25), -&gt; deptId INT(11), -&gt; salary FLOAT, -&gt; CHECK(salary&gt;0 AND salary&lt;10000), -&gt; FOREIGN KEY(deptId) REFERENCES tb_dept1(id) -&gt; );Query OK, 0 rows affected (0.37 sec) 在修改表时添加检查约束修改表时设置检查约束的语法规则如下： 1ALTER TABLE tb_emp7 ADD CONSTRAINT &lt;检查约束名&gt; CHECK(&lt;检查约束&gt;); 示例： 12345mysql&gt; ALTER TABLE tb_emp7 -&gt; ADD CONSTRAINT check_id -&gt; CHECK(id&gt;0);Query OK, 0 rows affected (0.19 sec)Records: 0 Duplicates: 0 Warnings: 0 删除检查约束修改表时删除检查约束的语法规则如下： 1ALTER TABLE &lt;数据表名&gt; DROP CONSTRAINT &lt;检查约束名&gt;; 默认值约束（Default Constraint）在创建表时设置默认值约束创建表时可以使用 DEFAULT 关键字设置默认值约束，具体的语法规则如下： 1&lt;字段名&gt; &lt;数据类型&gt; DEFAULT &lt;默认值&gt;; 示例： 12345678910111213141516mysql&gt; CREATE TABLE tb_dept3 -&gt; ( -&gt; id INT(11) PRIMARY KEY, -&gt; name VARCHAR(22), -&gt; location VARCHAR(50) DEFAULT &apos;Beijing&apos; -&gt; );Query OK, 0 rows affected (0.37 sec)mysql&gt; DESC tb_dept3;+----------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+----------+-------------+------+-----+---------+-------+| id | int(11) | NO | PRI | NULL | || name | varchar(22) | YES | | NULL | || location | varchar(50) | YES | | Beijing | |+----------+-------------+------+-----+---------+-------+3 rows in set (0.06 sec) 在修改表时添加默认值约束修改表时添加默认值约束的语法规则如下： 123ALTER TABLE &lt;数据表名&gt;CHANGE COLUMN &lt;字段名&gt; &lt;字段名&gt; &lt;数据类型&gt; DEFAULT &lt;默认值&gt;; 示例 123456789101112131415161718192021222324252627mysql&gt; desc tb_emp1;+--------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+--------+-------------+------+-----+---------+-------+| id | int(11) | NO | PRI | NULL | || name | varchar(25) | YES | | NULL | || deptId | int(11) | YES | MUL | NULL | || salary | float | YES | | NULL | |+--------+-------------+------+-----+---------+-------+4 rows in set (0.00 sec)mysql&gt; alter table tb_emp1 -&gt; change column salary -&gt; salary float default 10000.0;Query OK, 0 rows affected (0.04 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; desc tb_emp1;+--------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+--------+-------------+------+-----+---------+-------+| id | int(11) | NO | PRI | NULL | || name | varchar(25) | YES | | NULL | || deptId | int(11) | YES | MUL | NULL | || salary | float | YES | | 10000 | |+--------+-------------+------+-----+---------+-------+4 rows in set (0.00 sec) 删除默认值约束修改表时删除默认值约束的语法规则如下： 12ALTER TABLE &lt;数据表名&gt;CHANGE COLUMN &lt;字段名&gt; &lt;字段名&gt; &lt;数据类型&gt; DEFAULT NULL; 示例： 12345678910111213141516mysql&gt; alter table tb_emp1 -&gt; change column salary -&gt; salary float default null;Query OK, 0 rows affected (0.10 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; desc tb_emp1;+--------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+--------+-------------+------+-----+---------+-------+| id | int(11) | NO | PRI | NULL | || name | varchar(25) | YES | | NULL | || deptId | int(11) | YES | MUL | NULL | || salary | float | YES | | NULL | |+--------+-------------+------+-----+---------+-------+4 rows in set (0.00 sec) 非空约束（NOT NULL）MySQL 非空约束（NOT NULL）可以通过 CREATE TABLE 或 ALTER TABLE 语句实现。在表中某个列的定义后加上关键字 NOT NULL 作为限定词，来约束该列的取值不能为空。 非空约束（Not Null Constraint）指字段的值不能为空。对于使用了非空约束的字段，如果用户在添加数据时没有指定值，数据库系统就会报错。 在创建表时设置非空约束创建表时可以使用 NOT NULL 1&lt;字段名&gt; &lt;数据类型&gt; NOT NULL; 12345678910111213141516mysql&gt; CREATE TABLE tb_dept4 -&gt; ( -&gt; id INT(11) PRIMARY KEY, -&gt; name VARCHAR(22) NOT NULL, -&gt; location VARCHAR(50) -&gt; );Query OK, 0 rows affected (0.37 sec)mysql&gt; DESC tb_dept3;+----------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+----------+-------------+------+-----+---------+-------+| id | int(11) | NO | PRI | NULL | || name | varchar(22) | NO | | NULL | || location | varchar(50) | YES | | NULL | |+----------+-------------+------+-----+---------+-------+3 rows in set (0.06 sec) 在修改表时添加非空约束修改表时设置非空约束的语法规则如下： 123ALTER TABLE &lt;数据表名&gt;CHANGE COLUMN &lt;字段名&gt;&lt;字段名&gt; &lt;数据类型&gt; NOT NULL; 1234567891011121314mysql&gt; ALTER TABLE tb_dept4 -&gt; CHANGE COLUMN location -&gt; location VARCHAR(50) NOT NULL;Query OK, 0 rows affected (0.15 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; DESC tb_dept4;+----------+-------------+------+-----+----------+-------+| Field | Type | Null | Key | Default | Extra |+----------+-------------+------+-----+----------+-------+| id | int(11) | NO | PRI | NULL | || name | varchar(22) | NO | | NULL | || location | varchar(50) | NO | | NULL | |+----------+-------------+------+-----+----------+-------+3 rows in set (0.00 sec) 删除非空约束修改表时删除非空约束的语法规则如下： 12ALTER TABLE &lt;数据表名&gt;CHANGE COLUMN &lt;字段名&gt; &lt;字段名&gt; &lt;数据类型&gt; NULL; 1234567891011121314mysql&gt; ALTER TABLE tb_dept4 -&gt; CHANGE COLUMN location -&gt; location VARCHAR(50) NULL;Query OK, 0 rows affected (0.15 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; DESC tb_dept4;+----------+-------------+------+-----+----------+-------+| Field | Type | Null | Key | Default | Extra |+----------+-------------+------+-----+----------+-------+| id | int(11) | NO | PRI | NULL | || name | varchar(22) | NO | | NULL | || location | varchar(50) | YES | | NULL | |+----------+-------------+------+-----+----------+-------+3 rows in set (0.00 sec) 查看表中的约束在 MySQL 中可以使用 SHOW CREATE TABLE 语句来查看表中的约束。 查看数据表中的约束语法格式如下： 1SHOW CREATE TABLE &lt;数据表名&gt;; 123456789101112131415161718192021222324mysql&gt; CREATE TABLE tb_emp8 -&gt; ( -&gt; id INT(11) PRIMARY KEY, -&gt; name VARCHAR(22) UNIQUE, -&gt; deptId INT(11) NOT NULL, -&gt; salary FLOAT DEFAULT 0, -&gt; CHECK(salary&gt;0), -&gt; FOREIGN KEY(deptId) REFERENCES tb_dept1(id) -&gt; );Query OK, 0 rows affected (0.37 sec)mysql&gt; SHOW CREATE TABLE tb_emp8 \G*************************** 1. row *************************** Table: tb_emp8Create Table: CREATE TABLE `tb_emp8` ( `id` int(11) NOT NULL, `name` varchar(22) DEFAULT NULL, `deptId` int(11) NOT NULL, `salary` float DEFAULT &apos;0&apos;, PRIMARY KEY (`id`), UNIQUE KEY `name` (`name`), KEY `deptId` (`deptId`), CONSTRAINT `tb_emp8_ibfk_1` FOREIGN KEY (`deptId`) REFERENCES `tb_dept1` (`id`)) ENGINE=InnoDB DEFAULT CHARSET=gb23121 row in set (0.19 sec) 数据表查询语句在 MySQL 中，可以使用 SELECT 语句来查询数据。查询数据是指从数据库中根据需求，使用不同的查询方式来获取不同的数据，是使用频率最高、最重要的操作。 SELECT 的语法格式如下： 12345678910SELECT&#123;* | &lt;字段列名&gt;&#125;[FROM &lt;表 1&gt;, &lt;表 2&gt;…[WHERE &lt;表达式&gt;[GROUP BY &lt;group by definition&gt;[HAVING &lt;expression&gt; [&#123;&lt;operator&gt; &lt;expression&gt;&#125;…]][ORDER BY &lt;order by definition&gt;][LIMIT[&lt;offset&gt;,] &lt;row count&gt;]] 其中，各条子句的含义如下： {*|&lt;字段列名&gt;}包含星号通配符的字段列表，表示所要查询字段的名称。 &lt;表 1&gt;，&lt;表 2&gt;…，表 1 和表 2 表示查询数据的来源，可以是单个或多个。 WHERE &lt;表达式&gt;是可选项，如果选择该项，将限定查询数据必须满足该查询条件。 GROUP BY&lt; 字段 &gt;，该子句告诉 MySQL 如何显示查询出来的数据，并按照指定的字段分组。 [ORDER BY&lt; 字段 &gt;]，该子句告诉 MySQL 按什么样的顺序显示查询出来的数据，可以进行的排序有升序（ASC）和降序（DESC），默认情况下是升序。 [LIMIT[&lt;offset&gt;，]&lt;row count&gt;]，该子句告诉 MySQL 每次显示查询出来的数据条数。 示例 1SELECT * FROM &lt; 表名 &gt;; 1SELECT &lt; 列名 &gt; FROM &lt; 表名 &gt;; 1SELECT &lt;字段名1&gt;,&lt;字段名2&gt;,…,&lt;字段名n&gt; FROM &lt;表名&gt;; 参考http://c.biancheng.net/mysql/]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[window mysql 初始化配置]]></title>
    <url>%2Fmysql%2Fck9bgz7nm004vqov7jcj2br7h.html</url>
    <content type="text"><![CDATA[mysql 下载地址https://dev.mysql.com/downloads/installer/ 注： msi安装包的就直接安装 ​ zip包的需要解压到特定地方然后配置系统变量的path路径，定位到mysql/bin目录下 配置环境变量将 mysql 安装路径下的bin目录添加至环境变量，例E:\mysql-5.7.21-winx64\bin 初始化 在mysql 安装路径下新建my.ini文件，添加一下内容： 123456789101112131415[mysql]# 设置mysql客户端默认字符集default-character-set=utf8 [mysqld]# 设置3306端口port = 3306# 设置mysql的安装目录basedir=E:\mysql-5.7.23# 允许最大连接数max_connections=20# 服务端使用的字符集默认为8比特编码的latin1字符集character-set-server=utf8# 创建新表时将使用的默认存储引擎default-storage-engine=INNODB 初始化mysql服务 123456mysqld --initialize-insecure # 这种方法初始化后没有设置密码，密码为空。mysqld --initialize # 这种方法初始化后会随机生成密码。mysqld -install # 安装mysql服务net start mysql # 启动服务net stop mysql # 停止服务。 修改密码 12345678910111213141516171819202122232425# mysql -u root -p # 登陆 mysqlEnter password: ****** # 输入密码，若初始化没有，则直接回车set password for &apos;root&apos;@&apos;localhost&apos;=password(&apos;123456&apos;); # 设置密码flush privileges;quit # 退出mysql,重新进入# 例C:\WINDOWS\system32&gt;mysql -u root -pEnter password: ******Welcome to the MySQL monitor. Commands end with ; or \g.Your MySQL connection id is 2Server version: 5.7.21 MySQL Community Server (GPL)Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.mysql&gt; set password for &apos;root&apos;@&apos;localhost&apos;=password(&apos;123456&apos;);Query OK, 0 rows affected, 1 warning (0.00 sec)mysql&gt; flush privileges;Query OK, 0 rows affected (0.01 sec) MySQL如何修改密码 MySQL设置密码的三种方法]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python itertools module]]></title>
    <url>%2Fpython%2Fmodule%2Fck9bgz86i00ggqov7tlnsaah9.html</url>
    <content type="text"><![CDATA[简介itertools 是python的迭代器模块，itertools提供的工具相当高效且节省内存 用法123&gt;&gt;&gt; import itertools&gt;&gt;&gt; dir(itertools)[&apos;__doc__&apos;, &apos;__loader__&apos;, &apos;__name__&apos;, &apos;__package__&apos;, &apos;__spec__&apos;, &apos;_grouper&apos;, &apos;_tee&apos;, &apos;_tee_dataobject&apos;, &apos;accumulate&apos;, &apos;chain&apos;, &apos;combinations&apos;, &apos;combinations_with_replacement&apos;, &apos;compress&apos;, &apos;count&apos;, &apos;cycle&apos;, &apos;dropwhile&apos;, &apos;filterfalse&apos;, &apos;groupby&apos;, &apos;islice&apos;, &apos;permutations&apos;, &apos;product&apos;, &apos;repeat&apos;, &apos;starmap&apos;, &apos;takewhile&apos;, &apos;tee&apos;, &apos;zip_longest&apos;] 无穷迭代器 迭代器 实参 结果 示例 count() start, [step] start, start+step, start+2*step, … count(10) --&gt; 10 11 12 13 14... cycle() p p0, p1, … plast, p0, p1, … cycle(&#39;ABCD&#39;) --&gt; A B C D A BC D ... repeat() elem [,n] elem, elem, elem, … 重复无限次或n次 repeat(10, 3) --&gt; 10 10 10 根据最短输入序列长度停止的迭代器 迭代器 实参 结果 示例 accumulate() p [,func] p0, p0+p1, p0+p1+p2, … accumulate([1,2,3,4,5]) --&gt; 1 36 10 15 chain() p, q, … p0, p1, … plast, q0, q1, … chain(&#39;ABC&#39;, &#39;DEF&#39;) --&gt; A B C DE F chain.from_iterable() iterable – 可迭代对象 p0, p1, … plast, q0, q1, … chain.from_iterable([&#39;ABC&#39;,&#39;DEF&#39;]) --&gt; A B C D E F compress() data, selectors (d[0] if s[0]), (d[1] if s[1]), … compress(&#39;ABCDEF&#39;,[1,0,1,0,1,1]) --&gt; A C E F dropwhile() pred, seq seq[n], seq[n+1], … 从pred首次真值测试失败开始 dropwhile(lambda x: x&lt;5,[1,4,6,4,1]) --&gt; 6 4 1 filterfalse() pred, seq seq中pred(x)为假值的元素，x是seq中的元素。 filterfalse(lambda x: x%2,range(10)) --&gt; 0 2 4 6 8 groupby() iterable[, key] 根据key(v)值分组的迭代器 islice() seq, [start,] stop [, step] seq[start:stop:step]中的元素 islice(&#39;ABCDEFG&#39;, 2, None) --&gt; CD E F G starmap() func, seq func(seq[0]), func(seq[1]), … starmap(pow, [(2,5), (3,2),(10,3)]) --&gt; 32 9 1000 takewhile() pred, seq seq[0], seq[1], …, 直到pred真值测试失败 takewhile(lambda x: x&lt;5,[1,4,6,4,1]) --&gt; 1 4 tee() it, n it1, it2, … itn 将一个迭代器拆分为n个迭代器 zip_longest() p, q, … (p[0], q[0]), (p[1], q[1]), … zip_longest(&#39;ABCD&#39;, &#39;xy&#39;,fillvalue=&#39;-&#39;) --&gt; Ax By C- D- 排列组合迭代器 迭代器 实参 结果 product() p, q, … [repeat=1] 笛卡尔积，相当于嵌套的for循环 permutations() p[, r] 长度r元组，所有可能的排列，无重复元素 combinations() p, r 长度r元组，有序，无重复元素 combinations_with_replacement() p, r 长度r元组，有序，元素可重复 product(&#39;ABCD&#39;, repeat=2) AA AB AC AD BA BB BC BD CA CB CC CD DA DBDC DD permutations(&#39;ABCD&#39;, 2) AB AC AD BA BC BD CA CB CD DA DB DC combinations(&#39;ABCD&#39;, 2) AB AC AD BC BD CD combinations_with_replacement(&#39;ABCD&#39;,2) AA AB AC AD BB BC BD CC CD DD itertools.count(start=0, step=1)创建一个迭代器，它从 start 值开始，返回均匀间隔的值。常用于 map() 中的实参来生成连续的数据点。此外，还用于 zip() 来添加序列号。大致相当于： 1234567def count(start=0, step=1): # count(10) --&gt; 10 11 12 13 14 ... # count(2.5, 0.5) -&gt; 2.5 3.0 3.5 ... n = start while True: yield n n += step 当对浮点数计数时，替换为乘法代码有时精度会更好，例如： (start + step * i for i in count()) 。 在 3.1 版更改: 增加参数 step ，允许非整型。 1234&gt;&gt;&gt; import itertools&gt;&gt;&gt; list(zip("abcd", itertools.count()))[('a', 0), ('b', 1), ('c', 2), ('d', 3)] itertools.cycle(iterable)创建一个迭代器，返回 iterable 中所有元素并保存一个副本。当取完 iterable 中所有元素，返回副本中的所有元素。无限重复。大致相当于： 123456789def cycle(iterable): # cycle(&apos;ABCD&apos;) --&gt; A B C D A B C D A B C D ... saved = [] for element in iterable: yield element saved.append(element) while saved: for element in saved: yield element 注意，该函数可能需要相当大的辅助空间（取决于 iterable 的长度）。 itertools.repeat(object[, times])创建一个迭代器，不断重复 object 。除非设定参数 times ，否则将无限重复。可用于 map() 函数中的参数，被调用函数可得到一个不变参数。也可用于 zip() 的参数以在元组记录中创建一个不变的部分。 大致相当于： 12345678def repeat(object, times=None): # repeat(10, 3) --&gt; 10 10 10 if times is None: while True: yield object else: for i in range(times): yield object repeat 最常见的用途就是在 map 或 zip 提供一个常量流： 12&gt;&gt;&gt; list(map(pow, range(10), repeat(2)))[0, 1, 4, 9, 16, 25, 36, 49, 64, 81] Itertool函数 itertools.accumulate(iterable[, func])创建一个迭代器，返回累加和或其他二元函数的累加结果（通过可选参数 func 指定）。如果提供了 func ，它应是2个参数的函数。输入 iterable 元素类型应是 func 能支持的任意类型。（例如，对于默认的加法操作，元素可以是任一支持加法的类型，包括 Decimal 或 Fraction ）。如果可迭代对象的输入为空，输出也为空。 大致相当于： 12345678910111213def accumulate(iterable, func=operator.add): &apos;Return running totals&apos; # accumulate([1,2,3,4,5]) --&gt; 1 3 6 10 15 # accumulate([1,2,3,4,5], operator.mul) --&gt; 1 2 6 24 120 it = iter(iterable) try: total = next(it) except StopIteration: return yield total for element in it: total = func(total, element) yield total func 参数有几种用法。它可以被设为 min() 最终得到一个最小值，或者设为 max() 最终得到一个最大值，或设为 operator.mul() 最终得到一个乘积。摊销表可通过累加利息和支付款项得到。给iterable设置初始值并只将参数 func 设为累加总数可以对一阶 递归关系 建模。 函数 functools.reduce() ，它只返回一个最终累积值 123456789101112131415161718192021&gt;&gt;&gt; data = [3, 4, 6, 2, 1, 9, 0, 7, 5, 8]&gt;&gt;&gt; list(accumulate(data, operator.mul)) # running product[3, 12, 72, 144, 144, 1296, 0, 0, 0, 0]&gt;&gt;&gt; list(accumulate(data, max)) # running maximum[3, 4, 6, 6, 6, 9, 9, 9, 9, 9]# Amortize a 5% loan of 1000 with 4 annual payments of 90&gt;&gt;&gt; cashflows = [1000, -90, -90, -90, -90]&gt;&gt;&gt; list(accumulate(cashflows, lambda bal, pmt: bal*1.05 + pmt))[1000, 960.0, 918.0, 873.9000000000001, 827.5950000000001]# Chaotic recurrence relation https://en.wikipedia.org/wiki/Logistic_map&gt;&gt;&gt; logistic_map = lambda x, _: r * x * (1 - x)&gt;&gt;&gt; r = 3.8&gt;&gt;&gt; x0 = 0.4&gt;&gt;&gt; inputs = repeat(x0, 36) # only the initial value is used&gt;&gt;&gt; [format(x, '.2f') for x in accumulate(inputs, logistic_map)]['0.40', '0.91', '0.30', '0.81', '0.60', '0.92', '0.29', '0.79', '0.63', '0.88', '0.39', '0.90', '0.33', '0.84', '0.52', '0.95', '0.18', '0.57', '0.93', '0.25', '0.71', '0.79', '0.63', '0.88', '0.39', '0.91', '0.32', '0.83', '0.54', '0.95', '0.20', '0.60', '0.91', '0.30', '0.80', '0.60'] itertools.chain(*iterables)创建一个迭代器，它首先返回第一个可迭代对象中所有元素，接着返回下一个可迭代对象中所有元素，直到耗尽所有可迭代对象中的元素。可将多个序列处理为单个序列。大致相当于： 12345def chain(*iterables): # chain(&apos;ABC&apos;, &apos;DEF&apos;) --&gt; A B C D E F for it in iterables: for element in it: yield element classmethod chain.from_iterable(iterable)构建类似 chain() 迭代器的另一个选择。从一个单独的可迭代参数中得到链式输入，该参数是延迟计算的。大致相当于： 12345def from_iterable(iterables): # chain.from_iterable(['ABC', 'DEF']) --&gt; A B C D E F for it in iterables: for element in it: yield element 12&gt;&gt;&gt; list(itertools.chain().from_iterable(["acd", "123"])) ['a', 'c', 'd', '1', '2', '3'] itertools.compress(data, selectors)创建一个迭代器，它返回 data 中经 selectors 真值测试为 True 的元素。迭代器在两者较短的长度处停止。大致相当于： 123def compress(data, selectors): # compress(&apos;ABCDEF&apos;, [1,0,1,0,1,1]) --&gt; A C E F return (d for d, s in zip(data, selectors) if s) itertools.dropwhile(predicate, iterable)创建一个迭代器，如果 predicate 为true，迭代器丢弃这些元素，然后返回其他元素。注意，迭代器在 predicate 首次为false之前不会产生任何输出，所以可能需要一定长度的启动时间。大致相当于： 123456789def dropwhile(predicate, iterable): # dropwhile(lambda x: x&lt;5, [1,4,6,4,1]) --&gt; 6 4 1 iterable = iter(iterable) for x in iterable: if not predicate(x): yield x break for x in iterable: yield x itertools.filterfalse(predicate, iterable)创建一个迭代器，只返回 iterable 中 predicate 为 False 的元素。如果 predicate 是 None，返回真值测试为false的元素。大致相当于： 1234567def filterfalse(predicate, iterable): # filterfalse(lambda x: x%2, range(10)) --&gt; 0 2 4 6 8 if predicate is None: predicate = bool for x in iterable: if not predicate(x): yield x itertools.groupby(iterable, key=None)创建一个迭代器，返回 iterable 中连续的键和组。key 是一个计算元素键值函数。如果未指定或为 None，key 缺省为恒等函数（identity function），返回元素不变。一般来说，iterable 需用同一个键值函数预先排序。 groupby() 操作类似于Unix中的 uniq。当每次 key 函数产生的键值改变时，迭代器会分组或生成一个新组（这就是为什么通常需要使用同一个键值函数先对数据进行排序）。这种行为与SQL的GROUP BY操作不同，SQL的操作会忽略输入的顺序将相同键值的元素分在同组中。 返回的组本身也是一个迭代器，它与 groupby() 共享底层的可迭代对象。因为源是共享的，当 groupby() 对象向后迭代时，前一个组将消失。因此如果稍后还需要返回结果，可保存为列表： 123456groups = []uniquekeys = []data = sorted(data, key=keyfunc)for k, g in groupby(data, keyfunc): groups.append(list(g)) # Store group iterator as a list uniquekeys.append(k) 12345678import randomlst = [random.randint(20) for x in range(10)]def fn(num): return "&gt;10" if num &gt; 10 else "&lt;=10"rst = [(k, list(v)) for k, v initertools.groupby(sorted(lst), key=fn)] itertools.islice(iterable, stop)itertools.islice(iterable, start, stop[, step])创建一个迭代器，返回从 iterable 里选中的元素。如果 start 不是0，跳过 iterable 中的元素，直到到达 start 这个位置。之后迭代器连续返回元素，除非 step 设置的值很高导致被跳过。如果 stop 为 None，迭代器耗光为止；否则，在指定的位置停止。与普通的切片不同，islice() 不支持将 start ， stop ，或 step 设为负值。可用来从内部数据结构被压平的数据中提取相关字段（例如一个多行报告，它的名称字段出现在每三行上）。大致相当于： 123456789101112131415161718192021222324def islice(iterable, *args): # islice(&apos;ABCDEFG&apos;, 2) --&gt; A B # islice(&apos;ABCDEFG&apos;, 2, 4) --&gt; C D # islice(&apos;ABCDEFG&apos;, 2, None) --&gt; C D E F G # islice(&apos;ABCDEFG&apos;, 0, None, 2) --&gt; A C E G s = slice(*args) start, stop, step = s.start or 0, s.stop or sys.maxsize, s.step or 1 it = iter(range(start, stop, step)) try: nexti = next(it) except StopIteration: # Consume *iterable* up to the *start* position. for i, element in zip(range(start), iterable): pass return try: for i, element in enumerate(iterable): if i == nexti: yield element nexti = next(it) except StopIteration: # Consume to *stop*. for i, element in zip(range(i + 1, stop), iterable): pass 如果 start 为 None，迭代从0开始。如果 step 为 None ，步长缺省为1。 itertools.starmap(function, iterable)创建一个迭代器，使用从可迭代对象中获取的参数来计算该函数。当参数对应的形参已从一个单独可迭代对象组合为元组时（数据已被“预组对”）可用此函数代替 map()。map() 与 starmap() 之间的区别可以类比 function(a,b) 与 function(*c) 的区别。大致相当于: 1234def starmap(function, iterable): # starmap(pow, [(2,5), (3,2), (10,3)]) --&gt; 32 9 1000 for args in iterable: yield function(*args) itertools.takewhile(predicate, iterable)创建一个迭代器，只要 predicate 为真就从可迭代对象中返回元素。大致相当于: 1234567def takewhile(predicate, iterable): # takewhile(lambda x: x&lt;5, [1,4,6,4,1]) --&gt; 1 4 for x in iterable: if predicate(x): yield x else: break itertools.tee(iterable, n=2)从一个可迭代对象中返回 n 个独立的迭代器。 下面的Python代码能帮助解释 tee 做了什么（尽管实际的实现更复杂，而且仅使用了一个底层的 FIFO 队列）。 大致相当于： 1234567891011121314def tee(iterable, n=2): it = iter(iterable) deques = [collections.deque() for i in range(n)] def gen(mydeque): while True: if not mydeque: # when the local deque is empty try: newval = next(it) # fetch a new value and except StopIteration: return for d in deques: # load it to all the deques d.append(newval) yield mydeque.popleft() return tuple(gen(d) for d in deques) 一旦 tee() 实施了一次分裂，原有的 iterable 不应再被使用；否则tee对象无法得知 iterable 可能已向后迭代。 tee 迭代器不是线程安全的。当同时使用由同一个 tee() 调用所返回的迭代器时可能引发 RuntimeError，即使原本的 iterable 是线程安全的。 该迭代工具可能需要相当大的辅助存储空间（这取决于要保存多少临时数据）。通常，如果一个迭代器在另一个迭代器开始之前就要使用大部份或全部数据，使用 list() 会比 tee() 更快。 itertools.zip_longest(iterables, fillvalue=None)创建一个迭代器，从每个可迭代对象中收集元素。如果可迭代对象的长度未对齐，将根据 fillvalue 填充缺失值。迭代持续到耗光最长的可迭代对象。大致相当于： 12345678910111213141516171819def zip_longest(*args, fillvalue=None): # zip_longest(&apos;ABCD&apos;, &apos;xy&apos;, fillvalue=&apos;-&apos;) --&gt; Ax By C- D- iterators = [iter(it) for it in args] num_active = len(iterators) if not num_active: return while True: values = [] for i, it in enumerate(iterators): try: value = next(it) except StopIteration: num_active -= 1 if not num_active: return iterators[i] = repeat(fillvalue) value = fillvalue values.append(value) yield tuple(values) 如果其中一个可迭代对象有无限长度，zip_longest() 函数应封装在限制调用次数的场景中（例如 islice() 或 takewhile()）。除非指定， fillvalue 默认为 None 。 排列组合迭代器： itertools.product(*iterables, repeat=1)可迭代对象输入的笛卡儿积。 大致相当于生成器表达式中的嵌套循环。例如， product(A, B) 和 ((x,y) for x in A for y in B) 返回结果一样。 嵌套循环像里程表那样循环变动，每次迭代时将最右侧的元素向后迭代。这种模式形成了一种字典序，因此如果输入的可迭代对象是已排序的，笛卡尔积元组依次序发出。 要计算可迭代对象自身的笛卡尔积，将可选参数 repeat 设定为要重复的次数。例如，product(A, repeat=4) 和 product(A, A, A, A) 是一样的。 该函数大致相当于下面的代码，只不过实际实现方案不会在内存中创建中间结果。 123456789def product(*args, repeat=1): # product('ABCD', 'xy') --&gt; Ax Ay Bx By Cx Cy Dx Dy # product(range(2), repeat=3) --&gt; 000 001 010 011 100 101 110 111 pools = [tuple(pool) for pool in args] * repeat result = [[]] for pool in pools: result = [x+[y] for x in result for y in pool] for prod in result: yield tuple(prod) itertools.permutations(iterable, r=None)连续返回由 iterable 元素生成长度为 r 的排列。 如果 r 未指定或为 None ，r 默认设置为 iterable 的长度，这种情况下，生成所有全长排列。 排列依字典序发出。因此，如果 iterable 是已排序的，排列元组将有序地产出。 即使元素的值相同，不同位置的元素也被认为是不同的。如果元素值都不同，每个排列中的元素值不会重复。 大致相当于： 123456789101112131415161718192021222324def permutations(iterable, r=None): # permutations(&apos;ABCD&apos;, 2) --&gt; AB AC AD BA BC BD CA CB CD DA DB DC # permutations(range(3)) --&gt; 012 021 102 120 201 210 pool = tuple(iterable) n = len(pool) r = n if r is None else r if r &gt; n: return indices = list(range(n)) cycles = list(range(n, n-r, -1)) yield tuple(pool[i] for i in indices[:r]) while n: for i in reversed(range(r)): cycles[i] -= 1 if cycles[i] == 0: indices[i:] = indices[i+1:] + indices[i:i+1] cycles[i] = n - i else: j = cycles[i] indices[i], indices[-j] = indices[-j], indices[i] yield tuple(pool[i] for i in indices[:r]) break else: return permutations() 的代码也可被改写为 product() 的子序列，只要将含有重复元素（来自输入中同一位置的）的项排除。 1234567def permutations(iterable, r=None): pool = tuple(iterable) n = len(pool) r = n if r is None else r for indices in product(range(n), repeat=r): if len(set(indices)) == r: yield tuple(pool[i] for i in indices) 当 0 &lt;= r &lt;= n ，返回项个数为 n! / (n-r)! ；当 r &gt; n ，返回项个数为0。 itertools.combinations(iterable, r)返回由输入 iterable 中元素组成长度为 r 的子序列。 组合按照字典序返回。所以如果输入 iterable 是有序的，生成的组合元组也是有序的。 即使元素的值相同，不同位置的元素也被认为是不同的。如果元素各自不同，那么每个组合中没有重复元素。 大致相当于： 12345678910111213141516171819def combinations(iterable, r): # combinations(&apos;ABCD&apos;, 2) --&gt; AB AC AD BC BD CD # combinations(range(4), 3) --&gt; 012 013 023 123 pool = tuple(iterable) n = len(pool) if r &gt; n: return indices = list(range(r)) yield tuple(pool[i] for i in indices) while True: for i in reversed(range(r)): if indices[i] != i + n - r: break else: return indices[i] += 1 for j in range(i+1, r): indices[j] = indices[j-1] + 1 yield tuple(pool[i] for i in indices) combinations() 的代码可被改写为 permutations() 过滤后的子序列，（相对于元素在输入中的位置）元素不是有序的。 123456def combinations(iterable, r): pool = tuple(iterable) n = len(pool) for indices in permutations(range(n), r): if sorted(indices) == list(indices): yield tuple(pool[i] for i in indices) 当 0 &lt;= r &lt;= n 时，返回项的个数是 n! / r! / (n-r)!；当 r &gt; n 时，返回项个数为0。 itertools.combinations_with_replacement(iterable, r)返回由输入 iterable 中元素组成的长度为 r 的子序列，允许每个元素可重复出现。 组合按照字典序返回。所以如果输入 iterable 是有序的，生成的组合元组也是有序的。 不同位置的元素是不同的，即使它们的值相同。因此如果输入中的元素都是不同的话，返回的组合中元素也都会不同。 大致相当于： 12345678910111213141516def combinations_with_replacement(iterable, r): # combinations_with_replacement(&apos;ABC&apos;, 2) --&gt; AA AB AC BB BC CC pool = tuple(iterable) n = len(pool) if not n and r: return indices = [0] * r yield tuple(pool[i] for i in indices) while True: for i in reversed(range(r)): if indices[i] != n - 1: break else: return indices[i:] = [indices[i] + 1] * (r - i) yield tuple(pool[i] for i in indices) combinations_with_replacement() 的代码可被改写为 production() 过滤后的子序列，（相对于元素在输入中的位置）元素不是有序的。 123456def combinations_with_replacement(iterable, r): pool = tuple(iterable) n = len(pool) for indices in product(range(n), repeat=r): if sorted(indices) == list(indices): yield tuple(pool[i] for i in indices) 当 n &gt; 0 时，返回项个数为 (n+r-1)! / r! / (n-1)!. Referencehttps://docs.python.org/zh-cn/3.7/library/itertools.html#itertools.islice]]></content>
      <categories>
        <category>python</category>
        <category>module</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>module</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker参数说明]]></title>
    <url>%2Fdocker%2Fck9bgz7qv007nqov786dtnoqh.html</url>
    <content type="text"><![CDATA[Docker 命令参数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081[root@hadoop01 ~]# dockerUsage: docker [OPTIONS] COMMANDA self-sufficient runtime for containersOptions: --config string Location of client config files (default &quot;/root/.docker&quot;) -c, --context string Name of the context to use to connect to the daemon (overrides DOCKER_HOST env var and default context set with &quot;docker context use&quot;) -D, --debug Enable debug mode -H, --host list Daemon socket(s) to connect to -l, --log-level string Set the logging level (&quot;debug&quot;|&quot;info&quot;|&quot;warn&quot;|&quot;error&quot;|&quot;fatal&quot;) (default &quot;info&quot;) --tls Use TLS; implied by --tlsverify --tlscacert string Trust certs signed only by this CA (default &quot;/root/.docker/ca.pem&quot;) --tlscert string Path to TLS certificate file (default &quot;/root/.docker/cert.pem&quot;) --tlskey string Path to TLS key file (default &quot;/root/.docker/key.pem&quot;) --tlsverify Use TLS and verify the remote -v, --version Print version information and quitManagement Commands: builder Manage builds config Manage Docker configs container Manage containers context Manage contexts engine Manage the docker engine image Manage images network Manage networks node Manage Swarm nodes plugin Manage plugins secret Manage Docker secrets service Manage services stack Manage Docker stacks swarm Manage Swarm system Manage Docker trust Manage trust on Docker images volume Manage volumesCommands: attach Attach local standard input, output, and error streams to a running container build Build an image from a Dockerfile commit Create a new image from a container&apos;s changes cp Copy files/folders between a container and the local filesystem create Create a new container diff Inspect changes to files or directories on a container&apos;s filesystem events Get real time events from the server exec Run a command in a running container export Export a container&apos;s filesystem as a tar archive history Show the history of an image images List images import Import the contents from a tarball to create a filesystem image info Display system-wide information inspect Return low-level information on Docker objects kill Kill one or more running containers load Load an image from a tar archive or STDIN login Log in to a Docker registry logout Log out from a Docker registry logs Fetch the logs of a container pause Pause all processes within one or more containers port List port mappings or a specific mapping for the container ps List containers pull Pull an image or a repository from a registry push Push an image or a repository to a registry rename Rename a container restart Restart one or more containers rm Remove one or more containers rmi Remove one or more images run Run a command in a new container save Save one or more images to a tar archive (streamed to STDOUT by default) search Search the Docker Hub for images start Start one or more stopped containers stats Display a live stream of container(s) resource usage statistics stop Stop one or more running containers tag Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE top Display the running processes of a container unpause Unpause all processes within one or more containers update Update configuration of one or more containers version Show the Docker version information wait Block until one or more containers stop, then print their exit codesRun &apos;docker COMMAND --help&apos; for more information on a command. Docker配置文件Ｄocker 的配置文件可以设置大部分的后台进程参数，文件路径： ubuntu 中的位置：/etc/default/docker/daemon.json centos6 中的位置：/etc/sysconfig/docker/daemon.json centos7 中的位置：/etc/docker/daemon.json 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&#123; &quot;authorization-plugins&quot;: [],//访问授权插件 &quot;data-root&quot;: &quot;&quot;,//docker数据持久化存储的根目录 &quot;dns&quot;: [],//DNS服务器 &quot;dns-opts&quot;: [],//DNS配置选项，如端口等 &quot;dns-search&quot;: [],//DNS搜索域名 &quot;exec-opts&quot;: [],//执行选项 &quot;exec-root&quot;: &quot;&quot;,//执行状态的文件的根目录 &quot;experimental&quot;: false,//是否开启试验性特性 &quot;storage-driver&quot;: &quot;&quot;,//存储驱动器 &quot;storage-opts&quot;: [],//存储选项 &quot;labels&quot;: [],//键值对式标记docker元数据 &quot;live-restore&quot;: true,//dockerd挂掉是否保活容器（避免了docker服务异常而造成容器退出） &quot;log-driver&quot;: &quot;&quot;,//容器日志的驱动器 &quot;log-opts&quot;: &#123;&#125;,//容器日志的选项 &quot;mtu&quot;: 0,//设置容器网络MTU（最大传输单元） &quot;pidfile&quot;: &quot;&quot;,//daemon PID文件的位置 &quot;cluster-store&quot;: &quot;&quot;,//集群存储系统的URL &quot;cluster-store-opts&quot;: &#123;&#125;,//配置集群存储 &quot;cluster-advertise&quot;: &quot;&quot;,//对外的地址名称 &quot;max-concurrent-downloads&quot;: 3,//设置每个pull进程的最大并发 &quot;max-concurrent-uploads&quot;: 5,//设置每个push进程的最大并发 &quot;default-shm-size&quot;: &quot;64M&quot;,//设置默认共享内存的大小 &quot;shutdown-timeout&quot;: 15,//设置关闭的超时时限(who?) &quot;debug&quot;: true,//开启调试模式 &quot;hosts&quot;: [],//监听地址(?) &quot;log-level&quot;: &quot;&quot;,//日志级别 &quot;tls&quot;: true,//开启传输层安全协议TLS &quot;tlsverify&quot;: true,//开启输层安全协议并验证远程地址 &quot;tlscacert&quot;: &quot;&quot;,//CA签名文件路径 &quot;tlscert&quot;: &quot;&quot;,//TLS证书文件路径 &quot;tlskey&quot;: &quot;&quot;,//TLS密钥文件路径 &quot;swarm-default-advertise-addr&quot;: &quot;&quot;,//swarm对外地址 &quot;api-cors-header&quot;: &quot;&quot;,//设置CORS（跨域资源共享-Cross-origin resource sharing）头 &quot;selinux-enabled&quot;: false,//开启selinux(用户、进程、应用、文件的强制访问控制) &quot;userns-remap&quot;: &quot;&quot;,//给用户命名空间设置 用户/组 &quot;group&quot;: &quot;&quot;,//docker所在组 &quot;cgroup-parent&quot;: &quot;&quot;,//设置所有容器的cgroup的父类(?) &quot;default-ulimits&quot;: &#123;&#125;,//设置所有容器的ulimit &quot;init&quot;: false,//容器执行初始化，来转发信号或控制(reap)进程 &quot;init-path&quot;: &quot;/usr/libexec/docker-init&quot;,//docker-init文件的路径 &quot;ipv6&quot;: false,//开启IPV6网络 &quot;iptables&quot;: false,//开启防火墙规则 &quot;ip-forward&quot;: false,//开启net.ipv4.ip_forward &quot;ip-masq&quot;: false,//开启ip掩蔽(IP封包通过路由器或防火墙时重写源IP地址或目的IP地址的技术) &quot;userland-proxy&quot;: false,//用户空间代理 &quot;userland-proxy-path&quot;: &quot;/usr/libexec/docker-proxy&quot;,//用户空间代理路径 &quot;ip&quot;: &quot;0.0.0.0&quot;,//默认IP &quot;bridge&quot;: &quot;&quot;,//将容器依附(attach)到桥接网络上的桥标识 &quot;bip&quot;: &quot;&quot;,//指定桥接ip &quot;fixed-cidr&quot;: &quot;&quot;,//(ipv4)子网划分，即限制ip地址分配范围，用以控制容器所属网段实现容器间(同一主机或不同主机间)的网络访问 &quot;fixed-cidr-v6&quot;: &quot;&quot;,//（ipv6）子网划分 &quot;default-gateway&quot;: &quot;&quot;,//默认网关 &quot;default-gateway-v6&quot;: &quot;&quot;,//默认ipv6网关 &quot;icc&quot;: false,//容器间通信 &quot;raw-logs&quot;: false,//原始日志(无颜色、全时间戳) &quot;allow-nondistributable-artifacts&quot;: [],//不对外分发的产品提交的registry仓库 &quot;registry-mirrors&quot;: [],//registry仓库镜像 &quot;seccomp-profile&quot;: &quot;&quot;,//seccomp配置文件 &quot;insecure-registries&quot;: [],//非https的registry地址 &quot;no-new-privileges&quot;: false,//禁止新优先级(??) &quot;default-runtime&quot;: &quot;runc&quot;,//OCI联盟(The Open Container Initiative)默认运行时环境 &quot;oom-score-adjust&quot;: -500,//内存溢出被杀死的优先级(-1000~1000) &quot;node-generic-resources&quot;: [&quot;NVIDIA-GPU=UUID1&quot;, &quot;NVIDIA-GPU=UUID2&quot;],//对外公布的资源节点 &quot;runtimes&quot;: &#123;//运行时 &quot;cc-runtime&quot;: &#123; &quot;path&quot;: &quot;/usr/bin/cc-runtime&quot; &#125;, &quot;custom&quot;: &#123; &quot;path&quot;: &quot;/usr/local/bin/my-runc-replacement&quot;, &quot;runtimeArgs&quot;: [ &quot;--debug&quot; ] &#125; &#125;&#125; 参考docker 各种参数配置 docker 的常用参数和解析]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spark参数配置说明]]></title>
    <url>%2Fpython%2Fspark%2Fck9bgz7yx009iqov7ddn164zu.html</url>
    <content type="text"><![CDATA[spark配置修改方式Spark有以下三种方式修改配置： Spark properties （Spark属性） 可以控制绝大多数应用程序参数，而且既可以通过 SparkConf 对象来设置，也可以通过Java系统属性来设置。 Environment variables （环境变量） 可以指定一些各个机器相关的设置，如IP地址，其设置方法是写在每台机器上的conf/spark-env.sh中。 Logging （日志） 可以通过log4j.properties配置日志。 spark配置参数官方链接：https://spark.apache.org/docs/latest/configuration.html 其它参考：http://ifeve.com/spark-config/]]></content>
      <categories>
        <category>python</category>
        <category>spark</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>spark</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spark异常处理]]></title>
    <url>%2Fspark%2Fck9bgz7z1009lqov7vs1lkqr2.html</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>spark</category>
      </categories>
      <tags>
        <tag>spark</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spark web 用法]]></title>
    <url>%2Fspark%2Fck9bgz83e00dkqov7pvdm4s4g.html</url>
    <content type="text"><![CDATA[修改spark默认启动端口123456789101112131415161718192021228080 --&gt; master WEB端口8081 --&gt; work WEB端口7077 --&gt; master通信端口18080 --&gt; spark历史服务器端口4040 --&gt; Spark当前执行的任务页面查看端口4040，如果任务结束了4040端口页面不能访问50070：HDFSwebUI的端口号8485:journalnode默认的端口号9000：非高可用访问数rpc端口8020：高可用访问数据rpc8088：yarn的webUI的端口号8080：master的webUI，Tomcat的端口号7077：spark基于standalone的提交任务的端口号8081：worker的webUI的端口号18080：historyServer的webUI的端口号4040：application的webUI的端口号2181：zookeeper的rpc端口号9083：hive的metastore的端口号60010：Hbase的webUI的端口号6379：Redis的端口号8080：sparkwebUI的端口号9092：kafka broker的端口 修改默认端口在 standalone模式中配置spark-env.sh 12345678# Master节点的web端口是8080 export SPARK_MASTER_WEBUI_PORT=8080# work节点的web端口是8081export SPARK_WORKER_WEBUI_PORT=8081# Master通信端口是7077export SPARK_MASTER_PORT=7077 在 standalone模式中配置spark-defaults.confspark-env.sh 123456789# Spark历史服务器端口是18080spark.history.ui.port 18080# Spark外部服务端口是6066，这个端口有被黑客攻击的漏洞建议关闭spark.master.rest.enabled falsespark.master.rest.port 16066# Spark当前执行的任务页面查看端口4040spark.ui.port 14040 Spark Web UI详解默认登陆URL1http://&#123;spark_ip&#125;:4040/jobs/ jobs页面 User: spark任务提交的用户，用以进行权限控制与资源分配。 Total Uptime: spark application总的运行时间，从app master开始运行到结束的整体时间。 Scheduling Mode: application中task任务的调度策略，由参数spark.scheduler.mode来设置，可选的参数有FAIR和FIFO，默认是FIFO。这与yarn的资源调度策略的层级不同，yarn的资源调度是针对集群中不同application间的，而spark scheduler mode则是针对application内部task set级别的资源分配，不同FAIR策略的参数配置方式与yarn中FAIR策略的配置方式相同。 Active Jobs: 正在运行的Job的基本信息。 Event Timeline: 在application应用运行期间，Job和Exector的增加和删除事件进行图形化的展现。这个就是用来表示调度job何时启动何时结束，以及Excutor何时加入何时移除。我们可以很方便看到哪些job已经运行完成，使用了多少Excutor，哪些正在运行。 Completed Jobs: 已完成Job的基本信息，如想查看某一个Job的详细情况，可点击对应Job进行查看。 注：Job默认都是串行提交运行的，如果Job间没有依赖，可以使用多线程并行提交Job，实现Job并发。 Jobs Detail页面 在Jobs页面点击进入某个Job之后，可以查看某一Job的详细信息： Staus: 展示Job的当前状态信息。 Active Stages: 正在运行的stages信息，点击某个stage可进入查看具体的stage信息。 Pending Stages: 排队的stages信息，根据解析的DAG图stage可并发提交运行，而有依赖的stage未运行完时则处于等待队列中。 Completed Stages: 已经完成的stages信息。 Event Timeline: 展示当前Job运行期间stage的提交与结束、Executor的加入与退出等事件信息。 DAG Visualization: 当前Job所包含的所有stage信息（stage中包含的明细的tranformation操作），以及各stage间的DAG依赖图。DAG也是一种调度模型，在spark的作业调度中，有很多作业存在依赖关系，所以没有依赖关系的作业可以并行执行，有依赖的作业不能并行执行。 Stages页面 在Job Detail页点击进入某个stage后，可以查看某一stage的详细信息： Total time across all tasks: 当前stage中所有task花费的时间和。 Locality Level Summary: 不同本地化级别下的任务数，本地化级别是指数据与计算间的关系（PROCESS_LOCAL进程本地化：task与计算的数据在同一个Executor中。NODE_LOCAL节点本地化：情况一：task要计算的数据是在同一个Worker的不同Executor进程中；情况二：task要计算的数据是在同一个Worker的磁盘上，或在 HDFS 上，恰好有 block 在同一个节点上。RACK_LOCAL机架本地化，数据在同一机架的不同节点上：情况一：task计算的数据在Worker2的Executor中；情况二：task计算的数据在Worker2的磁盘上。ANY跨机架，数据在非同一机架的网络上，速度最慢）。 Input Size/Records: 输入的数据字节数大小/记录条数。 Shuffle Write: 为下一个依赖的stage提供输入数据，shuffle过程中通过网络传输的数据字节数/记录条数。应该尽量减少shuffle的数据量及其操作次数，这是spark任务优化的一条基本原则。 DAG Visualization: 当前stage中包含的详细的tranformation操作流程图。 Metrics: 当前stage中所有task的一些指标（每一指标项鼠标移动上去后会有对应解释信息）统计信息。 Event Timeline: 清楚地展示在每个Executor上各个task的各个阶段的时间统计信息，可以清楚地看到task任务时间是否有明显倾斜，以及倾斜的时间主要是属于哪个阶段，从而有针对性的进行优化。 Aggregated Metrics by Executor: 将task运行的指标信息按excutor做聚合后的统计信息，并可查看某个Excutor上任务运行的日志信息。 Tasks: 当前stage中所有任务运行的明细信息，是与Event Timeline中的信息对应的文字展示（可以点击某个task查看具体的任务日志）。 Storage页面 storage页面能看出application当前使用的缓存情况，可以看到有哪些RDD被缓存了，以及占用的内存资源。如果job在执行时持久化（persist）/缓存（cache）了一个RDD，那么RDD的信息可以在这个选项卡中查看。 Storage Detail页面 点击某个RDD即可查看该RDD缓存的详细信息，包括缓存在哪个Executor中，使用的block情况，RDD上分区（partitions）的信息以及存储RDD的主机的地址。 Enviroment页面Environment选项卡提供有关Spark应用程序（或SparkContext）中使用的各种属性和环境变量的信息。用户可以通过这个选项卡得到非常有用的各种Spark属性信息，而不用去翻找属性配置文件。 Executor页面Executors选项卡提供了关于内存、CPU核和其他被Executors使用的资源的信息。这些信息在Executor级别和汇总级别都可以获取到。一方面通过它可以看出来每个excutor是否发生了数据倾斜，另一方面可以具体分析目前的应用是否产生了大量的shuffle，是否可以通过数据的本地性或者减小数据的传输来减少shuffle的数据量。 Summary: 该application运行过程中使用Executor的统计信息。Executors: 每个Excutor的详细信息（包含driver），可以点击查看某个Executor中任务运行的详细日志。 SQL页面SQL选项卡（只有执行了spark SQL查询才会有SQL选项卡）可以查看SQL执行计划的细节，它提供了SQL查询的DAG以及显示Spark如何优化已执行的SQL查询的查询计划。 参考spark的UI界面及调优 https://www.jianshu.com/p/8143a50a5af9 https://blog.csdn.net/minge_se/article/details/79146737]]></content>
      <categories>
        <category>spark</category>
      </categories>
      <tags>
        <tag>spark</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python io module]]></title>
    <url>%2Fpython%2Fmodule%2Fck9bgz7zp00a2qov735jnodl5.html</url>
    <content type="text"><![CDATA[参考：python3之模块io使用流的核心工具]]></content>
      <categories>
        <category>python</category>
        <category>module</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>module</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker mysql官方镜像操作]]></title>
    <url>%2Fdocker%2Fck9bgz7lt003aqov72fw47one.html</url>
    <content type="text"><![CDATA[… 拉取镜像123456[root@hadoop01 ~]# docker pull mysql# 查看镜像[root@hadoop01 ~]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEmysql latest b8fd9553f1f0 4 weeks ago 445MB 生成容器1234567891011121314[root@hadoop01 ~]# docker run -d -p 3307:3306 --name mysql -P -e mysqld -e MYSQL_ROOT_PASSWORD=123456 -e MYSQL_USER=yope -e MYSQL_PASSWORD=yope -e MYSQL_DATABASE=testDb -v /mysql_data:/var/lib/mysql mysql参数说明: -d 后台运行容器，并返回容器ID； -P 随机端口映射，容器内部端口随机映射到主机的高端口 -p 3307:3306 映射端口,将容器3306端口映射到宿主机端口3307； --name mysql 指定容器名称为 mysql； -v /mysql_data:/var/lib/mysql 映射数据库存放位置。将宿主机的目录“/mysql_data”映射到容器的“/var/lib/mysql”目录； -e 设置环境变量；# 查看容器[root@hadoop01 mysql_data]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESc72ef1ca7166 mysql &quot;docker-entrypoint.s…&quot; 9 minutes ago Up 8 minutes 0.0.0.0:3307-&gt;3306/tcp, 0.0.0.0:32768-&gt;33060/tcp mysql]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker构建流程]]></title>
    <url>%2Fdocker%2Fck9bgz7m7003mqov7d36b3o3g.html</url>
    <content type="text"><![CDATA[docker构建镜像1docker build -t spark_clu:1.0.0 . 语法： ​ docker build [OPTIONS] PATH | URL | - 常用OPTIONS参数： ​ -f :指定要使用的Dockerfile路径； ​ –force-rm :设置镜像过程中删除中间容器； ​ -m :设置内存最大值； ​ –no-cache :创建镜像的过程不使用缓存； ​ –pull :尝试去更新镜像的新版本； ​ –quiet, -q :安静模式，成功后只输出镜像 ID； ​ –rm :设置镜像成功后删除中间容器； ​ –tag, -t: 镜像的名字及标签，通常 name:tag 或者 name 格式；可以在一次构建中为一个镜像设置多个标签。 ​ –network: 默认 default。在构建期间设置RUN指令的网络模式 Docker build 命令 docker存储镜像12docker save -o spark_clu.tar spark_clu:1.0.0gzip spark_clu.tar # spark_clu.tar.gz 语法： ​ docker save [OPTIONS] IMAGE [IMAGE…] OPTIONS选项 ​ -o :输出到的文件。 docker删除镜像1docker rmi -f spark_clu:1.0.0 语法： ​ docker rmi [OPTIONS] IMAGE [IMAGE…] OPTIONS选项： ​ -f :强制删除； ​ –no-prune :不移除该镜像的过程镜像，默认移除； docker载入镜像1docker load -i spark_clu.tar.gz 语法： ​ docker load [OPTIONS] OPTIONS 选项： ​ –input , -i : 指定导入的文件，代替 STDIN。 ​ –quiet , -q : 精简输出信息。]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker命令操作]]></title>
    <url>%2Fdocker%2Fck9bgz7m3003iqov7p1e6166w.html</url>
    <content type="text"><![CDATA[查看docker版本12[root@hadoop01 ~]# docker -vDocker version 19.03.3, build a872fc2f86 列出本机的所有 image 文件123[root@hadoop01 ~]# docker images -aREPOSITORY TAG IMAGE ID CREATED SIZEhello-world latest fce289e99eb9 9 months ago 1.84kB 运行容器12345[root@hadoop01 ~]# docker container run hello-worldHello from Docker!This message shows that your installation appears to be working correctly....... 结束容器123[root@hadoop01 ~]# docker container kill [container_id]注：通过 docker ps 可查看container_id 镜像相关的操作123456789101112131415161718[root@hadoop01 koa-demos]# docker image --helpUsage: docker image COMMANDManage imagesCommands: build Build an image from a Dockerfile history Show the history of an image import Import the contents from a tarball to create a filesystem image inspect Display detailed information on one or more images load Load an image from a tar archive or STDIN ls List images prune Remove unused images pull Pull an image or a repository from a registry push Push an image or a repository to a registry rm Remove one or more images save Save one or more images to a tar archive (streamed to STDOUT by default) tag Create a tag TARGET_IMAGE that refers to SOURCE_IMAGERun &apos;docker image COMMAND --help&apos; for more information on a command. 容器相关的操作12345678910111213141516171819202122232425262728293031[root@hadoop01 ~]# docker container --helpUsage: docker container COMMANDManage containersCommands: attach Attach local standard input, output, and error streams to a running container commit Create a new image from a container&apos;s changes cp Copy files/folders between a container and the local filesystem create Create a new container diff Inspect changes to files or directories on a container&apos;s filesystem exec Run a command in a running container export Export a container&apos;s filesystem as a tar archive inspect Display detailed information on one or more containers kill Kill one or more running containers logs Fetch the logs of a container ls List containers pause Pause all processes within one or more containers port List port mappings or a specific mapping for the container prune Remove all stopped containers rename Rename a container restart Restart one or more containers rm Remove one or more containers run Run a command in a new container start Start one or more stopped containers stats Display a live stream of container(s) resource usage statistics stop Stop one or more running containers top Display the running processes of a container unpause Unpause all processes within one or more containers update Update configuration of one or more containers wait Block until one or more containers stop, then print their exit codesRun &apos;docker container COMMAND --help&apos; for more information on a command. 示例以 koa-demos 项目为例 下载源代码 12[root@hadoop01 ~]# git clone https://github.com/ruanyf/koa-demos.git[root@hadoop01 ~]# cd koa-demos 编写 Dockerfile 文件 1234[root@hadoop01 ~]# mkdir .dockerignore添加.git、node_modules、npm-debug.log文件到.dockerignore.注：.dockerignore文件里的文件或目录在制作镜像时会默认忽略。 编写Dockerfile文件 1234567891011121314[root@hadoop01 ~]# mkdir Dockerfile增加以下内容：FROM node:8.4COPY . /appWORKDIR /appRUN npm install --registry=https://registry.npm.taobao.orgEXPOSE 3000注：代码解释如下.From node:8.4 该image继承自官方的node image,冒号表示标签,这里表示8.4,即8.4版本的node.COPY . /app 将当前目录下的所有文件都拷贝到image文件的 /app 目录.WORKDIR /app 指定接下来的工作目录为 /app .RUN npm install 在/app目录下，运行npm install命令安装依赖。注意，安装后所有的依赖，都将打包进入image文件。EXPOSE 3000 将容器的3000端口暴露出来,允许外部连接这个端口. 创建 image 文件 123456789[root@hadoop01 koa-demos]# docker image build -t koa-demos:1.0.0 .......Successfully built efb833bfa6ddSuccessfully tagged koa-demos:1.0.0注： -t 该参数用来指定image文件的名字,后面还可以用冒号指定标签,如果不指定,默认标签就是latest . 当前路径，表示Dockerfile文件所在的路径 生成容器 1234567[root@hadoop01 koa-demos]# docker container run -p 8000:3000 -it koa-demos:1.0.0 bash注： -p 容器的3000端口映射到本地的8000端口. -it 容器的shell会映射到当前本地的shell,你在本机窗口输入的命令会传入到容器中. koa-demo:1.0.0 image文件的名字:标签。 /bin/bash 容器启动以后,容器内部第一个执行的命令.这里是启用Bash,以保证用户可以使用shell 1[root@hadoop01 koa-demos]# docker container run --rm -p 8000:3000 -it koa-demo:1.0.0 /bin/bash Referencehttps://blog.csdn.net/itguangit/article/details/80222387]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker安装]]></title>
    <url>%2Fdocker%2Fck9bgz7ly003eqov7fmvbwn4t.html</url>
    <content type="text"><![CDATA[什么是dockerDocker 是一个开源的应用容器引擎，基于Go语言并遵从Apache2.0协议开源。Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。Docker 从 17.03 版本之后分为 CE（Community Edition: 社区版） 和 EE（Enterprise Edition: 企业版）。 安装dockerUbuntu Docker 安装 CentOS Docker 安装 Windows Docker 安装 MacOS Docker 安装 配置镜像源 修改 /etc/docker/daemon.json 12345# vim /etc/docker/daemon.json # 添加以下内容&#123; &quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;] &#125; 重启Docker 12# systemctl daemon-reload # systemctl restart docker 异常处理 docker: Error response from daemon: Get https://registry-1.docker.io/v2/: net/http: request canceled 1234[root@hadoop01 ~]# docker run hello-worldUnable to find image &apos;hello-world:latest&apos; locallydocker: Error response from daemon: Get https://registry-1.docker.io/v2/library/hello-world/manifests/latest: Get https://auth.docker.io/token?scope=repository%3Alibrary%2Fhello-world%3Apull&amp;service=registry.docker.io: net/http: request canceled (Client.Timeout exceeded while awaiting headers).See &apos;docker run --help&apos;. 修改docker镜像源： docker默认的源为国外官方源，下载速度较慢，可改为国内镜像源。 参考: https://blog.csdn.net/nmjhehe/article/details/99359737]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python3.7.3安装]]></title>
    <url>%2Fpython%2Fck9bgz7o20054qov71xhqh3w2.html</url>
    <content type="text"><![CDATA[安装依赖 安装gcc编译器 123yum -y install gcc注：有些系统版本已经默认安装gcc，通过 gcc --version 查看 安装其它依赖包 1yum -y install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel libffi-devel 下载python3.7.3安装包 最新版本下载地址：https://www.python.org/downloads/1# wget https://www.python.org/ftp/python/3.7.3/Python-3.7.3.tgz 安装python3.7.3 创建安装目录，例： 123# mkdir /usr/local/python3注：安装路径可变 解压下载的安装包 123# tar zxvf /Python-3.7.3.tgz .注: 解压路径可自行指定 进入解压后的目录，编译安装 1234# cd Python-3.7.3# ./configure --prefix=/usr/local/python3...# make &amp;&amp; make install 建立软链接12# ln -s /usr/local/python3/bin/python3 /usr/bin/python3# ln -s /usr/local/python3/bin/pip3 /usr/bin/pip3 测试123# python3# pip3]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 迭代器和生成器]]></title>
    <url>%2Fpython%2Fck9bgz7nw0051qov7z0h8u9x8.html</url>
    <content type="text"><![CDATA[迭代器迭代是Python最强大的功能之一，是访问集合元素的一种方式。 迭代器是一个实现了迭代器协议的对象。 迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。 迭代器有两个基本的方法：iter() 和 next()。 123456789101112131415161718class MyNumbers: def __iter__(self): self.a = 1 return self def __next__(self): if self.a &lt;= 20: x = self.a self.a += 1 return x else: raise StopIteration myclass = MyNumbers()myiter = iter(myclass) for x in myiter: print(x) 生成器在 Python 中，使用了 yield 的函数被称为生成器（generator）。 生成器是一个迭代器。 在调用生成器运行的过程中，每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回 yield 的值, 并在下一次执行 next() 方法时从当前位置继续运行。 调用一个生成器函数，返回的是一个迭代器对象。 12345678910111213141516171819#!/usr/bin/python3 import sys def fibonacci(n): # 生成器函数 - 斐波那契 a, b, counter = 0, 1, 0 while True: if (counter &gt; n): return yield a a, b = b, a + b counter += 1f = fibonacci(10) # f 是一个迭代器，由生成器返回生成 while True: try: print (next(f), end=&quot; &quot;) except StopIteration: sys.exit() 相关参考Python3 迭代器与生成器 python 中的容器、迭代器、生成器]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Restful API 简述]]></title>
    <url>%2Funcategorized%2Fck9bgz7ax000fqov7cin1lqct.html</url>
    <content type="text"><![CDATA[REST简述REST的由来REST最早是由Roy Fielding博士发表的论文中提到的，他也曾参与设计了HTTP协议。论文地址：http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm REST的定义REST 全称是Resource Representational State Transfer，即：资源在网络中以某种形式进行状态转移。 Resource：资源，即数据。 Representational：某种表现形式，比如用JSON，XML，JPEG等； State Transfer：状态变化。通过HTTP动词实现。 REST 指的是一组架构约束条件和原则。如果一个架构符合REST的约束条件和原则，我们就称它为RESTful架构。符合REST设计风格的Web API称为RESTful API。 简单来说REST是一种系统架构设计风格（而非标准），一种分布式系统的应用层解决方案。REST 指的是一组架构约束条件和原则。满足这些约束条件和原则的应用程序或设计就是 RESTful。 REST的目的Client和Server端进一步解耦。 Restful的理解一种软件架构风格、设计风格，而不是标准，只是提供了一组设计原则和约束条件。它主要用于客户端和服务器交互类的软件。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。 RESTful架构，就是目前最流行的一种互联网软件架构。它结构清晰、符合标准、易于理解、扩展方便，所以正得到越来越多网站的采用。 RESTful 是目前最流行的 API 设计规范，用于 Web 数据接口的设计。传统上，软件和网络是两个不同的领域，很少有交集；软件开发主要针对单机环境，网络则主要研究系统之间的通信。在当今的互联网应用的前端展示媒介很丰富。有手机、有平板电脑还有PC以及其他的展示媒介。那么这些前端接收到的用户请求统一由一个后台来处理并返回给不同的前端肯定是最科学和最经济的方式，RESTful API就是一套协议来规范多种形式的前端和同一个后台的交互方式. REST的设计原则 客户端-服务器：通过将用户UI与数据存储分开，我们可以简化服务器组件来提高跨多个平台的用户界面的可移植性并提高可伸缩性。 它可以比表现成前后端分离的思想。 无状态：从客户端到服务器的每个请求都必须包含理解请求所需的所有信息，并且不能利用服务器上任何存储的上下文。 这表示你应该尽可能的避免使用session，由客户端自己标识会话状态。（token） 规范接口：REST接口约束定义：资源识别; 请求动作; 响应信息; 它表示通过uri标出你要操作的资源，通过请求动作（http method）标识要执行的操作，通过返回的状态码来表示这次请求的执行结果。 可缓存： 缓存约束要求将对请求的响应中的数据隐式或显式标记为可缓存或不可缓存。如果响应是可缓存的，则客户端缓存有权重用该响应数据以用于以后的等效请求。 它表示get请求响应头中应该表示有是否可缓存的头（Cache-Control) Reference浅谈Restful Api的知识 了解restful api 10个有关RESTful API良好设计的最佳实践]]></content>
  </entry>
  <entry>
    <title><![CDATA[python 遍历目录获得所有文件]]></title>
    <url>%2Fpython%2Ftips%2Fck9bgz80x00b8qov78ymotpbz.html</url>
    <content type="text"><![CDATA[问题给定一个本地路径，获得当前路径及其子路径下的所有文件。 实现通过 os.walk 方法实现。 123456789def traverse_directory(loc_path): file_list = [] for dirpath, dirnames, filenames in os.walk(loc_path): file_list += [os.path.join(dirpath, filename) for filename in filenames] return file_listif __name__ == &quot;__main__&quot;: local_path = &apos;/home/path&apos; traverse_directory(local_path)]]></content>
      <categories>
        <category>python</category>
        <category>tips</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python factions module]]></title>
    <url>%2Fpython%2Fmodule%2Fck9bgz7ze009sqov7sva6tgl4.html</url>
    <content type="text"><![CDATA[简介python 中处理分数的模块。 源代码 Lib/fractions.py 用法分数实例可以由一对整数，一个分数，或者一个字符串构建而成。 12345class fractions.Fraction(numerator=0, denominator=1)class fractions.Fraction(other_fraction)class fractions.Fraction(float)class fractions.Fraction(decimal)class fractions.Fraction(string) 12345678910111213141516171819202122232425&gt;&gt;&gt; from fractions import Fraction&gt;&gt;&gt; Fraction(16, -10)Fraction(-8, 5)&gt;&gt;&gt; Fraction(123)Fraction(123, 1)&gt;&gt;&gt; Fraction()Fraction(0, 1)&gt;&gt;&gt; Fraction(&apos;3/7&apos;)Fraction(3, 7)&gt;&gt;&gt; Fraction(&apos; -3/7 &apos;)Fraction(-3, 7)&gt;&gt;&gt; Fraction(&apos;1.414213 \t\n&apos;)Fraction(1414213, 1000000)&gt;&gt;&gt; Fraction(&apos;-.125&apos;)Fraction(-1, 8)&gt;&gt;&gt; Fraction(&apos;7e-6&apos;)Fraction(7, 1000000)&gt;&gt;&gt; Fraction(2.25)Fraction(9, 4)&gt;&gt;&gt; Fraction(1.1)Fraction(2476979795053773, 2251799813685248)&gt;&gt;&gt; from decimal import Decimal&gt;&gt;&gt; Fraction(Decimal(&apos;1.1&apos;))Fraction(11, 10) numerator 与 denominator12345678910&gt;&gt;&gt; from fractions import Fraction&gt;&gt;&gt; fra = fractions.Fraction(&apos;1.1&apos;)&gt;&gt;&gt; fraFraction(11, 10)&gt;&gt;&gt; fra.numerator # 分子11&gt;&gt;&gt; fra.denominator # 分母10 from_float(flt)根据浮点数flt（flt为float实例）创建分数。 1234&gt;&gt;&gt; fractions.Fraction.from_float(0.3)Fraction(5404319552844595, 18014398509481984)&gt;&gt;&gt; fractions.Fraction.from_float(0.3).limit_denominator(10)Fraction(3, 10) from_decimal(dec)根据dec（dec为decimal.Decimal实例）创建分数。 12&gt;&gt;&gt; fractions.Fraction.from_decimal(Decimal(&apos;1.25&apos;))Fraction(5, 4) limit_denominator(max_denominator=1000000)Finds and returns the closest Fraction to self that has denominator at most max_denominator. This method is useful for finding rational approximations to a given floating-point number: 12345678910&gt;&gt;&gt; import math&gt;&gt;&gt; fractions.Fraction(math.pi)Fraction(884279719003555, 281474976710656)&gt;&gt;&gt; fractions.Fraction(math.pi).limit_denominator(1000)Fraction(355, 113)&gt;&gt;&gt; fractions.Fraction(math.cos(math.pi/3)).limit_denominator()Fraction(1, 2) fractions.gcd(a, b)返回整数 a 和 b 的最大公约数。如果 a 或 b 之一非零，则 gcd(a, b) 的绝对值是能同时整除 a 和 b 的最大整数。若 b 非零，则 gcd(a,b) 与 b 同号；否则返回值与 a 同号。gcd(0, 0) 返回 0。 3.5 版后已移除: 由 math.gcd() 取代.]]></content>
      <categories>
        <category>python</category>
        <category>module</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>module</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python 计算当前月份的日期范围]]></title>
    <url>%2Fpython%2Ftips%2Fck9bgz80i00auqov741qrax8s.html</url>
    <content type="text"><![CDATA[问题你的代码需要在当前月份中循环每一天，想找到一个计算这个日期范围的高效方法。 解决方案在这样的日期上循环并需要事先构造一个包含所有日期的列表。 你可以先计算出开始日期和结束日期， 然后在你步进的时候使用 datetime.timedelta 对象递增这个日期变量即可。 下面是一个接受任意 datetime 对象并返回一个由当前月份开始日和下个月开始日组成的元组对象。 123456789from datetime import datetime, date, timedeltaimport calendardef get_month_range(start_date=None): if start_date is None: start_date = date.today().replace(day=1) _, days_in_month = calendar.monthrange(start_date.year, start_date.month) end_date = start_date + timedelta(days=days_in_month) return (start_date, end_date) 有了这个就可以很容易的在返回的日期范围上面做循环操作了： 12345678910111213141516&gt;&gt;&gt; a_day = timedelta(days=1)&gt;&gt;&gt; first_day, last_day = get_month_range()&gt;&gt;&gt; while first_day &lt; last_day:... print(first_day)... first_day += a_day...2019-10-012019-10-022019-10-032019-10-042019-10-052019-10-062019-10-072019-10-082019-10-09#... and so on... 讨论上面的代码先计算出一个对应月份第一天的日期。 一个快速的方法就是使用 date 或 datetime 对象的 replace() 方法简单的将 days 属性设置成1即可。 replace() 方法一个好处就是它会创建和你开始传入对象类型相同的对象。 所以，如果输入参数是一个 date 实例，那么结果也是一个 date 实例。 同样的，如果输入是一个 datetime 实例，那么你得到的就是一个 datetime 实例。 然后，使用 calendar.monthrange() 函数来找出该月的总天数。 任何时候只要你想获得日历信息，那么 calendar 模块就非常有用了。 monthrange() 函数会返回包含星期和该月天数的元组。 一旦该月的天数已知了，那么结束日期就可以通过在开始日期上面加上这个天数获得。 有个需要注意的是结束日期并不包含在这个日期范围内(事实上它是下个月的开始日期)。 这个和Python的 slice 与 range 操作行为保持一致，同样也不包含结尾。 为了在日期范围上循环，要使用到标准的数学和比较操作。 比如，可以利用 timedelta 实例来递增日期，小于号&lt;用来检查一个日期是否在结束日期之前。 理想情况下，如果能为日期迭代创建一个同内置的 range() 函数一样的函数就好了。 幸运的是，可以使用一个生成器来很容易的实现这个目标： 1234def date_range(start, stop, step): while start &lt; stop: yield start.strftime(&apos;%Y-%m-%d %H:%M:%S&apos;) start += step 下面是使用这个生成器的例子： 12345678910111213&gt;&gt;&gt; for dt in date_range(datetime(2019, 9, 25), datetime(2019, 10, 5), timedelta(days=1)): print(dt)2019-09-25 00:00:002019-09-26 00:00:002019-09-27 00:00:002019-09-28 00:00:002019-09-29 00:00:002019-09-30 00:00:002019-10-01 00:00:002019-10-02 00:00:002019-10-03 00:00:002019-10-04 00:00:00 Referencehttps://python3-cookbook.readthedocs.io/zh_CN/latest/c03/p14_date_range_for_current_month.html]]></content>
      <categories>
        <category>python</category>
        <category>tips</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python 字符串令牌解析]]></title>
    <url>%2Fpython%2Ftips%2Fck9bgz80q00b1qov7xpkrpnqh.html</url>
    <content type="text"><![CDATA[问题你有一个字符串，想从左至右将其解析为一个令牌流。 解决方案假如你有下面这样一个文本字符串： 1text = &apos;foo = 23 + 42 * 10&apos; 为了令牌化字符串，你不仅需要匹配模式，还得指定模式的类型。 比如，你可能想将字符串像下面这样转换为序列对： 12tokens = [(&apos;NAME&apos;, &apos;foo&apos;), (&apos;EQ&apos;,&apos;=&apos;), (&apos;NUM&apos;, &apos;23&apos;), (&apos;PLUS&apos;,&apos;+&apos;), (&apos;NUM&apos;, &apos;42&apos;), (&apos;TIMES&apos;, &apos;*&apos;), (&apos;NUM&apos;, &apos;10&apos;)] 为了执行这样的切分，第一步就是像下面这样利用命名捕获组的正则表达式来定义所有可能的令牌，包括空格： 123456789import reNAME = r&apos;(?P&lt;NAME&gt;[a-zA-Z_][a-zA-Z_0-9]*)&apos;NUM = r&apos;(?P&lt;NUM&gt;\d+)&apos;PLUS = r&apos;(?P&lt;PLUS&gt;\+)&apos;TIMES = r&apos;(?P&lt;TIMES&gt;\*)&apos;EQ = r&apos;(?P&lt;EQ&gt;=)&apos;WS = r&apos;(?P&lt;WS&gt;\s+)&apos;master_pat = re.compile(&apos;|&apos;.join([NAME, NUM, PLUS, TIMES, EQ, WS])) 在上面的模式中， ?P&lt;TOKENNAME&gt; 用于给一个模式命名，供后面使用。 下一步，为了令牌化，使用模式对象很少被人知道的 scanner() 方法。 这个方法会创建一个 scanner 对象， 在这个对象上不断的调用 match() 方法会一步步的扫描目标文本，每步一个匹配。 下面是演示一个 scanner 对象如何工作的交互式例子： 1234567891011121314151617181920212223242526272829303132333435&gt;&gt;&gt; import re&gt;&gt;&gt; text = &apos;foo = 23 + 42 * 10&apos;&gt;&gt;&gt; NAME = r&apos;(?P&lt;NAME&gt;[a-zA-Z_][a-zA-Z_0-9]*)&apos;&gt;&gt;&gt; NUM = r&apos;(?P&lt;NUM&gt;\d+)&apos;&gt;&gt;&gt; PLUS = r&apos;(?P&lt;PLUS&gt;\+)&apos;&gt;&gt;&gt; TIMES = r&apos;(?P&lt;TIMES&gt;\*)&apos;&gt;&gt;&gt; EQ = r&apos;(?P&lt;EQ&gt;=)&apos;&gt;&gt;&gt; WS = r&apos;(?P&lt;WS&gt;\s+)&apos;&gt;&gt;&gt; pattern = re.compile(&apos;|&apos;.join([NAME, NUM, PLUS, TIMES, EQ, WS]))&gt;&gt;&gt; patternre.compile(&apos;(?P&lt;NAME&gt;[a-zA-Z_][a-zA-Z_0-9]*)|(?P&lt;NUM&gt;\\d+)|(?P&lt;PLUS&gt;\\+)|(?P&lt;TIMES&gt;\\*)|(?P&lt;EQ&gt;=)|(?P&lt;WS&gt;\\s+)&apos;)&gt;&gt;&gt; scanner = pattern.scanner(text)&gt;&gt;&gt; while 1: try: _ = scanner.match() print((_.lastgroup, _.group())) except: break (&apos;NAME&apos;, &apos;foo&apos;)(&apos;WS&apos;, &apos; &apos;)(&apos;EQ&apos;, &apos;=&apos;)(&apos;WS&apos;, &apos; &apos;)(&apos;NUM&apos;, &apos;23&apos;)(&apos;WS&apos;, &apos; &apos;)(&apos;PLUS&apos;, &apos;+&apos;)(&apos;WS&apos;, &apos; &apos;)(&apos;NUM&apos;, &apos;42&apos;)(&apos;WS&apos;, &apos; &apos;)(&apos;TIMES&apos;, &apos;*&apos;)(&apos;WS&apos;, &apos; &apos;)(&apos;NUM&apos;, &apos;10&apos;) 关于更高阶的令牌化技术，你可能需要查看 PyParsing 或者 PLY 包。]]></content>
      <categories>
        <category>python</category>
        <category>tips</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python 在字符串中处理html和xml]]></title>
    <url>%2Fpython%2Ftips%2Fck9bgz80m00axqov7uoa54xu3.html</url>
    <content type="text"><![CDATA[问题你想将HTML或者XML实体如 &entity; 或 &#code; 替换为对应的文本。 再者，你需要转换文本中特定的字符(比如&lt;, &gt;, 或 &amp;)。 解决方案如果你想替换文本字符串中的 ‘&lt;’ 或者 ‘&gt;’ ，使用 html.escape() 函数可以很容易的完成。比如： 1234567891011121314151617181920&gt;&gt;&gt; import html&gt;&gt;&gt; html.__all__[&apos;escape&apos;, &apos;unescape&apos;]&gt;&gt;&gt; s = &apos;Elements are written as &quot;&lt;tag&gt;text&lt;/tag&gt;&quot;.&apos;&gt;&gt;&gt; print(s)Elements are written as &quot;&lt;tag&gt;text&lt;/tag&gt;&quot;.&gt;&gt;&gt; print(html.escape(s))Elements are written as &amp;quot;&amp;lt;tag&amp;gt;text&amp;lt;/tag&amp;gt;&amp;quot;.&gt;&gt;&gt; print(html.escape(s, quote=False))Elements are written as &quot;&amp;lt;tag&amp;gt;text&amp;lt;/tag&amp;gt;&quot;注： html.escape(s, quote=True) 将字符串 s 中的字符``&amp;`` 、 &lt; 和 &gt; 转换为安全的HTML序列。 如果需要在 HTML 中显示可能包含此类字符的文本，请使用此选项。 如果可选的标志 quote 为真值，则字符 (&quot;) 和 (&apos;) 也被转换； 这有助于包含在由引号分隔的 HTML 属性中，如 &lt;a href=&quot;...&quot;&gt;。 如果你正在处理的是ASCII文本，并且想将非ASCII文本对应的编码实体嵌入进去， 可以给某些I/O函数传递参数 errors=&#39;xmlcharrefreplace&#39; 来达到这个目。比如： 12345678910111213&gt;&gt;&gt; s = &apos;Spicy Jalapeño&apos;&gt;&gt;&gt; s.encode(&apos;ascii&apos;, errors=&apos;xmlcharrefreplace&apos;)b&apos;Spicy Jalape&amp;#241;o&apos;注： Python encode() 方法以 encoding 指定的编码格式编码字符串。errors参数可以指定不同的错误处理方案。 语法格式： str.encode(encoding=&apos;UTF-8&apos;,errors=&apos;strict&apos;) 参数： encoding -- 要使用的编码，如&quot;UTF-8&quot;。 errors -- 设置不同错误的处理方案。默认为 &apos;strict&apos;,意为编码错误引起一个UnicodeError。 其他可能的值有 &apos;ignore&apos;, &apos;replace&apos;, &apos;xmlcharrefreplace&apos;, &apos;backslashreplace&apos; 以及通过 codecs.register_error() 注册的任何值。 讨论在生成HTML或者XML文本的时候，如果正确的转换特殊标记字符是一个很容易被忽视的细节。 特别是当你使用 print() 函数或者其他字符串格式化来产生输出的时候。 使用像 html.escape() 的工具函数可以很容易的解决这类问题。 如果你想以其他方式处理文本，还有一些其他的工具函数比如 xml.sax.saxutils.unescapge() 可以帮助你。 然而，你应该先调研清楚怎样使用一个合适的解析器。 比如，如果你在处理HTML或XML文本， 使用某个解析模块比如 html.parse 或 xml.etree.ElementTree 已经帮你自动处理了相关的替换细节 Referencehttps://python3-cookbook.readthedocs.io/zh_CN/latest/c02/p17_handle_html_xml_in_text.html]]></content>
      <categories>
        <category>python</category>
        <category>tips</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python textwrap module]]></title>
    <url>%2Fpython%2Fmodule%2Fck9bgz80300agqov70k8qeso0.html</url>
    <content type="text"><![CDATA[作用通过调整换行符在段落中出现的位置来格式化文本。 源码： Lib/textwrap.py 用法textwrap 模块提供了一些快捷函数，以及可以完成所有工作的类 TextWrapper。 如果你只是要对一两个文本字符串进行自动换行或填充，快捷函数应该就够用了；否则的话，你应该使用 TextWrapper 的实例来提高效率。定义方法如下： 123&gt;&gt;&gt; import textwrap &gt;&gt;&gt; textwrap.__all__ [&apos;TextWrapper&apos;, &apos;wrap&apos;, &apos;fill&apos;, &apos;dedent&apos;, &apos;indent&apos;, &apos;shorten&apos;] textwrap.wrap(text, width=70, **kwargs)将text（字符串）以指定宽度（width，默认70字符）字符进行拆分，以序列的形式返回拆分后的结果,行尾不带换行符。 123456&gt;&gt;&gt; import textwrap &gt;&gt;&gt; textwrap.wrap(text, 70)[&apos;As we hugged Ruth good-bye she said to me with tears glistening in her&apos;, &apos;eyes, “The day you called I was still in bed. I had just finished&apos;, &apos;praying. I asked God if it would be possible to have some Christmas&apos;, &apos;Carolers come to my home and sing this year. Thank you for being the&apos;, &apos;answer to my Christmas prayer.&apos;]&gt;&gt;&gt; len(&apos;As we hugged Ruth good-bye she said to me with tears glistening in her&apos;) 70 textwrap.fill(text, width=70, **kwargs)对 text 中的单独段落自动换行，并返回一个包含被自动换行段落的单独字符串。 fill() 是以下语句的快捷方式 1&quot;\n&quot;.join(wrap(text, ...)) 123&gt;&gt;&gt; textwrap.fill(text, 70) &apos;As we hugged Ruth good-bye she said to me with tears glistening in her\neyes, “The day you called I was still in bed. I had just finished\npraying. I asked God if it would be possible to have some Christmas\nCarolers come to my home and sing this year. Thank you for being the\nanswer to my Christmas prayer.&apos;&gt;&gt;&gt; textwrap.shorten(text, width, **kwargs)折叠并截短给定的 text 以符合给定的 width。 首先将折叠 text 中的空格（所有连续空格替换为单个空格）。 如果结果能适合 width 则将其返回。 否则将丢弃足够数量的末尾单词以使得剩余单词加 placeholder 能适合 width: 12345678&gt;&gt;&gt; textwrap.shorten(&apos;Hello world&apos;, 11)&apos;Hello world&apos;&gt;&gt;&gt; textwrap.shorten(&apos;Hello world!&apos;, 11)&apos;Hello [...]&apos;&gt;&gt;&gt; textwrap.shorten(&apos;Hello world&apos;, 8, placeholder=&apos;...&apos;)&apos;Hello...&apos; textwrap.dedent(text)移除 text 中每一行的任何相同前缀空白符。 12&gt;&gt;&gt; textwrap.dedent(&apos; hello world&apos;)&apos;hello world&apos; textwrap.indent(text, prefix, predicate=None)将 prefix 添加到 text 中选定行的开头。 默认情况下，prefix 会被添加到所有不是只由空白符（包括任何行结束符）组成的行。 12345&gt;&gt;&gt; textwrap.indent(&apos;hello\nworld&apos;, &apos; &apos;) &apos; hello\n world&apos;&gt;&gt;&gt; print(textwrap.indent(&apos;hello\nworld&apos;, &apos; &apos;)) hello world 可选的 predicate 参数可用来控制哪些行要缩进。 例如，可以很容易地为空行或只有空白符的行添加 prefix: 12345&gt;&gt;&gt; print(indent(s, &apos;+ &apos;, lambda line: True))+ hello+++ world class textwrap.TextWrapper(**kwargs)TextWrapper构造器接受多个可选的关键字参数。 每个关键字参数对应一个实例属性，比如说 1wrapper = TextWrapper(initial_indent=&quot;* &quot;) 就相当于 12wrapper = TextWrapper()wrapper.initial_indent = &quot;* &quot; 你可以多次重用相同的 TextWrapper对象，并且你也可以在使用期间通过直接向实例属性赋值来修改它的任何选项。 TextWrapper 的实例属性（以及构造器的关键字参数）如下所示： width –&gt; (默认: 70) 自动换行的最大行长度。 只要输入文本中没有长于 width 的单个单词，TextWrapper 就能保证没有长于 width 个字符的输出行。 expand_tabs –&gt; (默认: True) 如果为真值，则 text 中所有的制表符将使用 text 的 expandtabs() 方法扩展为空格符。 tabsize –&gt; (默认: 8) 如果 expand_tabs 为真值，则 text 中所有的制表符将扩展为零个或多个空格，具体取决于当前列位置和给定的制表宽度。 replace_whitespace –&gt; (default: True) 如果为真值，在制表符扩展之后、自动换行之前，wrap() 方法将把每个空白字符都替换为单个空格。 会被替换的空白字符如下：制表，换行，垂直制表，进纸和回车 (‘\t\n\v\f\r’)。 123注解: 如果 expand_tabs 为假值且 replace_whitespace 为真值，每个制表符将被替换为单个空格，这与制表符扩展是 不 一样的。 如果 replace_whitespace 为假值，在一行的中间有可能出现换行符并导致怪异的输出。 因此，文本应当（使用 str.splitlines() 或类似方法）拆分为段落并分别进行自动换行。 drop_whitespace –&gt; (默认: True) 如果为真值，每一行开头和末尾的空白字符（在包装之后、缩进之前）会被丢弃。 但是段落开头的空白字符如果后面不带任何非空白字符则不会被丢弃。 如果被丢弃的空白字符占据了一个整行，则该整行将被丢弃。 initial_indent –&gt; (默认: &#39;&#39;) 将被添加到被自动换行输出内容的第一行的字符串。 其长度会被计入第一行的长度。 空字符串不会被缩进。 subsequent_indent –&gt; (default: &#39;&#39;) 将被添加到被自动换行输出内容除第一行外的所有行的字符串。 其长度会被计入除行一行外的所有行的长度。 fix_sentence_endings –&gt; (默认: False) 如果为真值，TextWrapper 将尝试检测句子结尾并确保句子间总是以恰好两个空格符分隔。 对于使用等宽字体的文本来说通常都需要这样。 但是，句子检测算法并不完美：它假定句子结尾是一个小写字母加字符 &#39;.&#39;, &#39;!&#39; 或 &#39;?&#39; 中的一个，并可能带有字符 &#39;&quot;&#39; 或 &quot;&#39;&quot;，最后以一个空格结束。 此算法的问题之一是它无法区分以下文本中的 “Dr.” 由于句子检测算法依赖于 string.lowercase 来确定“小写字母”，以及约定在句点后使用两个空格来分隔处于同一行的句子，因此只适用于英语文本。 break_long_words –&gt; (默认: True) 如果为真值，则长度超过 width 的单词将被分开以保证行的长度不会超过 width。 如果为假值，超长单词不会被分开，因而某些行的长度可能会超过 width。 （超长单词将被单独作为一行，以尽量减少超出 width 的情况。） break_on_hyphens –&gt; (默认: True) 如果为真值，将根据英语的惯例首选在空白符和复合词的连字符之后自动换行。 如果为假值，则只有空白符会被视为合适的潜在断行位置，但如果你确实不希望出现分开的单词则你必须将 break_long_words 设为假值。 之前版本的默认行为总是允许分开带有连字符的单词。 max_lines –&gt; (默认: None) 如果不为 None，则输出内容将最多包含 max_lines 行，并使 placeholder 出现在输出内容的末尾。 placeholder –&gt; (默认: ‘ […]’) 该文本将在输出文本被截短时出现在文本末尾。]]></content>
      <categories>
        <category>python</category>
        <category>module</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>module</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python format用法]]></title>
    <url>%2Fpython%2Ftips%2Fck9bgz83y00e1qov7qrez5rta.html</url>
    <content type="text"><![CDATA[作用str.format() 方法通过字符串中的花括号 {} 来识别替换字段 replacement field，从而完成字符串的格式化。 用法 省略字段名 123456789101112131415# 花括号内省略字段名，传递位置参数。&gt;&gt;&gt; &apos;name &#123;&#125;, age &#123;&#125;&apos;.format(&apos;Lucy&apos;, 20)&apos;name Lucy, age 20&apos;&gt;&gt;&gt; &apos;name &#123;&#125;, age &#123;&#125;&apos;.format(&apos;Lucy&apos;, 20, &apos;blue&apos;) &apos;name Lucy, age 20&apos;&gt;&gt;&gt; &apos;name &#123;&#125;, age &#123;&#125;&apos;.format(&apos;Lucy&apos;) Traceback (most recent call last): File &quot;&lt;pyshell#86&gt;&quot;, line 1, in &lt;module&gt; &apos;name &#123;&#125;, age &#123;&#125;&apos;.format(&apos;Lucy&apos;)IndexError: tuple index out of range注：花括号个数不多于位置参数的个数。 下标索引传参 可以通过数字形式的简单字段名传递位置参数。数字必须是大于等于 0 的整数。带数字的替换字段可以重复使用。数字形式的简单字段名相当于把 format 中的所有位置参数整体当作一个元组，通过字段名中的数字进行取值。即 {0} 等价于 tuple[0]，所以花括号内的数字不能越界。 12&gt;&gt;&gt; &apos;name &#123;0&#125;, color &#123;2&#125;, age &#123;1&#125;&apos;.format(&apos;Lucy&apos;, 20, &apos;Bule&apos;)&apos;name Lucy, color Bule, age 20&apos; 关键字传参 使用变量名形式的简单字段名传递关键字参数。 关键字参数的位置可以随意调换。 12345678910111213# 用法一&gt;&gt;&gt; &apos;name &#123;name&#125;, color &#123;color&#125;, age &#123;age&#125;&apos;.format(name=&apos;Lucy&apos;, color=&apos;Bule&apos;, age=20)&apos;name Lucy, color Bule, age 20&apos;# 用法二&gt;&gt;&gt; d = dict(name=&apos;Lucy&apos;, color=&apos;Bule&apos;, age=20) &gt;&gt;&gt; &apos;name &#123;name&#125;, color &#123;color&#125;, age &#123;age&#125;&apos;.format(**d)&apos;name Lucy, color Bule, age 20&apos;# 用法三&gt;&gt;&gt; d = dict(name=&apos;Lucy&apos;, color=&apos;Bule&apos;, age=20) &gt;&gt;&gt; &apos;name &#123;name&#125;, color &#123;color&#125;, age &#123;age&#125;&apos;.format_map(d)&apos;name Lucy, color Bule, age 20&apos; 简单字段名的混合使用 混合使用数字形式和变量名形式的字段名，可以同时传递位置参数和关键字参数。 关键字参数必须位于位置参数之后。 混合使用时可以省略数字。 省略字段名 {} 不能和数字形式的字段名 {非负整数} 同时使用。 12345678&gt;&gt;&gt; &apos;name &#123;1&#125;, color &#123;0&#125;, age &#123;age&#125;&apos;.format(&apos;Bule&apos;, &apos;Lucy&apos;, age=20) &apos;name Lucy, color Bule, age 20&apos;# 使用元组和字典传参&gt;&gt;&gt; tup = (&apos;Bule&apos;, &apos;Lucy&apos;) &gt;&gt;&gt; dt = dict(age=20) &gt;&gt;&gt; &apos;name &#123;1&#125;, color &#123;0&#125;, age &#123;age&#125;&apos;.format(*tup, **dt) &apos;name Lucy, color Bule, age 20&apos; 复合字段名的使用 同时使用了数字和变量名两种形式的字段名就是复合字段名。 复合字段名支持两种操作符： [] 方括号 传递位置参数 传递关键字参数 . 点号 传递位置参数 替换字段形式：{数字.属性名} 只有一个替换字段的时候可以省略数字 传递关键字参数 替换字段形式：{关键字参数名.属性名} 方括号替换 123&gt;&gt;&gt; lst = [&apos;Bule&apos;, 20, &apos;Lucy&apos;]&gt;&gt;&gt; &apos;name &#123;0[2]&#125;, color &#123;0[0]&#125;, age &#123;0[1]&#125;&apos;.format(lst)&apos;name Lucy, color Bule, age 20&apos; 12&gt;&gt;&gt; &apos;name &#123;0[name]&#125;, color &#123;0[color]&#125;, age &#123;0[age]&#125;&apos;.format(d)&apos;name Lucy, color Bule, age 20&apos; 点号替换 12&gt;&gt;&gt; &apos;name &#123;per.name&#125;, color &#123;per.color&#125;, age &#123;per.age&#125;&apos;.format(per=p) &apos;name Lucy, color Bule, age 20&apos; 1234567891011# 方法一&gt;&gt;&gt; &apos;name &#123;0.name&#125;, color &#123;0.color&#125;, age &#123;0.age&#125;&apos;.format(p)&apos;name Lucy, color Bule, age 20&apos;# 方法二&gt;&gt;&gt; &apos;name &#123;name&#125;, color &#123;color&#125;, age &#123;age&#125;&apos;.format(**vars(p)) &apos;name Lucy, color Bule, age 20&apos;# 方法三&gt;&gt;&gt; &apos;name &#123;name&#125;, color &#123;color&#125;, age &#123;age&#125;&apos;.format_map(vars(p)) &apos;name Lucy, color Bule, age 20&apos; 字符串中插入变量Python并没有对在字符串中简单替换变量值提供直接的支持。 但是通过使用字符串的 format() 方法来解决这个问题。比如： 123&gt;&gt;&gt; s = &apos;&#123;name&#125; has &#123;n&#125; messages.&apos;&gt;&gt;&gt; s.format(name=&apos;Guido&apos;, n=37)&apos;Guido has 37 messages.&apos; 或者，如果要被替换的变量能在变量域中找到， 那么你可以结合使用 format_map() 和 vars() 。就像下面这样： 1234&gt;&gt;&gt; name = &apos;Guido&apos;&gt;&gt;&gt; n = 37&gt;&gt;&gt; s.format_map(vars())&apos;Guido has 37 messages.&apos; vars() 还有一个有意思的特性就是它也适用于对象实例。比如： 12345678&gt;&gt;&gt; class Info:... def __init__(self, name, n):... self.name = name... self.n = n...&gt;&gt;&gt; a = Info(&apos;Guido&apos;,37)&gt;&gt;&gt; s.format_map(vars(a))&apos;Guido has 37 messages.&apos; format 和 format_map() 的一个缺陷就是它们并不能很好的处理变量缺失的情况，比如： 1234&gt;&gt;&gt; s.format(name=&apos;Guido&apos;)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;KeyError: &apos;n&apos; 一种避免这种错误的方法是另外定义一个含有 __missing__() 方法的字典对象，就像下面这样： 1234class safesub(dict):&quot;&quot;&quot;防止key找不到&quot;&quot;&quot;def __missing__(self, key): return &apos;&#123;&apos; + key + &apos;&#125;&apos; 现在你可以利用这个类包装输入后传递给 format_map() ： 123&gt;&gt;&gt; del n # Make sure n is undefined&gt;&gt;&gt; s.format_map(safesub(vars()))&apos;Guido has &#123;n&#125; messages.&apos; 如果你发现自己在代码中频繁的执行这些步骤，你可以将变量替换步骤用一个工具函数封装起来。就像下面这样： 1234import sysdef sub(text): return text.format_map(safesub(sys._getframe(1).f_locals)) 现在你可以像下面这样写了： 12345678&gt;&gt;&gt; name = &apos;Guido&apos;&gt;&gt;&gt; n = 37&gt;&gt;&gt; print(sub(&apos;Hello &#123;name&#125;&apos;))Hello Guido&gt;&gt;&gt; print(sub(&apos;You have &#123;n&#125; messages.&apos;))You have 37 messages.&gt;&gt;&gt; print(sub(&apos;Your favorite color is &#123;color&#125;&apos;))Your favorite color is &#123;color&#125; 多年以来由于Python缺乏对变量替换的内置支持而导致了各种不同的解决方案。 作为本节中展示的一个可能的解决方案，你可以有时候会看到像下面这样的字符串格式化代码： 12345&gt;&gt;&gt; name = &apos;Guido&apos;&gt;&gt;&gt; n = 37&gt;&gt;&gt; &apos;%(name) has %(n) messages.&apos; % vars()&apos;Guido has 37 messages.&apos;&gt;&gt;&gt; 你可能还会看到字符串模板的使用： 12345&gt;&gt;&gt; import string&gt;&gt;&gt; s = string.Template(&apos;$name has $n messages.&apos;)&gt;&gt;&gt; s.substitute(vars())&apos;Guido has 37 messages.&apos;&gt;&gt;&gt; 然而， format() 和 format_map() 相比较上面这些方案而已更加先进，因此应该被优先选择。 使用 format() 方法还有一个好处就是你可以获得对字符串格式化的所有支持(对齐，填充，数字格式化等待)， 而这些特性是使用像模板字符串之类的方案不可能获得的。 本机还部分介绍了一些高级特性。映射或者字典类中鲜为人知的 __missing__() 方法可以让你定义如何处理缺失的值。 在 SafeSub 类中，这个方法被定义为对缺失的值返回一个占位符。 你可以发现缺失的值会出现在结果字符串中(在调试的时候可能很有用)，而不是产生一个 KeyError 异常。 sub() 函数使用 sys._getframe(1) 返回调用者的栈帧。可以从中访问属性 f_locals 来获得局部变量。 毫无疑问绝大部分情况下在代码中去直接操作栈帧应该是不推荐的。 但是，对于像字符串替换工具函数而言它是非常有用的。 另外，值得注意的是 f_locals 是一个复制调用函数的本地变量的字典。 尽管你可以改变 f_locals 的内容，但是这个修改对于后面的变量访问没有任何影响。 所以，虽说访问一个栈帧看上去很邪恶，但是对它的任何操作不会覆盖和改变调用者本地变量的值。 Referencehttps://blog.csdn.net/jpch89/article/details/84099277 https://python3-cookbook.readthedocs.io/zh_CN/latest/c02/p15_interpolating_variables_in_strings.html]]></content>
      <categories>
        <category>python</category>
        <category>tips</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python 审查清理文本字符串]]></title>
    <url>%2Fpython%2Ftips%2Fck9bgz80t00b4qov706g8sqdj.html</url>
    <content type="text"><![CDATA[问题一些无聊的幼稚黑客在你的网站页面表单中输入文本”pýtĥöñ”，然后你想将这些字符清理掉。 解决方案文本清理问题会涉及到包括文本解析与数据处理等一系列问题。 在非常简单的情形下，你可能会选择使用字符串函数(比如 str.upper() 和 str.lower() )将文本转为标准格式。 使用 str.replace()或者 re.sub() 的简单替换操作能删除或者改变指定的字符序列。 你同样还可以使用2.9小节的 unicodedata.normalize() 函数将unicode文本标准化。 然后，有时候你可能还想在清理操作上更进一步。比如，你可能想消除整个区间上的字符或者去除变音符。 为了这样做，你可以使用经常会被忽视的 str.translate() 方法。 为了演示，假设你现在有下面这个凌乱的字符串： 123&gt;&gt;&gt; s = &apos;pýtĥöñ\fis\tawesome\r\n&apos;&gt;&gt;&gt; s&apos;pýtĥöñ\x0cis\tawesome\r\n&apos; 第一步是清理空白字符。为了这样做，先创建一个小的转换表格然后使用 translate() 方法： 12345678&gt;&gt;&gt; remap = &#123; ord(&apos;\t&apos;) : &apos; &apos;, ord(&apos;\f&apos;) : &apos; &apos;, ord(&apos;\r&apos;) : None # Deleted &#125;&gt;&gt;&gt; a = s.translate(remap)&gt;&gt;&gt; a&apos;pýtĥöñ is awesome\n&apos; 正如你看的那样，空白字符 \t 和 \f 已经被重新映射到一个空格。回车字符r直接被删除。 你可以以这个表格为基础进一步构建更大的表格。比如，让我们删除所有的和音符： 123456789&gt;&gt;&gt; import unicodedata&gt;&gt;&gt; import sys&gt;&gt;&gt; cmb_chrs = dict.fromkeys(c for c in range(sys.maxunicode) if unicodedata.combining(chr(c)))&gt;&gt;&gt; b = unicodedata.normalize(&apos;NFD&apos;, a)&gt;&gt;&gt; b&apos;pýtĥöñ is awesome\n&apos;&gt;&gt;&gt; b.translate(cmb_chrs)&apos;python is awesome\n&apos; 上面例子中，通过使用 dict.fromkeys() 方法构造一个字典，每个Unicode和音符作为键，对应的值全部为 None 。 然后使用 unicodedata.normalize() 将原始输入标准化为分解形式字符。 然后再调用 translate 函数删除所有重音符。 同样的技术也可以被用来删除其他类型的字符(比如控制字符等)。 作为另一个例子，这里构造一个将所有Unicode数字字符映射到对应的ASCII字符上的表格： 12345678910&gt;&gt;&gt; digitmap = &#123; c: ord(&apos;0&apos;) + unicodedata.digit(chr(c)) for c in range(sys.maxunicode) if unicodedata.category(chr(c)) == &apos;Nd&apos; &#125;&gt;&gt;&gt; len(digitmap)460&gt;&gt;&gt; # Arabic digits&gt;&gt;&gt; x = &apos;\u0661\u0662\u0663&apos;&gt;&gt;&gt; x.translate(digitmap)&apos;123&apos; 另一种清理文本的技术涉及到I/O解码与编码函数。这里的思路是先对文本做一些初步的清理， 然后再结合 encode() 或者 decode() 操作来清除或修改它。比如： 12345&gt;&gt;&gt; a&apos;pýtĥöñ is awesome\n&apos;&gt;&gt;&gt; b = unicodedata.normalize(&apos;NFD&apos;, a)&gt;&gt;&gt; b.encode(&apos;ascii&apos;, &apos;ignore&apos;).decode(&apos;ascii&apos;)&apos;python is awesome\n&apos; 这里的标准化操作将原来的文本分解为单独的和音符。接下来的ASCII编码/解码只是简单的一下子丢弃掉那些字符。 当然，这种方法仅仅只在最后的目标就是获取到文本对应ACSII表示的时候生效。 讨论文本字符清理一个最主要的问题应该是运行的性能。一般来讲，代码越简单运行越快。 对于简单的替换操作， str.replace() 方法通常是最快的，甚至在你需要多次调用的时候。 比如，为了清理空白字符，你可以这样做： 12345def clean_spaces(s): s = s.replace(&apos;\r&apos;, &apos;&apos;) s = s.replace(&apos;\t&apos;, &apos; &apos;) s = s.replace(&apos;\f&apos;, &apos; &apos;) return s 如果你去测试的话，你就会发现这种方式会比使用 translate() 或者正则表达式要快很多。 另一方面，如果你需要执行任何复杂字符对字符的重新映射或者删除操作的话， tanslate() 方法会非常的快。 从大的方面来讲，对于你的应用程序来说性能是你不得不去自己研究的东西。 不幸的是，我们不可能给你建议一个特定的技术，使它能够适应所有的情况。 因此实际情况中需要你自己去尝试不同的方法并评估它。 转载自：https://python3-cookbook.readthedocs.io/zh_CN/latest/c02/p12_sanitizing_clean_up_text.html]]></content>
      <categories>
        <category>python</category>
        <category>tips</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python unicodedata module]]></title>
    <url>%2Fpython%2Fmodule%2Fck9bgz80a00anqov79srxe2gi.html</url>
    <content type="text"><![CDATA[简介处理Unicode字符数据库(UCD)的模块，UCD为所有Unicode字符定义字符属性。 UCD是Unicode字符数据库（Unicode Character DataBase）的缩写。 UCD由一些描述Unicode字符属性和内部关系的纯文本或html文件组成。 UCD中的文本文件大都是适合于程序分析的Unicode相关数据。其中的html文件解释了数据库的组织，数据的格式和含义。 定义函数123&gt;&gt;&gt; import unicodedata&gt;&gt;&gt; dir(unicodedata)[&apos;UCD&apos;, &apos;__doc__&apos;, &apos;__file__&apos;, &apos;__loader__&apos;, &apos;__name__&apos;, &apos;__package__&apos;, &apos;__spec__&apos;, &apos;bidirectional&apos;, &apos;category&apos;, &apos;combining&apos;, &apos;decimal&apos;, &apos;decomposition&apos;, &apos;digit&apos;, &apos;east_asian_width&apos;, &apos;lookup&apos;, &apos;mirrored&apos;, &apos;name&apos;, &apos;normalize&apos;, &apos;numeric&apos;, &apos;ucd_3_2_0&apos;, &apos;ucnhash_CAPI&apos;, &apos;unidata_version&apos;] unicodedata.lookup(name)12345lookup(name, /) Look up character by name. If a character with the given name is found, return the corresponding character. If not found, KeyError is raised. 1234567&gt;&gt;&gt; unicodedata.lookup(&apos;LEFT CURLY BRACKET&apos;)&#123;&gt;&gt;&gt; unicodedata.lookup(&apos;LEFT CURLY&apos;)Traceback (most recent call last): File &quot;&lt;pyshell#35&gt;&quot;, line 1, in &lt;module&gt; unicodedata.lookup(&apos;LEFT CURLY&apos;)KeyError: &quot;undefined character name &apos;LEFT CURLY&apos;&quot; unicodedata.name(chr, default=None)12345name(chr, default=None, /) Returns the name assigned to the character chr as a string. If no name is defined, default is returned, or, if not given, ValueError is raised. 12345678&gt;&gt;&gt; unicodedata.name(&apos;&#125;&apos;)&apos;RIGHT CURLY BRACKET&apos;&gt;&gt;&gt; unicodedata.name(&apos;&#125;&#125;&apos;)Traceback (most recent call last): File &quot;&lt;pyshell#37&gt;&quot;, line 1, in &lt;module&gt; unicodedata.name(&apos;&#125;&#125;&apos;)TypeError: name() argument 1 must be a unicode character, not str unicodedata.decimal(chr, default=None)123456decimal(chr, default=None, /) Converts a Unicode character into its equivalent decimal value. Returns the decimal value assigned to the character chr as integer. If no such value is defined, default is returned, or, if not given, ValueError is raised. 123456789&gt;&gt;&gt; unicodedata.decimal(&apos;8&apos;)8&gt;&gt;&gt; type(unicodedata.decimal(&apos;8&apos;))&lt;class &apos;int&apos;&gt;&gt;&gt;&gt; unicodedata.decimal(&apos;a&apos;)Traceback (most recent call last): File &quot;&lt;pyshell#46&gt;&quot;, line 1, in &lt;module&gt; unicodedata.decimal(&apos;a&apos;)ValueError: not a decimal unicodedata.digit(chr, default=None)123456digit(chr, default=None, /) Converts a Unicode character into its equivalent digit value. Returns the digit value assigned to the character chr as integer. If no such value is defined, default is returned, or, if not given, ValueError is raised. 1234567&gt;&gt;&gt; unicodedata.digit(&apos;8&apos;)8&gt;&gt;&gt; unicodedata.digit(&apos;a&apos;)Traceback (most recent call last): File &quot;&lt;pyshell#50&gt;&quot;, line 1, in &lt;module&gt; unicodedata.digit(&apos;a&apos;)ValueError: not a digit unicodedata.numeric(chr, default=None)123456numeric(chr, default=None, /) Converts a Unicode character into its equivalent numeric value. Returns the numeric value assigned to the character chr as float. If no such value is defined, default is returned, or, if not given, ValueError is raised. 123456789&gt;&gt;&gt; unicodedata.numeric(&apos;5&apos;)5.0&gt;&gt;&gt; unicodedata.numeric(&apos;五&apos;) 5.0&gt;&gt;&gt; unicodedata.numeric(&apos;无&apos;) Traceback (most recent call last): File &quot;&lt;pyshell#52&gt;&quot;, line 1, in &lt;module&gt; unicodedata.numeric(&apos;无&apos;)ValueError: not a numeric character unicodedata.category(chr)12category(chr, /) Returns the general category assigned to the character chr as string. unicodedata.bidirectional(chr)123bidirectional(chr, /) Returns the bidirectional class assigned to the character chr as string. If no such value is defined, an empty string is returned. unicodedata.combining(chr)123combining(chr, /) Returns the canonical combining class assigned to the character chr as integer. Returns 0 if no combining class is defined. unicodedata.decomposition(chr)123decomposition(chr, /) Returns the character decomposition mapping assigned to the character chr as string. An empty string is returned in case no such mapping is defined. unicodedata.east_asian_width(chr) 12east_asian_width(chr, /) Returns the east asian width assigned to the character chr as string. unicodedata.mirrored(chr)1234mirrored(chr, /) Returns the mirrored property assigned to the character chr as integer. Returns 1 if the character has been identified as a &quot;mirrored&quot; character in bidirectional text, 0 otherwise. unicodedata.normalize(form, unistr)normalize(form, unistr, /) Return the normal form &apos;form&apos; for the Unicode string unistr. Valid values for form are &apos;NFC&apos;, &apos;NFKC&apos;, &apos;NFD&apos;, and &apos;NFKD&apos;.unicodedata.unidata_versionunicodedata.ucnhash_CAPIunicodedata.ucd_3_2_01234DATA ucd_3_2_0 = &lt;unicodedata.UCD object&gt; ucnhash_CAPI = &lt;capsule object &quot;unicodedata.ucnhash_CAPI&quot;&gt; unidata_version = &apos;11.0.0&apos; Referencehttps://docs.python.org/zh-cn/3/library/unicodedata.html#module-unicodedata https://blog.csdn.net/xc_zhou/article/details/82079753]]></content>
      <categories>
        <category>python</category>
        <category>module</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>module</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python 将Unicode文本标准化]]></title>
    <url>%2Fpython%2Ftips%2Fck9bgz80d00aqqov7wnh842g1.html</url>
    <content type="text"><![CDATA[问题你正在处理Unicode字符串，需要确保所有字符串在底层有相同的表示。 解决方案在Unicode中，某些字符能够用多个合法的编码表示。为了说明，考虑下面的这个例子： 123456789101112&gt;&gt;&gt; s1 = &apos;Spicy Jalape\u00f1o&apos;&gt;&gt;&gt; s2 = &apos;Spicy Jalapen\u0303o&apos;&gt;&gt;&gt; s1&apos;Spicy Jalapeño&apos;&gt;&gt;&gt; s2&apos;Spicy Jalapeño&apos;&gt;&gt;&gt; s1 == s2False&gt;&gt;&gt; len(s1)14&gt;&gt;&gt; len(s2)15 这里的文本”Spicy Jalapeño”使用了两种形式来表示。 第一种使用整体字符”ñ”(U+00F1)，第二种使用拉丁字母”n”后面跟一个”~”的组合字符(U+0303)。 在需要比较字符串的程序中使用字符的多种表示会产生问题。 为了修正这个问题，你可以使用unicodedata模块先将文本标准化： 1234567891011121314&gt;&gt;&gt; import unicodedata&gt;&gt;&gt; t1 = unicodedata.normalize(&apos;NFC&apos;, s1)&gt;&gt;&gt; t2 = unicodedata.normalize(&apos;NFC&apos;, s2)&gt;&gt;&gt; t1 == t2True&gt;&gt;&gt; print(ascii(t1))&apos;Spicy Jalape\xf1o&apos;&gt;&gt;&gt; t3 = unicodedata.normalize(&apos;NFD&apos;, s1)&gt;&gt;&gt; t4 = unicodedata.normalize(&apos;NFD&apos;, s2)&gt;&gt;&gt; t3 == t4True&gt;&gt;&gt; print(ascii(t3))&apos;Spicy Jalapen\u0303o&apos; normalize() 第一个参数指定字符串标准化的方式。 NFC表示字符应该是整体组成(比如可能的话就使用单一编码)，而NFD表示字符应该分解为多个组合字符表示。 Python同样支持扩展的标准化形式NFKC和NFKD，它们在处理某些字符的时候增加了额外的兼容特性。比如： 12345678910&gt;&gt;&gt; s = &apos;\ufb01&apos; # A single character&gt;&gt;&gt; s&apos;ﬁ&apos;&gt;&gt;&gt; unicodedata.normalize(&apos;NFD&apos;, s)&apos;ﬁ&apos;# Notice how the combined letters are broken apart here&gt;&gt;&gt; unicodedata.normalize(&apos;NFKD&apos;, s)&apos;fi&apos;&gt;&gt;&gt; unicodedata.normalize(&apos;NFKC&apos;, s)&apos;fi&apos; 讨论标准化对于任何需要以一致的方式处理Unicode文本的程序都是非常重要的。 当处理来自用户输入的字符串而你很难去控制编码的时候尤其如此。 在清理和过滤文本的时候字符的标准化也是很重要的。 比如，假设你想清除掉一些文本上面的变音符的时候(可能是为了搜索和匹配)： 123&gt;&gt;&gt; t1 = unicodedata.normalize(&apos;NFD&apos;, s1)&gt;&gt;&gt; &apos;&apos;.join(c for c in t1 if not unicodedata.combining(c))&apos;Spicy Jalapeno&apos; 最后一个例子展示了 unicodedata 模块的另一个重要方面，也就是测试字符类的工具函数。combining() 函数可以测试一个字符是否为和音字符。 在这个模块中还有其他函数用于查找字符类别，测试是否为数字字符等等。 转载自： https://python3-cookbook.readthedocs.io/zh_CN/latest/c02/p09_normalize_unicode_text_to_regexp.html]]></content>
      <categories>
        <category>python</category>
        <category>tips</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python fnmatch module]]></title>
    <url>%2Fpython%2Fmodule%2Fck9bgz7za009oqov7v61k8203.html</url>
    <content type="text"><![CDATA[介绍在python中，fnmatch模块是用来做字符串匹配文件名的标准库。 源码: Lib/fnmatch.py fnmatch支持的通配符： 通配符 含义 * 匹配任何数量的字符 ？ 匹配单个字符 [seq] 匹配seq中的字符 [!seq] 匹配除seq以外的任何字符 使用123&gt;&gt;&gt; import fnmatch&gt;&gt;&gt; fnmatch.__all__[&apos;filter&apos;, &apos;fnmatch&apos;, &apos;fnmatchcase&apos;, &apos;translate&apos;] fnmatch这个库相对比较简单，只有4个函数，分别是fnmatch、fnmatchcase、filter和translate，其中最常用的是fnmatch。主要功能如下： fnmatch：判断文件名是否符合特定的模式。 fnmatchcase：判断文件名是否符合特定的模式，区分大小写。 filter：返回输入列表中，符合特定模式的文件名列表。 translate：将通配符模式转换成正则表达式。 示例fnmatch.fnmatch1语法：fnmatch(name, pat) 1234567891011121314&gt;&gt;&gt; file_list = [&apos;A1.jpg&apos;, &apos;a1.txt&apos;, &apos;a2.txt&apos;, &apos;aA.txt&apos;, &apos;b3.jpg&apos;, &apos;b2.jpg&apos;, &apos;b1.jpg&apos;]# 匹配图片&gt;&gt;&gt; [name for name in file_list if fnmatch.fnmatch(name, &apos;*.jpg&apos;)][&apos;A1.jpg&apos;, &apos;b3.jpg&apos;, &apos;b2.jpg&apos;, &apos;b1.jpg&apos;]&gt;&gt;&gt; [name for name in file_list if fnmatch.fnmatch(name, &apos;*.JPG&apos;)][&apos;A1.jpg&apos;, &apos;b3.jpg&apos;, &apos;b2.jpg&apos;, &apos;b1.jpg&apos;]# 上述方式等效于如下：&gt;&gt;&gt; [name for name in file_list if name.endswith(&apos;.jpg&apos;)][&apos;A1.jpg&apos;, &apos;b3.jpg&apos;, &apos;b2.jpg&apos;, &apos;b1.jpg&apos;]注：fnmatch.fnmatch 方式匹配文件名时，不区分大小写，即大小写不敏感。 fnmatch.fnmatchcase1语法：fnmatchcase(name, pat) 12345678910&gt;&gt;&gt; file_list = [&apos;A1.jpg&apos;, &apos;a1.txt&apos;, &apos;a2.txt&apos;, &apos;aA.txt&apos;, &apos;b3.jpg&apos;, &apos;b2.jpg&apos;, &apos;b1.jpg&apos;]&gt;&gt;&gt; [name for name in file_list if fnmatch.fnmatchcase(name, &apos;*.jpg&apos;)][&apos;A1.jpg&apos;, &apos;b3.jpg&apos;, &apos;b2.jpg&apos;, &apos;b1.jpg&apos;]# 大些的 *.JPG 将匹配不到&gt;&gt;&gt; [name for name in file_list if fnmatch.fnmatchcase(name, &apos;*.JPG&apos;)][]注：fnmatch.fnmatchcase 用法与 fnmatch.fnmatch相同，区别是其大小写敏感。 fnmatch.filter1语法：filter(names, pat) 123456&gt;&gt;&gt; file_list = [&apos;A1.jpg&apos;, &apos;a1.txt&apos;, &apos;a2.txt&apos;, &apos;aA.txt&apos;, &apos;b3.jpg&apos;, &apos;b2.jpg&apos;, &apos;b1.jpg&apos;]&gt;&gt;&gt; fnmatch.filter(file_list, &apos;*.jpg&apos;)[&apos;A1.jpg&apos;, &apos;b3.jpg&apos;, &apos;b2.jpg&apos;, &apos;b1.jpg&apos;]&gt;&gt;&gt; fnmatch.filter(file_list, &apos;*.JPG&apos;)[&apos;A1.jpg&apos;, &apos;b3.jpg&apos;, &apos;b2.jpg&apos;, &apos;b1.jpg&apos;] fnmatch.translate1语法：translate(pat) 12&gt;&gt;&gt; fnmatch.translate(&apos;*jpg&apos;)&apos;(?s:.*jpg)\\Z&apos;]]></content>
      <categories>
        <category>python</category>
        <category>module</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>module</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[猴子爬山问题]]></title>
    <url>%2Fmath%2Fck9bgz7nj004rqov7i9m7e8r4.html</url>
    <content type="text"><![CDATA[问题一只顽猴儿在一座有 n 级台阶的山上爬山，假设猴子上山一步可跳1级台阶或3级台阶。试求猴子上山有多少种不同爬法。 分析这一问题实际上是一个整数有序可重复拆分问题，通过递归思想求解： f(n) –&gt; n 级台阶的爬山总方法数 考虑在猴子到达最后一个台阶时，其所处位置在 n-1 台阶处或n-3 台阶处，故有 f(n) = f(n-1) + f(n-3) 因 n&gt;0 , 故： n=1 或 n=2 , f(1) = f(2) = 1 n = 3 , f(3) = 2 程序设计python 实现123456789101112131415161718#!/usr/bin/env python3import functools@functools.lru_cache()def recursion_count(n: &quot;int, and n &gt; 0&quot;): if n == 1 or n == 2: return 1 elif n == 3: return 2 elif n &gt; 3: return recursion_count(n-1) + recursion_count(n-3)if __name__ == &quot;__main__&quot;: a = recursion_count(50) print(a) # 122106097 functools.lru_cache 为python中一个缓存装饰器，其作用可以直接将函数或类方法的结果缓存住，后续调用则直接返回缓存的结果。 原型如下： @functools.lru_cache(maxsize=None, typed=False) maxsize –&gt; 最多缓存的次数，如果为 None，则无限制，设置为 2 的幂时，性能最佳 typed=True –&gt; 不同参数类型的调用将分别缓存，例如 f(3) 和 f(3.0)。(注意，在 functools32 中没有此参数) LRU (Least Recently Used，最近最少使用) 算法是一种缓存淘汰策略。其根据数据的历史访问记录来进行淘汰，核心思想是，“如果数据最近被访问过，那么将来被访问的几率也更高”。该算法最初为操作系统中一种内存管理的页面置换算法，主要用于找出内存中较久时间没有使用的内存块，将其移出内存从而为新数据提供空间。]]></content>
      <categories>
        <category>math</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python 通过某个字段将记录分组]]></title>
    <url>%2Fpython%2Ftips%2Fck9bgz85u00ftqov7nqpr0g32.html</url>
    <content type="text"><![CDATA[问题你有一个字典或者实例的序列，然后你想根据某个特定的字段比如 date 来分组迭代访问。 实现通过 itertools.groupby() 函数实现上述需求 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&gt;&gt;&gt; from itertools import groupby&gt;&gt;&gt; from operator import itemgetter&gt;&gt;&gt; import pprint&gt;&gt;&gt; rows = [ &#123;&apos;address&apos;: &apos;5412 N CLARK&apos;, &apos;date&apos;: &apos;07/01/2012&apos;&#125;, &#123;&apos;address&apos;: &apos;5148 N CLARK&apos;, &apos;date&apos;: &apos;07/04/2012&apos;&#125;, &#123;&apos;address&apos;: &apos;5800 E 58TH&apos;, &apos;date&apos;: &apos;07/02/2012&apos;&#125;, &#123;&apos;address&apos;: &apos;2122 N CLARK&apos;, &apos;date&apos;: &apos;07/03/2012&apos;&#125;, &#123;&apos;address&apos;: &apos;5645 N RAVENSWOOD&apos;, &apos;date&apos;: &apos;07/02/2012&apos;&#125;, &#123;&apos;address&apos;: &apos;1060 W ADDISON&apos;, &apos;date&apos;: &apos;07/02/2012&apos;&#125;, &#123;&apos;address&apos;: &apos;4801 N BROADWAY&apos;, &apos;date&apos;: &apos;07/01/2012&apos;&#125;, &#123;&apos;address&apos;: &apos;1039 W GRANVILLE&apos;, &apos;date&apos;: &apos;07/04/2012&apos;&#125;,]# 先堆 rows 安date进行排序&gt;&gt;&gt; rows.sort(key=itemgetter(&apos;date&apos;))# rows 按需后输出结果&gt;&gt;&gt; pprint.pprint(rows)[&#123;&apos;address&apos;: &apos;5412 N CLARK&apos;, &apos;date&apos;: &apos;07/01/2012&apos;&#125;, &#123;&apos;address&apos;: &apos;4801 N BROADWAY&apos;, &apos;date&apos;: &apos;07/01/2012&apos;&#125;, &#123;&apos;address&apos;: &apos;5800 E 58TH&apos;, &apos;date&apos;: &apos;07/02/2012&apos;&#125;, &#123;&apos;address&apos;: &apos;5645 N RAVENSWOOD&apos;, &apos;date&apos;: &apos;07/02/2012&apos;&#125;, &#123;&apos;address&apos;: &apos;1060 W ADDISON&apos;, &apos;date&apos;: &apos;07/02/2012&apos;&#125;, &#123;&apos;address&apos;: &apos;2122 N CLARK&apos;, &apos;date&apos;: &apos;07/03/2012&apos;&#125;, &#123;&apos;address&apos;: &apos;5148 N CLARK&apos;, &apos;date&apos;: &apos;07/04/2012&apos;&#125;, &#123;&apos;address&apos;: &apos;1039 W GRANVILLE&apos;, &apos;date&apos;: &apos;07/04/2012&apos;&#125;]# 对 rows 进行分组 &gt;&gt;&gt; for date, items in groupby(rows, key=itemgetter(&apos;date&apos;)): print(date) for i in items: print(&apos; &apos;, i) 07/01/2012 &#123;&apos;address&apos;: &apos;5412 N CLARK&apos;, &apos;date&apos;: &apos;07/01/2012&apos;&#125; &#123;&apos;address&apos;: &apos;4801 N BROADWAY&apos;, &apos;date&apos;: &apos;07/01/2012&apos;&#125;07/02/2012 &#123;&apos;address&apos;: &apos;5800 E 58TH&apos;, &apos;date&apos;: &apos;07/02/2012&apos;&#125; &#123;&apos;address&apos;: &apos;5645 N RAVENSWOOD&apos;, &apos;date&apos;: &apos;07/02/2012&apos;&#125; &#123;&apos;address&apos;: &apos;1060 W ADDISON&apos;, &apos;date&apos;: &apos;07/02/2012&apos;&#125;07/03/2012 &#123;&apos;address&apos;: &apos;2122 N CLARK&apos;, &apos;date&apos;: &apos;07/03/2012&apos;&#125;07/04/2012 &#123;&apos;address&apos;: &apos;5148 N CLARK&apos;, &apos;date&apos;: &apos;07/04/2012&apos;&#125; &#123;&apos;address&apos;: &apos;1039 W GRANVILLE&apos;, &apos;date&apos;: &apos;07/04/2012&apos;&#125; groupby() 函数扫描整个序列并且查找连续相同值（或者根据指定 key 函数返回值相同）的元素序列。 在每次迭代的时候，它会返回一个值和一个迭代器对象， 这个迭代器对象可以生成元素值全部等于上面那个值的组中所有对象。 一个非常重要的准备步骤是要根据指定的字段将数据排序。 因为 groupby() 仅仅检查连续的元素，如果事先并没有排序完成的话，分组函数将得不到想要的结果。 Referencehttps://python3-cookbook.readthedocs.io/zh_CN/latest/c01/p15_group_records_based_on_field.html]]></content>
      <categories>
        <category>python</category>
        <category>tips</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python 映射名称到序列元素]]></title>
    <url>%2Fpython%2Ftips%2Fck9bgz85o00fnqov7yu4tm1lj.html</url>
    <content type="text"><![CDATA[问题你有一段通过下标访问列表或者元组中元素的代码，但是这样有时候会使得你的代码难以阅读， 于是你想通过名称来访问元素。 实现通过 collections.namedtuple() 函数实现上述问题。 这个函数实际上是一个返回 Python 中标准元组类型子类的一个工厂方法。 你需要传递一个类型名和你需要的字段给它，然后它就会返回一个类，你可以初始化这个类，为你定义的字段传递值等。 代码示例： 123456789101112&gt;&gt;&gt; from collections import namedtuple&gt;&gt;&gt; Subscriber = namedtuple(&apos;Subscriber&apos;, [&apos;addr&apos;, &apos;joined&apos;])&gt;&gt;&gt; sub = Subscriber(&apos;jonesy@example.com&apos;, &apos;2012-10-19&apos;)&gt;&gt;&gt; subSubscriber(addr=&apos;jonesy@example.com&apos;, joined=&apos;2012-10-19&apos;)&gt;&gt;&gt; sub.addr&apos;jonesy@example.com&apos;&gt;&gt;&gt; sub.joined&apos;2012-10-19&apos;注：尽管 namedtuple 的实例看起来像一个普通的类实例，但是它跟元组类型是可交换的，支持所有的普通元组操作，比如索引和解压。 说明123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&gt;&gt;&gt; from collections import namedtuple&gt;&gt;&gt; Subscriber = namedtuple(&apos;Subscriber&apos;, [&apos;addr&apos;, &apos;joined&apos;])&gt;&gt;&gt; sub = Subscriber(&apos;jonesy@example.com&apos;, &apos;2012-10-19&apos;)&gt;&gt;&gt; subSubscriber(addr=&apos;jonesy@example.com&apos;, joined=&apos;2012-10-19&apos;)# 实例方法&gt;&gt;&gt; [x for x in dir(sub) if &quot;__&quot; not in x][&apos;_asdict&apos;, &apos;_fields&apos;, &apos;_fields_defaults&apos;, &apos;_make&apos;, &apos;_replace&apos;, &apos;addr&apos;, &apos;count&apos;, &apos;index&apos;, &apos;joined&apos;]# sub._asdict() Return a new OrderedDict which maps field names to their values.&gt;&gt;&gt; sub._asdict()OrderedDict([(&apos;addr&apos;, &apos;jonesy@example.com&apos;), (&apos;joined&apos;, &apos;2012-10-19&apos;)])# sub._fields Return a fileds&gt;&gt;&gt; sub._fields(&apos;addr&apos;, &apos;joined&apos;)# _replace(_self, **kwds) Return a new Subscriber object replacing specified fields with new values&gt;&gt;&gt; sub._replace(joined=&apos;2018-10-10&apos;)Subscriber(addr=&apos;jonesy@example.com&apos;, joined=&apos;2018-10-10&apos;)# _make(iterable) from builtins.type Make a new Subscriber object from a sequence or iterable&gt;&gt;&gt; sub._make((&apos;xiai@qq.com&apos;, &apos;2018-10-11&apos;))Subscriber(addr=&apos;xiai@qq.com&apos;, joined=&apos;2018-10-11&apos;)# addr Alias for field number 0&gt;&gt;&gt; sub.addr&apos;jonesy@example.com&apos;# joined Alias for field number 1&gt;&gt;&gt; sub.joined&apos;2012-10-19&apos;# count(self, value, /) Return number of occurrences of value.# index(self, value, start=0, stop=9223372036854775807, /) Return first index of value. Raises ValueError if the value is not present.]]></content>
      <categories>
        <category>python</category>
        <category>tips</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python 序列中出现次数最多的元素]]></title>
    <url>%2Fpython%2Ftips%2Fck9bgz85i00fhqov7t5zpblma.html</url>
    <content type="text"><![CDATA[问题怎样找出一个序列中出现次数最多的元素呢？ 实现通过 collections.Counter 类来实现上述需求， 示例： 123456789101112131415&gt;&gt;&gt; from collections import Counter&gt;&gt;&gt; words = [ &apos;look&apos;, &apos;into&apos;, &apos;my&apos;, &apos;eyes&apos;, &apos;look&apos;, &apos;into&apos;, &apos;my&apos;, &apos;eyes&apos;, &apos;the&apos;, &apos;eyes&apos;, &apos;the&apos;, &apos;eyes&apos;, &apos;the&apos;, &apos;eyes&apos;, &apos;not&apos;, &apos;around&apos;, &apos;the&apos;, &apos;eyes&apos;, &quot;don&apos;t&quot;, &apos;look&apos;, &apos;around&apos;, &apos;the&apos;, &apos;eyes&apos;, &apos;look&apos;, &apos;into&apos;, &apos;my&apos;, &apos;eyes&apos;, &quot;you&apos;re&quot;, &apos;under&apos;]&gt;&gt;&gt; word_counts = Counter(words)&gt;&gt;&gt; word_countsCounter(&#123;&apos;eyes&apos;: 8, &apos;the&apos;: 5, &apos;look&apos;: 4, &apos;into&apos;: 3, &apos;my&apos;: 3, &apos;around&apos;: 2, &apos;not&apos;: 1, &quot;don&apos;t&quot;: 1, &quot;you&apos;re&quot;: 1, &apos;under&apos;: 1&#125;)# 出现频率最高的3个单词&gt;&gt;&gt; word_counts.most_common(3)[(&apos;eyes&apos;, 8), (&apos;the&apos;, 5), (&apos;look&apos;, 4)] 说明123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&gt;&gt;&gt; from collections import Counter# 统计words中单词出现频率&gt;&gt;&gt; word_counts = Counter(&apos;hello world&apos;)&gt;&gt;&gt; word_countsCounter(&#123;&apos;l&apos;: 3, &apos;o&apos;: 2, &apos;h&apos;: 1, &apos;e&apos;: 1, &apos; &apos;: 1, &apos;w&apos;: 1, &apos;r&apos;: 1, &apos;d&apos;: 1&#125;)# word_counts 示例中的方法&gt;&gt;&gt; dir(word_counts)[&apos;_keep_positive&apos;, &apos;clear&apos;, &apos;copy&apos;, &apos;elements&apos;, &apos;fromkeys&apos;, &apos;get&apos;, &apos;items&apos;, &apos;keys&apos;, &apos;most_common&apos;, &apos;pop&apos;, &apos;popitem&apos;, &apos;setdefault&apos;, &apos;subtract&apos;, &apos;update&apos;, &apos;values&apos;]# word_counts.copy() Return a shallow copy.&gt;&gt;&gt; word_counts.copy()Counter(&#123;&apos;l&apos;: 3, &apos;o&apos;: 2, &apos;h&apos;: 1, &apos;e&apos;: 1, &apos; &apos;: 1, &apos;w&apos;: 1, &apos;r&apos;: 1, &apos;d&apos;: 1&#125;)# word_counts.elements() Iterator over elements repeating each as many times as its count.&gt;&gt;&gt; word_counts.elements()&lt;itertools.chain object at 0x000002516523E5F8&gt;&gt;&gt;&gt; list(word_counts.elements())[&apos;h&apos;, &apos;e&apos;, &apos;l&apos;, &apos;l&apos;, &apos;l&apos;, &apos;o&apos;, &apos;o&apos;, &apos; &apos;, &apos;w&apos;, &apos;r&apos;, &apos;d&apos;]# word_counts.most_common(n=None) List the n most common elements and their counts from the most common to the least. If n is None, then list all element counts&gt;&gt;&gt; word_counts.most_common(n=2)[(&apos;l&apos;, 3), (&apos;o&apos;, 2)]# word_counts.subtract(*args, **kwds) Like dict.update() but subtracts counts instead of replacing them. Counts can be reduced below zero. Both the inputs and outputs are allowed to contain zero and negative counts.&gt;&gt;&gt; word_counts = Counter(&apos;hello world&apos;)&gt;&gt;&gt; word_counts.subtract(&apos;ll ooo&apos;)&gt;&gt;&gt; word_countsCounter(&#123;&apos;h&apos;: 1, &apos;e&apos;: 1, &apos;l&apos;: 1, &apos;w&apos;: 1, &apos;r&apos;: 1, &apos;d&apos;: 1, &apos;o&apos;: -1, &apos; &apos;: -1&#125;)# word_counts.update(*args, **kwds) Like dict.update() but add counts instead of replacing them.&gt;&gt;&gt; word_counts.update(&apos;ll ooo&apos;)&gt;&gt;&gt; word_countsCounter(&#123;&apos;l&apos;: 3, &apos;o&apos;: 2, &apos;h&apos;: 1, &apos;e&apos;: 1, &apos;w&apos;: 1, &apos;r&apos;: 1, &apos;d&apos;: 1, &apos; &apos;: 0&#125;)# word_counts.clear() Remove all items from D.# word_counts.get(key, default=None) Return the value for key if key is in the dictionary, else default.# word_counts.items() a set-like object providing a view on word_counts&apos;s items# word_counts.keys() a set-like object providing a view on word_counts&apos;s keys# word_counts.pop(k[,d]) v, remove specified key and return the corresponding value. If key is not found, d is returned if given, otherwise KeyError is raised# word_counts.popitem() (k, v), remove and return some (key, value) pair as a 2-tuple; but raise KeyError if word_counts is empty.# word_counts.etdefault(key, default=None) Insert key with a value of default if key is not in the dictionary. Return the value for key if key is in the dictionary, else default.# word_counts.values() an object providing a view on D&apos;s values]]></content>
      <categories>
        <category>python</category>
        <category>tips</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python 合并多个字典或映射]]></title>
    <url>%2Fpython%2Ftips%2Fck9bgz85c00fbqov7d8xcpkrb.html</url>
    <content type="text"><![CDATA[问题现在有多个字典或者映射，你想将它们从逻辑上合并为一个单一的映射后执行某些操作， 比如查找值或者检查某些键是否存在。 实现通过 collections 模块中的 ChainMap 类来实现。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&gt;&gt;&gt; from collections import ChainMap&gt;&gt;&gt; a = &#123;&apos;x&apos;: 1, &apos;z&apos;: 3 &#125;&gt;&gt;&gt; b = &#123;&apos;y&apos;: 2, &apos;z&apos;: 4 &#125;&gt;&gt;&gt; merge = ChainMap(a, b) # merge 具有 dict 的一般特性， 可以用操作字典的方式操作它。&gt;&gt;&gt; maps = merge.maps[&#123;&apos;x&apos;: 1, &apos;z&apos;: 3&#125;, &#123;&apos;y&apos;: 2, &apos;z&apos;: 4&#125;]# 操作方法# 下述方法中 D is merge&gt;&gt;&gt; [x for x in dir(merge) if &apos;__&apos; not in x][&apos;_abc_impl&apos;, &apos;clear&apos;, &apos;copy&apos;, &apos;fromkeys&apos;, &apos;get&apos;, &apos;items&apos;, &apos;keys&apos;, &apos;maps&apos;, &apos;new_child&apos;, &apos;parents&apos;, &apos;pop&apos;, &apos;popitem&apos;, &apos;setdefault&apos;, &apos;update&apos;, &apos;values&apos;]# merge.clear() Clear maps[0], leaving maps[1:] intact.&gt;&gt;&gt; merge.clear()&gt;&gt;&gt; a&#123;&#125;&gt;&gt;&gt; b&#123;&apos;y&apos;: 2, &apos;z&apos;: 4&#125;&gt;&gt;&gt; mergeChainMap(&#123;&#125;, &#123;&apos;y&apos;: 2, &apos;z&apos;: 4&#125;)# merge.copy(self) New ChainMap or subclass with a new copy of maps[0] and refs to maps[1:]# merge.get(key, default=None) D.get(k[,d]) -&gt; D[k] if k in D, else d. d defaults to None.# merge.new_child(m=None) New ChainMap with a new map followed by all previous maps. If no map is provided, an empty dict is used.# merge.pop(key, *args) Remove *key* from maps[0] and return its value. Raise KeyError if *key* not in maps[0].# merge.popitem() Remove and return an item pair from maps[0]. Raise KeyError is maps[0] is empty.# merge.fromkeys(iterable, *args) from abc.ABCMeta Create a ChainMap with a single dict created from the iterable.# merge.parents New ChainMap from maps[1:].# merge.setdefault(key, default=None) D.setdefault(k[,d]) -&gt; D.get(k,d), also set D[k]=d if k not in D and add in maps[0]# merge.update(*args, **kwds) D.update([E, ]**F) -&gt; None. Update D from mapping/iterable E and F. If E present and has a .keys() method, does: for k in E: D[k] = E[k] If E present and lacks .keys() method, does: for (k, v) in E: D[k] = v In either case, this is followed by: for k, v in F.items(): D[k] = v# merge.items() D.items() -&gt; a set-like object providing a view on D&apos;s items# merge.keys() D.keys() -&gt; a set-like object providing a view on D&apos;s keys# merge.values() D.values() -&gt; an object providing a view on D&apos;s values 说明 一个 ChainMap 接受多个字典并将它们在逻辑上变为一个字典。这些字典并不是真的合并在一起了， ChainMap 类只是在内部创建了一个容纳这些字典的列表并重新定义了一些常见的字典操作来遍历这个列表。 如果出现重复键，那么第一次出现的映射值会被返回。 对于字典的更新或删除操作总是影响的是列表中第一个字典。 与 update() 方法将两个字典合并不同的是，ChainMap 使用原来的字典，它自己不创建新的字典。故原字典改变，ChainMap 创建的类字典也会跟着改变。]]></content>
      <categories>
        <category>python</category>
        <category>tips</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python import 原理]]></title>
    <url>%2Fpython%2Fck9bgz7qy007qqov74zvngoz1.html</url>
    <content type="text"><![CDATA[本文测试环境为python3。这里先简单介绍下与 import 导入相关的概念。 前期铺垫python module （python 模块） module 定义 是一个以 .py、.pyo、.pyc、.pyd、.so、.dll等结尾的文件； 文件内包含了Python定义的变量、函数、类和及其它可执行语句。 module 来源 Python内置的模块（标准库） 第三方模块 自定义模块 module 使用 当做脚本直接运行 12345678910111213141516171819# test_script.py#!/usr/bin/python3def func(): print(&quot;Hi, I am function&quot;)class TestClass(object): def func(self): print(&quot;Hi, I am class&quot;)if __name__ == &quot;__main__&quot;: func() TestClass().func()[root@hadoop-centos-01 python_exm]# python test_script.pyHi, I am functionHi, I am class 导入其它模块 以上述test.py模块为例 123456&gt;&gt;&gt; import test_script&gt;&gt;&gt; test_script.func()Hi, I am function&gt;&gt;&gt; test_script.TestClass().func()Hi, I am class 123456&gt;&gt;&gt; from test_script import func, TestClass&gt;&gt;&gt; func()Hi, I am function&gt;&gt;&gt; TestClass().func()Hi, I am class 注：若发生导包错误，如下： 1234&gt;&gt;&gt; import test_scriptTraceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;ModuleNotFoundError: No module named &apos;test_script&apos; 需添加当前脚本的路径到 sys.path中，如下： 123456789&gt;&gt;&gt; import sys&gt;&gt;&gt; sys.path.append(&apos;/opt/test/python_exm&apos;)# 重新导入，无错误产生&gt;&gt;&gt; import test_script&gt;&gt;&gt; dir(test_script)[&apos;TestClass&apos;, &apos;__builtins__&apos;, &apos;__cached__&apos;, &apos;__doc__&apos;, &apos;__file__&apos;, &apos;__loader__&apos;, &apos;__name__&apos;, &apos;__package__&apos;, &apos;__spec__&apos;, &apos;func&apos;]注：sys.path是python的搜索模块的路径集，其为一个list python package （python 包） package 定义 是一个包含了 __init__.py 文件的文件夹; __init __.py 文件用于组织包（package），方便管理各个模块之间的引用、控制着包的导入行为; __init __.py 文件可以为空，但必须存在； __init __.py 文件在包被导入时会自动运行 所有的包都是模块，但并非所有模块都是包。 或者换句话说，包只是一种特殊的模块。任何具有 __path__ 属性的模块都会被当作是包。 示例： 12345678910test_package/├── __init__.py├── pack1│ ├── __init__.py│ ├── mod1.py│ └── mod2.py└── pack2 ├── __init__.py ├── mod1.py └── mod2.py package 导入 123import test_package注：通过此种方式导入包，其实际是运行了 __init__.py 文件， 故将需要导入的模块导入到 __init__.py 文件即可 1from test_package import pack1, pack2 命名空间 定义 名称到对象的映射。 命名空间是一个字典的实现，键为变量名，值是变量对应的值。 各个命名空间是独立没有关系的，一个命名空间中不能有重名，但是不同的命名空间可以重名而没有任何影响。 分类 局部命名空间（Local Namespace），函数运行时创建，记录了函数中定义的所有变量，包括函数的入参、内部定义的局部变量。 全局命名空间（Global Namespace），每个模块加载时创建，记录了模块中定义的变量，包括模块中定义的函数、类、其他导入的模块、模块级的变量与常量。 内建命名空间（Built-in Namespace ），任何模块均可以访问，放着内置的函数和异常。 生命周期 Local Namespace 在函数被调用时创建，结束时销毁。 Global Namespace 在模块被加载时创建，通常一直保留直到python解释器退出。 Built-inNamespace 在python解释器启动时创建，一直保留直到解释器退出。 创建顺序 内建命名空间 -&gt; 全局命名空间 -&gt; 局部命名空间 销毁顺序 局部命名空间 -&gt; 全局命名空间 -&gt; 内建命名空间 变量查找顺序 局部命名空间 -&gt; 全局命名空间 -&gt; 内建命名空间 若在这些命名空间找不到相关变量，Python会放弃查找并且引发一个NameError异常 访问 局部命名空间可以通过 locals() 访问 locals()返回一个键/值的dict，键为变量名字（str形式），值为该变量的实际值 全局命名空间可以用 globals() 访问 注： 123456781. 模块的命名空间不仅包括模块的常量和变量，还包括模块中定义的函数和类。此外还包括，任何被导入模块中的东西。2. 内置命名同样放置在一个模块中，被称作builtins3. from module import function 和import module不同 使用import module,模块被导入，但是它仍保持自己的命名空间，所以需要模块名来访问函数或者属性（例如module.function）； 使用from module import function ，实际上是直接从另一个模块中导入相关属性或函数，因此可以直接访问而不需要知道它们的来源。使用globals函数可以实现。4. locals是只读的(不能改变)，globals不是（可以改变） locals没有返回局部命名空间，它返回的是一个拷贝。所以对它进行改变，对局部命名空间中的变量值没有影响 globals返回全部实际命名空间，而非拷贝。所以globals返回的dict任何改动都会影响到全局变量 作用域 定义 访问变量时所查找的区域，python中作用域规则可以简单的归纳为LEGB原则： 1234L：local，局部作用域，即函数中定义的变量；E：enclosing，外部嵌套函数作用域，即包含此函数的上级函数的局部作用域，但不是全局的；G：global，全局作用域，就是模块级别定义的变量；B：built-in，内建作用域，系统固定模块里面的变量，比如：int，bytearray等 查找顺序 局部作用域 -&gt;外部嵌套函数作用域 -&gt; 全局作用域 -&gt; 内建作用域，即 L -&gt; E -&gt; G -&gt; B global 关键字 global 关键字用来在函数或其他局部作用域中使用全局变量。如果不修改全局变量，根据变量查找规则，也可以不使用global关键字。 123456789101112131415#!/usr/bin/env python3gloabl_var = 1def func1(): print(gloal_var) # 若不修改全局变量，可直接使用 def func2(): global gloabl_var gloabl_var += 1 print(gloabl_var)if __name__ == &quot;__main__&quot;: func1() # 1 func2() # 2 global 关键字用来在函数或其他局部作用域中声明全局变量。 1234567891011#!/usr/bin/env python3 def func(): global gloabl_var # 声明的全局变量可在全局命名空间内使用 gloabl_var = 1 print(gloabl_var) print(gloabl_var) # 1if __name__ == &quot;__main__&quot;： func() nonlocal关键字 nonlocal 关键字用来在函数或其他作用域中使用外层(非全局)变量。 123456789101112#!/usr/bin/env python3def func(): count = 0 def counter(): nonlocal count count += 1 return count return counter if __name__ == &quot;__main__&quot;: func()() # 1 注：Python 中只有模块（module），类（class）以及函数（def、lambda）才会引入新的作用域，其它的代码块（如 if ~ elif ~ else、try ~ except、for ~ else 、while ~ else等）是不会引入新的作用域的，故在这些语句内定义的变量，外部也可以访问。 import 导入Python import 搜索路径1. 在当前目录下搜索该模块 2. python安装目录，UNIX下，默认路径一般为/usr/local/lib/python/ 3. 在 Python 安装路径的 lib 库中搜索 4. python3.x 中.pth 文件内容注：import 搜索路径是按照 sys.path中的路径列表来搜索的。 12345&gt;&gt;&gt; import sys&gt;&gt;&gt; sys.path[&apos;&apos;, &apos;/usr/local/python2/lib/python27.zip&apos;, &apos;/usr/local/python2/lib/python2.7&apos;, &apos;/usr/local/python2/lib/python2.7/plat-linux2&apos;, &apos;/usr/local/python2/lib/python2.7/lib-tk&apos;, &apos;/usr/local/python2/lib/python2.7/lib-old&apos;, &apos;/usr/local/python2/lib/python2.7/lib-dynload&apos;, &apos;/usr/local/python2/lib/python2.7/site-packages&apos;, &apos;/usr/local/python2/lib/python2.7/site-packages/setuptools-41.0.1-py2.7.egg&apos;, &apos;/usr/local/python2/lib/python2.7/site-packages/pip-19.1.1-py2.7.egg&apos;]# sys.path 是一个list, 第一项为一个空字符串，代表当前目录，可通过 os.getcwd() 查看当前所在目录。 Python import 导入步骤​ python 所有加载的模块信息都存放在 sys.modules结构中，当 import 一个模块时，会按如下步骤来进行： 如果是 import A，检查 sys.modules中是否已经有 A，如果有则不加载，如果没有则为 A 创建 module 对象，并加载 A 到 sys.modules 中 如果是 from A import B，先为 A 创建 module 对象，再解析A，从中寻找B并填充到 A 的 __dict__中 Python import 导入方式Python 相对导入与绝对导入是相对于包内导入而言的。所谓包内导入是指包内的模块导入包内部的模块。 绝对导入 12345import A.B 或 from A import B注：module A的路径应在 sys.path 列表中，否则会引发 ModuleNotFoundError 异常 相对导入 123456from . import B 或 from ..A import B注：.代表当前模块，..代表上层模块，...代表上上层模块，依次类推。 相对导入时不能超过包的顶层，即不能导入包以外的模块或包 注： Python2.x 缺省为相对路径导入，Python3.x 缺省为绝对路径导入。 相对导入可以避免硬编码带来的维护问题，例如我们改了某一顶层包的名，那么其子包所有的导入就都不能用了。 绝对导入可以避免导入子包覆盖掉标准库模块（由于名字相同，发生冲突）。如果在 Python2.x 中要默认使用绝对导入，可以在文件开头加入如下语句： 1from__future__ import absolute_import Python 导包异常处理 示例： 1234567891011121314151617181920212223242526272829303132333435363738test_package/├── __init__.py├── pack1│ ├── __init__.py│ ├── mod1.py│ └── mod2.py└── pack2 ├── __init__.py ├── mod1.py └── mod2.py# 在根目录下的 __init__.py 文件写入下列语句 import test_package.pack1 import test_package.pack2 在使用 import test_package 导入包时，可自行导入 pack1 和 pack2 两个包， &gt;&gt;&gt; import test_package &gt;&gt;&gt; dir(test_package) [&apos;__builtins__&apos;, &apos;__cached__&apos;, &apos;__doc__&apos;, &apos;__file__&apos;, &apos;__loader__&apos;, &apos;__name__&apos;, &apos;__package__&apos;, &apos;__path__&apos;, &apos;__spec__&apos;, &apos;pack1&apos;, &apos;pack2&apos;, &apos;test_package&apos;]# 在pack1 __init__.py 文件写入下列语句 import test_package.pack1.mod1 import test_package.pack1.mod2 在使用 from test_package import pack1 导入包时，可自行导入 pack1 包下的 mod1 和 mod2 模块 &gt;&gt;&gt; from test_package import pack1 &gt;&gt;&gt; dir(pack1) [&apos;__builtins__&apos;, &apos;__cached__&apos;, &apos;__doc__&apos;, &apos;__file__&apos;, &apos;__loader__&apos;, &apos;__name__&apos;, &apos;__package__&apos;, &apos;__path__&apos;, &apos;__spec__&apos;, &apos;mod1&apos;, &apos;mod2&apos;, &apos;test_package&apos;]# 在pack2 __init__.py 文件写入下列语句 from test_package.pack1.mod1 import pack1_func_1 from test_package.pack1.mod2 import pack1_func_2 在使用 from test_package import pack2 导入包时，可自行导入 pack2 包下的 mod1 和 mod2 模块中的pack1_func_1 和 pack1_func_2 函数 &gt;&gt;&gt; from test_package import pack1 &gt;&gt;&gt; dir(pack1) [&apos;__builtins__&apos;, &apos;__cached__&apos;, &apos;__doc__&apos;, &apos;__file__&apos;, &apos;__loader__&apos;, &apos;__name__&apos;, &apos;__package__&apos;, &apos;__path__&apos;, &apos;__spec__&apos;, &apos;mod1&apos;, &apos;mod2&apos;, &apos;pack1_func_1&apos;, &apos;pack1_func_2&apos;] 错误处理 ModuleNotFoundError: No module named ‘test_package’ 1234&gt;&gt;&gt; import test_packageTraceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;ModuleNotFoundError: No module named &apos;test_package&apos; ModuleNotFoundError 异常是由于找不到 test_package 包的路径造成的，解决方法： 在 sys.path中添加 test_package包所在的路径 12345try: import test_packageexcep ModuleNotFoundError: import sys sys.path.append(&apos;path&apos;) # path 为test_package所在的路径 将 test_package包所在的路径添加到PYTHONPATH环境变量中 12345cd ~;vim .bashrcexport PYTHONPATH=&apos;path&apos; # path为test_package所在的路径# 保存退出，并重新激活 source .bashrc ValueError: attempted relative import beyond top-level package 123456# 在pack2下的mod1.py通过 from ..pack1 import mod1 的方式导入pack1下的mod1， 并执行pack2下的mod1.py[root@hadoop-centos-01 pack2]# python3 mod1.pyTraceback (most recent call last): File &quot;mod1.py&quot;, line 3, in &lt;module&gt; from ..pack1 import mod1ValueError: attempted relative import beyond top-level package 处理方法参考： https://blog.csdn.net/sky453589103/article/details/78863050 Reference命名空间： ​ https://www.cnblogs.com/windlaughing/archive/2013/05/26/3100362.html ​ https://www.cnblogs.com/zhangxinhe/p/6963462.html 相对导入和绝对导入： ​ https://www.jb51.net/article/102252.htm ​ https://blog.csdn.net/weixin_38256474/article/details/81228492 ​ https://blog.csdn.net/gaifuxi9518/article/details/81038818]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python 删除序列相同元素并保持顺序]]></title>
    <url>%2Fpython%2Ftips%2Fck9bgz85500f5qov7hekkcqig.html</url>
    <content type="text"><![CDATA[问题怎样在一个序列上面保持元素顺序的同时消除重复的值？ 实现 如果序列上的值都是 hashable 类型，那么可以很简单的利用集合或者生成器来解决这个问题。比如： 12345678910def dedupe(items): seen = set() for item in items: if item not in seen: yield item seen.add(item)&gt;&gt;&gt; a = [1, 5, 2, 1, 9, 1, 5, 10]&gt;&gt;&gt; list(dedupe(a))[1, 5, 2, 9, 10] 如果序列上的值是不可 hashable 类型 123456789101112131415def dedupe(items, key=None): seen = set() for item in items: val = item if key is None else key(item) if val not in seen: yield item seen.add(val) &gt;&gt;&gt; a = [ &#123;&apos;x&apos;:1, &apos;y&apos;:2&#125;, &#123;&apos;x&apos;:1, &apos;y&apos;:3&#125;, &#123;&apos;x&apos;:1, &apos;y&apos;:2&#125;, &#123;&apos;x&apos;:2, &apos;y&apos;:4&#125;]&gt;&gt;&gt; list(dedupe(a, key=lambda d: (d[&apos;x&apos;],d[&apos;y&apos;])))[&#123;&apos;x&apos;: 1, &apos;y&apos;: 2&#125;, &#123;&apos;x&apos;: 1, &apos;y&apos;: 3&#125;, &#123;&apos;x&apos;: 2, &apos;y&apos;: 4&#125;]&gt;&gt;&gt; list(dedupe(a, key=lambda d: d[&apos;x&apos;]))[&#123;&apos;x&apos;: 1, &apos;y&apos;: 2&#125;, &#123;&apos;x&apos;: 2, &apos;y&apos;: 4&#125;]注：key参数指定了一个函数，将序列元素转换成 hashable 类型]]></content>
      <categories>
        <category>python</category>
        <category>tips</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python zip 与 dict]]></title>
    <url>%2Fpython%2Ftips%2Fck9bgz85100f2qov7ppvs26bc.html</url>
    <content type="text"><![CDATA[zip 实现字典求最大值、最小值、排序等 123456789101112131415161718192021222324252627282930&gt;&gt;&gt; prices = &#123; &apos;ACME&apos;: 45.23, &apos;AAPL&apos;: 612.78, &apos;IBM&apos;: 205.55, &apos;HPQ&apos;: 37.20, &apos;FB&apos;: 10.75&#125;# dict value min, return v, k&gt;&gt;&gt; min(zip(prices.values(), prices.keys()))(10.75, &apos;FB&apos;)# dict value min max, return v, k&gt;&gt;&gt; min(zip(prices.values(), prices.keys()))(10.75, &apos;FB&apos;)# sorted by dict value&gt;&gt;&gt; sorted(zip(prices.values(), prices.keys()))[(10.75, &apos;FB&apos;), (37.2, &apos;HPQ&apos;), (45.23, &apos;ACME&apos;), (205.55, &apos;IBM&apos;), (612.78, &apos;AAPL&apos;)]注：zip() 函数创建的是一个迭代器，只能访问一次。# 在计算操作中使用到了 (值，键) 对。# 当多个实体拥有相同的值的时候，键会决定返回结果。 # 比如，在执行 min() 和 max() 操作的时候，如果恰巧最小或最大值有重复的，那么拥有最小或最大键的实体会返回&gt;&gt;&gt; prices = &#123; &apos;AAA&apos; : 45.23, &apos;ZZZ&apos;: 45.23 &#125;&gt;&gt;&gt; min(zip(prices.values(), prices.keys()))(45.23, &apos;AAA&apos;)&gt;&gt;&gt; max(zip(prices.values(), prices.keys()))(45.23, &apos;ZZZ&apos;)]]></content>
      <categories>
        <category>python</category>
        <category>tips</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python 实现一个优先级队列]]></title>
    <url>%2Fpython%2Ftips%2Fck9bgz84u00ewqov7c3116c3y.html</url>
    <content type="text"><![CDATA[实现一个优先级队列 问题 怎样实现一个按优先级排序的队列？ 并且在这个队列上面每次 pop 操作总是返回优先级最高的那个元素 实现 123456789101112131415161718import heapqclass PriorityQueue(object): def __init__(self): self._queue = [] self._index = 0 def push(self, itme, priority): heapq.heappush(self._queue, (-priority, self._index, item)) self._index += 1 def pop(self): heapq.heappop(self._queue)[-1] 注： 由于 push 和 pop 操作时间复杂度为 O(log N)，其中 N 是堆的大小，因此就算是 N 很大的时候它们运行速度也依旧很快； 优先级为负数的目的是使得元素按照优先级从高到低排序。 这个跟普通的按优先级从低到高排序的堆排序恰巧相反。 index 变量的作用是保证同等优先级元素的正确排序。 注：heapq 为python处理堆数据结构的一个模块，用法参考： [python heapq module] https://forgetst.github.io/2019/09/01/python-module-heapq/ Reference&emsp;&emsp;https://python3-cookbook.readthedocs.io/zh_CN/latest/index.html]]></content>
      <categories>
        <category>python</category>
        <category>tips</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python heapq module]]></title>
    <url>%2Fpython%2Fmodule%2Fck9bgz7zl009zqov7u45wehk2.html</url>
    <content type="text"><![CDATA[简介Python提供的关于堆的操作模块。 源码：Lib/heapq.py Python 提供的是基于小顶堆的操作，因此 Python 可以对 list 中的元素进行小顶堆排列，这样程序每次获取堆中元素时，总会取得堆中最小的元素。 有关堆的介绍：传送门 用法 heapq 模块包含的方法 123&gt;&gt;&gt; import heapq&gt;&gt;&gt; heapq.__all__[&apos;heappush&apos;, &apos;heappop&apos;, &apos;heapify&apos;, &apos;heapreplace&apos;, &apos;merge&apos;, &apos;nlargest&apos;, &apos;nsmallest&apos;, &apos;heappushpop&apos;] 用法 123456heap = [] # creates an empty heapheappush(heap, item) # pushes a new item on the heapitem = heappop(heap) # pops the smallest item from the heapitem = heap[0] # smallest item on the heap without popping itheapify(x) # transforms list into a heap, in-place, in linear timeitem = heapreplace(heap, item) # pops and returns smallest item, and adds new item; the heap size is unchanged 示例 创建一个堆 1234567891011121314&gt;&gt;&gt; import heapq# 创建一个堆# 方法一: 创建一个空的列表，然后向里面添加元素&gt;&gt;&gt; heap = []&gt;&gt;&gt; heapq.heappush(heap, 5)&gt;&gt;&gt; heap[5]# 方法二：将非空列表堆化&gt;&gt;&gt; heap = [7, 1, 2, 8, 6, 9, 10]&gt;&gt;&gt; heapq.heapify(heap)&gt;&gt;&gt; heap[0]1 方法使用 heapq.heapify(x)将list x 转换成堆。 1234&gt;&gt;&gt; import heapq&gt;&gt;&gt; heap = [7, 1, 2, 8, 6, 9, 10]&gt;&gt;&gt; heapq.heapify(heap) heapq.heappush(heap, item)将item的值加入 heap 中，保持堆的不变性。 123&gt;&gt;&gt; heapq.heappush(heap, -5)&gt;&gt;&gt; heap[-5, 1, 2, 6, 7, 9, 10, 8] heapq.heappop(heap)弹出并返回 heap 的最小的元素，保持堆的不变性。 如果堆为空，抛出 IndexError 。 使用 heap[0] ，可以只访问最小的元素而不弹出它。 1234&gt;&gt;&gt; heapq.heappop(heap)-5&gt;&gt;&gt; heap[1, 5, 2, 6, 7, 9, 10, 8] heapq.heappushpop(heap, item)将 item 放入堆中，然后弹出并返回 heap 的最小元素。 该组合操作比先调用 heappush() 再调用 heappop() 运行起来更有效率。 1234&gt;&gt;&gt; heapq.heappushpop(heap, 3) 1&gt;&gt;&gt; heap[2, 5, 3, 6, 7, 9, 10, 8] heapq.heapreplace(heap, item)弹出并从堆中返回最小的项，然后将 item 放入堆中。如果堆是空的，则引发 IndexError。该组合操作先调用 heappop() 在调用 heappush() 更有效。 注：返回的值可能大于添加的项。如果不希望这样，可以用 heapq.heappushpop()。 1234&gt;&gt;&gt; heapq.heapreplace(heap, -2) 2&gt;&gt;&gt; heap[-2, 5, 3, 6, 7, 9, 10, 8] heapq.merge(*iterables, key=None, reverse=False)将多个有序的输入（从小到大排序）合并到一个有序的输出中。返回已排序值的迭代器。 key：比较函数，该参数用于从每个输入元素中提取一个比较键。默认值是None(直接比较元素)。reverse：布尔值。如果设置为True，要实现逆序排列，所有的iterables都必须从大到小排序 1234567891011# 从小到大排序&gt;&gt;&gt; a = [1, 3, 5] &gt;&gt;&gt; b = [2, 4, 6] &gt;&gt;&gt; list(heapq.merge(a, b)) [1, 2, 3, 4, 5, 6]# 从大到下排序&gt;&gt;&gt; a = [5, 3, 1] &gt;&gt;&gt; b = [6, 4, 2]&gt;&gt;&gt; list(heapq.merge(a, b, reverse=True))[6, 5, 4, 3, 2, 1] heapq.nlargest(n, iterable, key=None)从iterable定义的数据集中返回一个包含n个最大元素的列表。 key: 比较函数，该参数用于从iterable中的每个元素中提取一个比较键 等价于: sordered (iterable, key=key, reverse=True)[:n] 12345678&gt;&gt;&gt; import heapq&gt;&gt;&gt; heap = [7, 1, 2, 8, 6, 9, 10] &gt;&gt;&gt; heapq.nlargest(2, heap)[10, 9]&gt;&gt;&gt; heapq.nsmallest(2, heap) [1, 2] heapq.nsmallest(n, iterable, key=None)从iterable定义的数据集中返回一个包含n个最小元素的列表。 key: 比较函数，该参数用于从iterable中的每个元素中提取一个比较键 等价于: sordered (iterable, key=key)[:n] 12345&gt;&gt;&gt; import heapq&gt;&gt;&gt; heap = [7, 1, 2, 8, 6, 9, 10]&gt;&gt;&gt; heapq.nsmallest(2, heap)[1, 2]]]></content>
      <categories>
        <category>python</category>
        <category>module</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>module</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python 字典中的键映射多个值]]></title>
    <url>%2Fpython%2Ftips%2Fck9bgz85900f8qov7dgc6c01l.html</url>
    <content type="text"><![CDATA[问题实现一个键对应多个值的字典 实现一个字典就是一个键对应一个单值的映射。如果想要一个键映射多个值，那么就需要将这多个值放到另外的容器中， 比如列表或者集合里面。根据不同的需求选择不同的容器。 collections 模块中的 defaultdict 可以很方便的实现上述需求。 123456789101112131415&gt;&gt;&gt; from collections import defaultdict # defualt list&gt;&gt;&gt; d[&apos;a&apos;].append(&apos;1&apos;)&gt;&gt;&gt; ddefaultdict(&lt;class &apos;list&apos;&gt;, &#123;&apos;a&apos;: [&apos;1&apos;]&#125;)&gt;&gt;&gt; d[&apos;a&apos;].append(&apos;2&apos;)&gt;&gt;&gt; ddefaultdict(&lt;class &apos;list&apos;&gt;, &#123;&apos;a&apos;: [&apos;1&apos;, &apos;2&apos;]&#125;)# defualt tuple&gt;&gt;&gt; d = defaultdict(tuple)&gt;&gt;&gt; d[1] += (1, 2)&gt;&gt;&gt; ddefaultdict(&lt;class &apos;tuple&apos;&gt;, &#123;1: (1, 2)&#125;) 1234567&gt;&gt;&gt; d = &#123;&#125;&gt;&gt;&gt; d.setdefault(&apos;a&apos;, []).append(1)&gt;&gt;&gt; d&#123;&apos;a&apos;: [1]&#125;&gt;&gt;&gt; d.setdefault(&apos;a&apos;, []).append(2)&gt;&gt;&gt; d&#123;&apos;a&apos;: [1, 2]&#125;]]></content>
      <categories>
        <category>python</category>
        <category>tips</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python 实现一个顺序字典]]></title>
    <url>%2Fpython%2Ftips%2Fck9bgz85f00feqov7cfjufnb6.html</url>
    <content type="text"><![CDATA[问题你想创建一个字典，并且在迭代或序列化这个字典的时候能够控制元素的顺序。 实现通过 collections 模块中的 OrderedDict 类，可生成一个保持元素被插入时的顺序的字典，示例如下： 12345678910111213141516&gt;&gt;&gt; from collections import OrderedDict&gt;&gt;&gt; d = OrderedDict()&gt;&gt;&gt; d[&apos;foo&apos;] = 1&gt;&gt;&gt; d[&apos;bar&apos;] = 2&gt;&gt;&gt; d[&apos;spam&apos;] = 3&gt;&gt;&gt; d[&apos;grok&apos;] = 4# Outputs &gt;&gt;&gt; for k, v in d.items(): print(&apos;%s --&gt; %s&apos; % (k, v))foo --&gt; 1bar --&gt; 2spam --&gt; 3grok --&gt; 4 当你想要构建一个将来需要序列化或编码成其他格式的映射的时候， OrderedDict 是非常有用的。 比如，你想精确控制以 JSON 编码后字段的顺序，你可以先使用 OrderedDict 来构建这样的数据： 1234&gt;&gt;&gt; import json&gt;&gt;&gt; json.dumps(d)&apos;&#123;&quot;foo&quot;: 1, &quot;bar&quot;: 2, &quot;spam&quot;: 3, &quot;grok&quot;: 4&#125;&apos; 讨论OrderedDict 内部维护着一个根据键插入顺序排序的双向链表。每次当一个新的元素插入进来的时候， 它会被放到链表的尾部。对于一个已经存在的键的重复赋值不会改变键的顺序。 需要注意的是，一个 OrderedDict 的大小是一个普通字典的两倍，因为它内部维护着另外一个链表。 所以如果你要构建一个需要大量 OrderedDict 实例的数据结构的时候（比如读取 100,000 行 CSV 数据到一个 OrderedDict 列表中去）， 那么你就得仔细权衡一下是否使用 OrderedDict 带来的好处要大过额外内存消耗的影响。 Referencehttps://python3-cookbook.readthedocs.io/zh_CN/latest/c01/p07_keep_dict_in_order.html]]></content>
      <categories>
        <category>python</category>
        <category>tips</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The Python 魔法方法]]></title>
    <url>%2Fpython%2Fck9bgz7s4007zqov7r0egiv5y.html</url>
    <content type="text"><![CDATA[魔法方法，也叫做特殊方法，是指名称前面和后面都加上了双下划线的方法。 对python而言，下划线对解释器有特殊的意义，而且是内建标识符所使用的符号，故应慎用下划线开始的变量名。 python中，变量以单下划线和双下划线开始，有不同的含义： “单下划线” 开始的成员变量叫做保护变量，意思是只有类对象和子类对象自己能访问到这些变量； “双下划线” 开始的是私有成员，意思是只有类对象自己能访问，连子类对象也不能访问到这个数据。 基本属性1234567891011121314&gt;&gt;&gt; class TestClass(object): &apos;&apos;&apos;This is test class&apos;&apos;&apos; # 类属性&gt;&gt;&gt; TestClass.__doc__ # 查看类型帮助信息， &apos;This is test class&apos;&gt;&gt;&gt; TestClass.__name__ # 查看类型名称， &apos;TestClass&apos;&gt;&gt;&gt; TestClass.__module__ # 查看类型所在模块， &apos;__main__&apos;&gt;&gt;&gt; TestClass.__bases__ # 查看类型所继承的基类， (&lt;type &apos;object&apos;&gt;,) &gt;&gt;&gt; TestClass.__dict__ # 查看类型字典，存储所有类型成员信息。 # 实例属性&gt;&gt;&gt; TestClass().__class__ # 类型 &lt;class &apos;__main__.Class1&apos;&gt; &gt;&gt;&gt; TestClass().__module__ # 实例类型所在模块 &apos;__main__&apos; &gt;&gt;&gt; TestClass().__dict__ # 对象字典，存储所有实例成员信息。 &#123;&apos;i&apos;: 1234&#125; 基本方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119__new__(cls[, ...]) new 是在一个对象实例化的时候所调用的第一个方法 它的第一个参数是这个类，其他的参数是用来直接传递给 init 方法 new 决定是否要使用该 init 方法，因为 new 可以调用其他类的构造方法或者直接返回别的实例对象来作为本类的实例，如果 new 没有返回实例对象，则 init 不会被调用 new 主要是用于继承一个不可变的类型比如一个 tuple 或者 string__init__(self[, ...]) 构造器，当一个实例被创建的时候调用的初始化方法__del__(self) 析构器，当一个实例被销毁的时候调用的方法__call__(self[, args...]) 允许一个类的实例像函数一样被调用：x(a, b) 调用 x.__call__(a, b)__len__(self) 定义当被 len() 调用时的行为__repr__(self) 定义当被 repr() 调用时的行为__str__(self) 定义当被 str() 调用时的行为 类似于Java中toString方法__bytes__(self) 定义当被 bytes() 调用时的行为__hash__(self) 定义当被 hash() 调用时的行为__bool__(self) 定义当被 bool() 调用时的行为，应该返回 True 或 False__format__(self, format_spec) 定义当被 format() 调用时的行为有关属性__getattr__(self, name) 定义当用户试图获取一个不存在的属性时的行为__getattribute__(self, name) 定义当该类的属性被访问时的行为__setattr__(self, name, value) 定义当一个属性被设置时的行为__delattr__(self, name) 定义当一个属性被删除时的行为__dir__(self) 定义当 dir() 被调用时的行为__get__(self, instance, owner) 定义当描述符的值被取得时的行为__set__(self, instance, value) 定义当描述符的值被改变时的行为__delete__(self, instance) 定义当描述符的值被删除时的行为比较操作符__lt__(self, other) 定义小于号的行为：x &lt; y 调用 x.__lt__(y)__le__(self, other) 定义小于等于号的行为：x &lt;= y 调用 x.__le__(y)__eq__(self, other) 定义等于号的行为：x == y 调用 x.__eq__(y)__ne__(self, other) 定义不等号的行为：x != y 调用 x.__ne__(y)__gt__(self, other) 定义大于号的行为：x &gt; y 调用 x.__gt__(y)__ge__(self, other) 定义大于等于号的行为：x &gt;= y 调用 x.__ge__(y)算数运算符__add__(self, other) 定义加法的行为：+__sub__(self, other) 定义减法的行为：-__mul__(self, other) 定义乘法的行为：*__truediv__(self, other) 定义真除法的行为：/__floordiv__(self, other) 定义整数除法的行为：//__mod__(self, other) 定义取模算法的行为：%__divmod__(self, other) 定义当被 divmod() 调用时的行为__pow__(self, other[, modulo]) 定义当被 power() 调用或 ** 运算时的行为__lshift__(self, other) 定义按位左移位的行为：&lt;&lt;__rshift__(self, other) 定义按位右移位的行为：&gt;&gt;__and__(self, other) 定义按位与操作的行为：&amp;__xor__(self, other) 定义按位异或操作的行为：^__or__(self, other) 定义按位或操作的行为：|反运算__radd__(self, other) （与上方相同，当左操作数不支持相应的操作时被调用）__rsub__(self, other) （与上方相同，当左操作数不支持相应的操作时被调用）__rmul__(self, other) （与上方相同，当左操作数不支持相应的操作时被调用）__rtruediv__(self, other) （与上方相同，当左操作数不支持相应的操作时被调用）__rfloordiv__(self, other) （与上方相同，当左操作数不支持相应的操作时被调用）__rmod__(self, other) （与上方相同，当左操作数不支持相应的操作时被调用）__rdivmod__(self, other) （与上方相同，当左操作数不支持相应的操作时被调用）__rpow__(self, other) （与上方相同，当左操作数不支持相应的操作时被调用）__rlshift__(self, other) （与上方相同，当左操作数不支持相应的操作时被调用）__rrshift__(self, other) （与上方相同，当左操作数不支持相应的操作时被调用）__rxor__(self, other) （与上方相同，当左操作数不支持相应的操作时被调用）__ror__(self, other) （与上方相同，当左操作数不支持相应的操作时被调用）增量赋值运算__iadd__(self, other) 定义赋值加法的行为：+=__isub__(self, other) 定义赋值减法的行为：-=__imul__(self, other) 定义赋值乘法的行为：*=__itruediv__(self, other) 定义赋值真除法的行为：/=__ifloordiv__(self, other) 定义赋值整数除法的行为：//=__imod__(self, other) 定义赋值取模算法的行为：%=__ipow__(self, other[, modulo]) 定义赋值幂运算的行为：**=__ilshift__(self, other) 定义赋值按位左移位的行为：&lt;&lt;=__irshift__(self, other) 定义赋值按位右移位的行为：&gt;&gt;=__iand__(self, other) 定义赋值按位与操作的行为：&amp;=__ixor__(self, other) 定义赋值按位异或操作的行为：^=__ior__(self, other) 定义赋值按位或操作的行为：|=一元操作符__neg__(self) 定义正号的行为：+x__pos__(self) 定义负号的行为：-x__abs__(self) 定义当被 abs() 调用时的行为__invert__(self) 定义按位求反的行为：~x类型转换__complex__(self) 定义当被 complex() 调用时的行为（需要返回恰当的值）__int__(self) 定义当被 int() 调用时的行为（需要返回恰当的值）__float__(self) 定义当被 float() 调用时的行为（需要返回恰当的值）__round__(self[, n]) 定义当被 round() 调用时的行为（需要返回恰当的值）__index__(self) 当对象是被应用在切片表达式中时，实现整形强制转换 如果你定义了一个可能在切片时用到的定制的数值型,你应该定义 index 如果 index 被定义，则 int 也需要被定义，且返回相同的值 上下文管理（with 语句）__enter__(self) 1. 定义当使用 with 语句时的初始化行为 2. __enter__ 的返回值被 with 语句的目标或者 as 后的名字绑定__exit__(self, exc_type, exc_value, traceback) 1. 定义当一个代码块被执行或者终止后上下文管理器应该做什么 2. 一般被用来处理异常，清除工作或者做一些代码块执行完毕之后的日常工作 容器类型__len__(self) 定义当被 len() 调用时的行为（返回容器中元素的个数）__getitem__(self, key) 定义获取容器中指定元素的行为，相当于 self[key]__setitem__(self, key, value) 定义设置容器中指定元素的行为，相当于 self[key] = value__delitem__(self, key) 定义删除容器中指定元素的行为，相当于 del self[key]__iter__(self) 定义当迭代容器中的元素的行为__reversed__(self) 定义当被 reversed() 调用时的行为__contains__(self, item) 定义当使用成员测试运算符（in 或 not in）时的行为 转载自： https://www.jb51.net/article/156169.htm]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[斐波那契数列]]></title>
    <url>%2Fmath%2Fck9bgz7nf004oqov7fi12qefo.html</url>
    <content type="text"><![CDATA[简介斐波那契数列（Fibonacci sequence），又称黄金分割数列、因数学家列昂纳多·斐波那契（Leonardoda Fibonacci）以兔子繁殖为例子而引入，故又称为“兔子数列”。 其指的是这样一个数列：1、1、2、3、5、8、13、21、34、……如果设F(n）为该数列的第n项（n∈N*），那么这句话可以写成如下形式：:F(n)=F(n-1)+F(n-2) 在现代物理、准晶体结构、化学等领域，斐波纳契数列都有直接的应用。 详细介绍参考：传送门 python 实现打印第 n 个斐波那契数 123456789101112131415#!/usr/bin/python3# return n-th numberdef fibonacci(n): assert isinstance(n, int), &apos;n should be integer&apos; assert n &gt; 0, &apos;n should be greater than 0&apos; a, b = 1, 1 for x in range(2, n): a, b = b, a + b else: return bif __name__ == &quot;__main__&quot;: print(fibonacci(10)) # 55 打印 n 个斐波那契数 1234567891011121314151617#!/usr/bin/python3# return count of ndef fibonacci(n): assert isinstance(n, int), &apos;n should be integer&apos; assert n &gt; 0, &apos;n should be greater than 0&apos; a, b = 0, 1 fib_lst = [] for x in range(n): fib_lst.append(b) a, b = b, a + b else: return fib_lstif __name__ == &quot;__main__&quot;: print(fibonacci(10)) # [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]]]></content>
      <categories>
        <category>math</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python operator module]]></title>
    <url>%2Fpython%2Fmodule%2Fck9bgz83n00drqov7u5pz6wc1.html</url>
    <content type="text"><![CDATA[简介operator模块提供了一套与Python的内置运算符对应的高效率函数。 许多函数名与特殊方法名相同，只是没有双下划线。为了向后兼容性，也保留了许多包含双下划线的函数。为了表述清楚，建议使用没有双下划线的函数。 函数包含的种类有：对象的比较运算、逻辑运算、数学运算以及序列运算。 源代码: Lib/operator.py 1234&gt;&gt;&gt; import operator&gt;&gt;&gt; dir(operator) [&apos;__abs__&apos;, &apos;__add__&apos;, &apos;__all__&apos;, &apos;__and__&apos;, &apos;__builtins__&apos;, &apos;__cached__&apos;, &apos;__concat__&apos;, &apos;__contains__&apos;, &apos;__delitem__&apos;, &apos;__doc__&apos;, &apos;__eq__&apos;, &apos;__file__&apos;, &apos;__floordiv__&apos;, &apos;__ge__&apos;, &apos;__getitem__&apos;, &apos;__gt__&apos;, &apos;__iadd__&apos;, &apos;__iand__&apos;, &apos;__iconcat__&apos;, &apos;__ifloordiv__&apos;, &apos;__ilshift__&apos;, &apos;__imatmul__&apos;, &apos;__imod__&apos;, &apos;__imul__&apos;, &apos;__index__&apos;, &apos;__inv__&apos;, &apos;__invert__&apos;, &apos;__ior__&apos;, &apos;__ipow__&apos;, &apos;__irshift__&apos;, &apos;__isub__&apos;, &apos;__itruediv__&apos;, &apos;__ixor__&apos;, &apos;__le__&apos;, &apos;__loader__&apos;, &apos;__lshift__&apos;, &apos;__lt__&apos;, &apos;__matmul__&apos;, &apos;__mod__&apos;, &apos;__mul__&apos;, &apos;__name__&apos;, &apos;__ne__&apos;, &apos;__neg__&apos;, &apos;__not__&apos;, &apos;__or__&apos;, &apos;__package__&apos;, &apos;__pos__&apos;, &apos;__pow__&apos;, &apos;__rshift__&apos;, &apos;__setitem__&apos;, &apos;__spec__&apos;, &apos;__sub__&apos;, &apos;__truediv__&apos;, &apos;__xor__&apos;, &apos;_abs&apos;, &apos;abs&apos;, &apos;add&apos;, &apos;and_&apos;, &apos;attrgetter&apos;, &apos;concat&apos;, &apos;contains&apos;, &apos;countOf&apos;, &apos;delitem&apos;, &apos;eq&apos;, &apos;floordiv&apos;, &apos;ge&apos;, &apos;getitem&apos;, &apos;gt&apos;, &apos;iadd&apos;, &apos;iand&apos;, &apos;iconcat&apos;, &apos;ifloordiv&apos;, &apos;ilshift&apos;, &apos;imatmul&apos;, &apos;imod&apos;, &apos;imul&apos;, &apos;index&apos;, &apos;indexOf&apos;, &apos;inv&apos;, &apos;invert&apos;, &apos;ior&apos;, &apos;ipow&apos;, &apos;irshift&apos;, &apos;is_&apos;, &apos;is_not&apos;, &apos;isub&apos;, &apos;itemgetter&apos;, &apos;itruediv&apos;, &apos;ixor&apos;, &apos;le&apos;, &apos;length_hint&apos;, &apos;lshift&apos;, &apos;lt&apos;, &apos;matmul&apos;, &apos;methodcaller&apos;, &apos;mod&apos;, &apos;mul&apos;, &apos;ne&apos;, &apos;neg&apos;, &apos;not_&apos;, &apos;or_&apos;, &apos;pos&apos;, &apos;pow&apos;, &apos;rshift&apos;, &apos;setitem&apos;, &apos;sub&apos;, &apos;truediv&apos;, &apos;truth&apos;, &apos;xor&apos;] 对象比较函数对象比较函数适用于所有的对象，函数名根据它们对应的比较运算符命名。 12345678910111213operator.lt(a, b) # a &lt; boperator.le(a, b) # a &lt;= boperator.eq(a, b) # a == boperator.ne(a, b) # a != boperator.ge(a, b) # a &gt;= boperator.gt(a, b) # a &gt; boperator.__lt__(a, b) # a &lt; boperator.__le__(a, b) # a &lt;= boperator.__eq__(a, b) # a == boperator.__ne__(a, b) # a != boperator.__ge__(a, b) # a &gt;= boperator.__gt__(a, b) # a &gt; b 逻辑运算123456789101112operator.not_(obj)operator.__not__(obj) Return the outcome of not obj. operator.truth(obj) Return True if obj is true, and False otherwise. This is equivalent to using the bool constructor.operator.is_(a, b) Return a is b. Tests object identity.operator.is_not(a, b) Return a is not b. Tests object identity. 赋值运算12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455operator.iadd(a, b)operator.__iadd__(a, b) a = iadd(a, b) is equivalent to a += b.operator.iand(a, b)operator.__iand__(a, b) a = iand(a, b) is equivalent to a &amp;= b.operator.iconcat(a, b)operator.__iconcat__(a, b) a = iconcat(a, b) is equivalent to a += b for a and b sequences.operator.ifloordiv(a, b)operator.__ifloordiv__(a, b) a = ifloordiv(a, b) is equivalent to a //= b.operator.ilshift(a, b)operator.__ilshift__(a, b) a = ilshift(a, b) is equivalent to a &lt;&lt;= b.operator.imod(a, b)operator.__imod__(a, b) a = imod(a, b) is equivalent to a %= b.operator.imul(a, b)operator.__imul__(a, b) a = imul(a, b) is equivalent to a *= b.operator.imatmul(a, b)operator.__imatmul__(a, b) a = imatmul(a, b) is equivalent to a @= b.operator.ior(a, b)operator.__ior__(a, b) a = ior(a, b) is equivalent to a |= b.operator.ipow(a, b)operator.__ipow__(a, b) a = ipow(a, b) is equivalent to a **= b.operator.irshift(a, b)operator.__irshift__(a, b) a = irshift(a, b) is equivalent to a &gt;&gt;= b.operator.isub(a, b)operator.__isub__(a, b) a = isub(a, b) is equivalent to a -= b.operator.itruediv(a, b)operator.__itruediv__(a, b) a = itruediv(a, b) is equivalent to a /= b.operator.ixor(a, b)operator.__ixor__(a, b) a = ixor(a, b) is equivalent to a ^= b. 数学运算12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273operator.abs(obj)operator.__abs__(obj) Return the absolute value of obj.operator.add(a, b)operator.__add__(a, b) Return a + b, for a and b numbers.operator.and_(a, b)operator.__and__(a, b) Return the bitwise and of a and b.operator.floordiv(a, b)operator.__floordiv__(a, b) Return a // b.operator.index(a)operator.__index__(a) Return a converted to an integer. Equivalent to a.__index__().operator.inv(obj)operator.invert(obj)operator.__inv__(obj)operator.__invert__(obj) Return the bitwise inverse of the number obj. This is equivalent to ~obj.operator.lshift(a, b)operator.__lshift__(a, b) Return a shifted left by b.operator.mod(a, b)operator.__mod__(a, b) Return a % b.operator.mul(a, b)operator.__mul__(a, b) Return a * b, for a and b numbers.operator.matmul(a, b)operator.__matmul__(a, b) Return a @ b.operator.neg(obj)operator.__neg__(obj) Return obj negated (-obj).operator.or_(a, b)operator.__or__(a, b) Return the bitwise or of a and b.operator.pos(obj)operator.__pos__(obj)Return obj positive (+obj).operator.pow(a, b)operator.__pow__(a, b) Return a ** b, for a and b numbers.operator.rshift(a, b)operator.__rshift__(a, b) Return a shifted right by b.operator.sub(a, b)operator.__sub__(a, b) Return a - b.operator.truediv(a, b)operator.__truediv__(a, b) Return a / b where 2/3 is .66 rather than 0. This is also known as &quot;true&quot; division.operator.xor(a, b)operator.__xor__(a, b) Return the bitwise exclusive or of a and b. 序列运算12345678910111213141516171819202122232425262728operator.concat(a, b)operator.__concat__(a, b) Return a + b for a and b sequences.operator.contains(a, b)operator.__contains__(a, b) Return the outcome of the test b in a. Note the reversed operands.operator.countOf(a, b) Return the number of occurrences of b in a.operator.delitem(a, b)operator.__delitem__(a, b) Remove the value of a at index b.operator.getitem(a, b)operator.__getitem__(a, b) Return the value of a at index b.operator.indexOf(a, b) Return the index of the first of occurrence of b in a.operator.setitem(a, b, c)operator.__setitem__(a, b, c) Set the value of a at index b to c.operator.length_hint(obj, default=0) Return an estimated length for the object o. First try to return its actual length, then an estimate using object.__length_hint__(), and finally return the default value. 实用函数operator.attrgetter1234567operator.attrgetter(attr)operator.attrgetter(*attrs)Return a callable object that fetches attr from its operand. If more than one attribute is requested, returns a tuple of attributes. The attribute names can also contain dots. For example: After f = attrgetter(&apos;name&apos;), the call f(b) returns b.name. After f = attrgetter(&apos;name&apos;, &apos;date&apos;), the call f(b) returns (b.name, b.date). After f = attrgetter(&apos;name.first&apos;, &apos;name.last&apos;), the call f(b) returns (b.name.first, b.name.last). Equivalent to: 12345678910111213141516def attrgetter(*items): if any(not isinstance(item, str) for item in items): raise TypeError(&apos;attribute name must be a string&apos;) if len(items) == 1: attr = items[0] def g(obj): return resolve_attr(obj, attr) else: def g(obj): return tuple(resolve_attr(obj, attr) for attr in items) return gdef resolve_attr(obj, attr): for name in attr.split(&quot;.&quot;): obj = getattr(obj, name) return obj operator.itemgetter123456operator.itemgetter(item)operator.itemgetter(*items)Return a callable object that fetches item from its operand using the operand’s __getitem__() method. If multiple items are specified, returns a tuple of lookup values. For example: After f = itemgetter(2), the call f(r) returns r[2]. After g = itemgetter(2, 5, 3), the call g(r) returns (r[2], r[5], r[3]). Equivalent to: 123456789def itemgetter(*items): if len(items) == 1: item = items[0] def g(obj): return obj[item] else: def g(obj): return tuple(obj[item] for item in items) return g The items can be any type accepted by the operand’s __getitem__() method. Dictionaries accept any hashable value. Lists, tuples, and strings accept an index or a slice: 12345678910&gt;&gt;&gt; itemgetter(1)(&apos;ABCDEFG&apos;)&apos;B&apos;&gt;&gt;&gt; itemgetter(1,3,5)(&apos;ABCDEFG&apos;)(&apos;B&apos;, &apos;D&apos;, &apos;F&apos;)&gt;&gt;&gt; itemgetter(slice(2,None))(&apos;ABCDEFG&apos;)&apos;CDEFG&apos;&gt;&gt;&gt; soldier = dict(rank=&apos;captain&apos;, name=&apos;dotterbart&apos;)&gt;&gt;&gt; itemgetter(&apos;rank&apos;)(soldier)&apos;captain&apos; Example of using itemgetter() to retrieve specific fields from a tuple record: 123456&gt;&gt;&gt; inventory = [(&apos;apple&apos;, 3), (&apos;banana&apos;, 2), (&apos;pear&apos;, 5), (&apos;orange&apos;, 1)]&gt;&gt;&gt; getcount = itemgetter(1)&gt;&gt;&gt; list(map(getcount, inventory))[3, 2, 5, 1]&gt;&gt;&gt; sorted(inventory, key=getcount)[(&apos;orange&apos;, 1), (&apos;banana&apos;, 2), (&apos;apple&apos;, 3), (&apos;pear&apos;, 5)] operator.methodcaller12345operator.methodcaller(name[, args...])Return a callable object that calls the method name on its operand. If additional arguments and/or keyword arguments are given, they will be given to the method as well. For example: After f = methodcaller(&apos;name&apos;), the call f(b) returns b.name(). After f = methodcaller(&apos;name&apos;, &apos;foo&apos;, bar=1), the call f(b) returns b.name(&apos;foo&apos;, bar=1). Equivalent to: 1234def methodcaller(name, *args, **kwargs): def caller(obj): return getattr(obj, name)(*args, **kwargs) return caller Mapping Operators to FunctionsThis table shows how abstract operations correspond to operator symbols in the Python syntax and the functions in the operator module. Operation Syntax Function Addition a + b add(a, b) Concatenation seq1 + seq2 concat(seq1, seq2) Containment Test obj in seq contains(seq, obj) Division a / b truediv(a, b) Division a // b floordiv(a, b) Bitwise And a &amp; b and_(a, b) Bitwise Exclusive Or a ^ b xor(a, b) Bitwise Inversion ~ a invert(a) Bitwise Or `a b` Exponentiation a ** b pow(a, b) Identity a is b is_(a, b) Identity a is not b is_not(a, b) Indexed Assignment obj[k] = v setitem(obj, k, v) Indexed Deletion del obj[k] delitem(obj, k) Indexing obj[k] getitem(obj, k) Left Shift a &lt;&lt; b lshift(a, b) Modulo a % b mod(a, b) Multiplication a * b mul(a, b) Matrix Multiplication a @ b matmul(a, b) Negation (Arithmetic) - a neg(a) Negation (Logical) not a not_(a) Positive + a pos(a) Right Shift a &gt;&gt; b rshift(a, b) Slice Assignment seq[i:j] = values setitem(seq, slice(i, j), values) Slice Deletion del seq[i:j] delitem(seq, slice(i, j)) Slicing seq[i:j] getitem(seq, slice(i, j)) String Formatting s % obj mod(s, obj) Subtraction a - b sub(a, b) Truth Test obj truth(obj) Ordering a &lt; b lt(a, b) Ordering a &lt;= b le(a, b) Equality a == b eq(a, b) Difference a != b ne(a, b) Ordering a &gt;= b ge(a, b) Ordering a &gt; b gt(a, b)]]></content>
      <categories>
        <category>python</category>
        <category>module</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>module</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 统计文件及目录个数]]></title>
    <url>%2FLinux%2Fcommand%2Fck9bgz7jt001yqov7g8h8w0ey.html</url>
    <content type="text"><![CDATA[可通过命令 wc 、cat等实现。 示例目录 123456789101112131415161718192021222324252627282930313233343536373839404142[root@hadoop-centos-01 test]# tree.├── hadoop├── python_exm│ ├── a.txt│ └── example.py├── spark│ └── python│ └── test.py├── text.txt├── text.txt.hard├── text.txt.soft -&gt; text.txt└── ts.txt4 directories, 7 files[root@hadoop-centos-01 test]# ls -lR.:total 12drwxr-xr-x. 2 root root 6 Aug 25 21:32 hadoopdrwxr-xr-x. 2 root root 37 Aug 25 21:22 python_exmdrwxr-xr-x. 3 root root 20 Aug 26 08:08 spark-rw-r--r--. 2 root root 22 Aug 15 07:12 text.txt-rw-r--r--. 2 root root 22 Aug 15 07:12 text.txt.hardlrwxrwxrwx. 1 root root 8 Aug 14 06:51 text.txt.soft -&gt; text.txt-rw-r--r--. 1 root root 79 Aug 20 06:48 ts.txt./hadoop:total 0./python_exm:total 8-rw-r--r--. 1 root root 1 Aug 25 21:22 a.txt-rw-r--r--. 1 root root 70 Aug 23 07:59 example.py./spark:total 0drwxr-xr-x. 2 root root 21 Aug 26 08:09 python./spark/python:total 0-rw-r--r--. 1 root root 0 Aug 26 08:09 test.py 统计当前文件夹下文件及目录的总个数 12[root@hadoop-centos-01 test]# ls | wc -l7 统计目录个数 统计当前文件夹下目录的个数 12[root@hadoop-centos-01 test]# ls -l | grep &quot;^d&quot; | wc -l3 统计当前文件夹及其子文件夹下目录的个数 12[root@hadoop-centos-01 test]# ls -lR | grep &quot;^d&quot; | wc -l4 统计文件个数统计当前文件夹下文件的个数 12[root@hadoop-centos-01 test]# ls -l | grep &quot;^-&quot; | wc -l3 统计当前文件夹及其子目录下文件的个数 12[root@hadoop-centos-01 test]# ls -lR | grep &quot;^-&quot; | wc -l6 统计文件行数统计当前目录下所有文件行数 方法一： 123456789101112[root@hadoop-centos-01 test]# wc -l *wc: hadoop: Is a directory 0 hadoopwc: python_exm: Is a directory 0 python_exmwc: spark: Is a directory 0 spark 2 text.txt 2 text.txt.hard 2 text.txt.soft 5 ts.txt 11 total 方法二： 123456[root@hadoop-centos-01 test]# wc -l text.txt text.txt.hard text.txt.soft ts.txt 2 text.txt 2 text.txt.hard 2 text.txt.soft 5 ts.txt 11 total 方法三： 12[root@hadoop-centos-01 test]# cat -n text.txt text.txt.hard text.txt.soft ts.txt | tail -1 11]]></content>
      <categories>
        <category>Linux</category>
        <category>command</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>command</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux wc command]]></title>
    <url>%2FLinux%2Fcommand%2Fwc%2Fck9bgz7ys009eqov7rzscu36n.html</url>
    <content type="text"><![CDATA[作用wc 命令用于计算字数。 利用 wc 指令我们可以计算文件的Byte数、字数、或是列数，若不指定文件名称、或是所给予的文件名为”-“，则wc指令会从标准输入设备读取数据。 用法语法1wc [-clw][--help][--version][文件...] 参数1234567-c, --bytes 统计字节数-m, --chars 统计字符数,这个标志不能与 -c 标志一起使用-l, --lines 统计列数-L, --max-line-length 打印最长行的长度-w, --words 统计字数–help 打印帮助文档–version 显示版本信息 用法示例 查看文件的字节数、字数、行数 12345678910# commandwc filename# example[root@hadoop-centos-01 python_exm]# lsexample.py[root@hadoop-centos-01 python_exm]# wc example.py 4 10 70 example.py注: 打印结果依次为：行数 单词数 字节数 文件名 只打印统计数字不打印文件名 1234[root@hadoop-centos-01 python_exm]# wc -l example.py4 example.py[root@hadoop-centos-01 python_exm]# cat example.py | wc -l4 统计当前目录下的文件数 1234567891011121314[root@hadoop-centos-01 test]# tree -L 1.├── hadoop├── python_exm├── spark├── text.txt├── text.txt.hard├── text.txt.soft -&gt; text.txt└── ts.txt3 directories, 4 files[root@hadoop-centos-01 test]# ls | wc -l7 帮助文档123456789101112131415161718Usage: wc [OPTION]... [FILE]... or: wc [OPTION]... --files0-from=FPrint newline, word, and byte counts for each FILE, and a total line ifmore than one FILE is specified. With no FILE, or when FILE is -,read standard input. A word is a non-zero-length sequence of charactersdelimited by white space.The options below may be used to select which counts are printed, always inthe following order: newline, word, character, byte, maximum line length. -c, --bytes print the byte counts -m, --chars print the character counts -l, --lines print the newline counts --files0-from=F read input from the files specified by NUL-terminated names in file F; If F is - then read names from standard input -L, --max-line-length print the length of the longest line -w, --words print the word counts --help display this help and exit --version output version information and exit]]></content>
      <categories>
        <category>Linux</category>
        <category>command</category>
        <category>wc</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>command</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 设置静态IP]]></title>
    <url>%2FLinux%2Fck9bgz7kp002cqov7i9zwc1cq.html</url>
    <content type="text"><![CDATA[第一步：激活网卡通过ip add或者ifconfig 查看网卡名称。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# 通过ip addr 查看[root@hadoop-centos-01 ~]# ip addr1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:ff:56:49 brd ff:ff:ff:ff:ff:ff inet 192.168.244.11/24 brd 192.168.244.255 scope global ens33 valid_lft forever preferred_lft forever inet6 fe80::20c:29ff:feff:5649/64 scope link valid_lft forever preferred_lft forever3: virbr0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN group default qlen 1000 link/ether 52:54:00:72:bb:ed brd ff:ff:ff:ff:ff:ff inet 192.168.122.1/24 brd 192.168.122.255 scope global virbr0 valid_lft forever preferred_lft forever4: virbr0-nic: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc pfifo_fast master virbr0 state DOWN group default qlen 1000 link/ether 52:54:00:72:bb:ed brd ff:ff:ff:ff:ff:ff# 通过 ifconfig 查看[root@hadoop-centos-01 ~]# ifconfigens33: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 192.168.244.11 netmask 255.255.255.0 broadcast 192.168.244.255 inet6 fe80::20c:29ff:feff:5649 prefixlen 64 scopeid 0x20&lt;link&gt; ether 00:0c:29:ff:56:49 txqueuelen 1000 (Ethernet) RX packets 9568 bytes 614967 (600.5 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 1112 bytes 140379 (137.0 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt; mtu 65536 inet 127.0.0.1 netmask 255.0.0.0 inet6 ::1 prefixlen 128 scopeid 0x10&lt;host&gt; loop txqueuelen 1000 (Local Loopback) RX packets 72 bytes 8088 (7.8 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 72 bytes 8088 (7.8 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0virbr0: flags=4099&lt;UP,BROADCAST,MULTICAST&gt; mtu 1500 inet 192.168.122.1 netmask 255.255.255.0 broadcast 192.168.122.255 ether 52:54:00:72:bb:ed txqueuelen 1000 (Ethernet) RX packets 0 bytes 0 (0.0 B) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 0 bytes 0 (0.0 B) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 Linux中的网卡名以eth开头，vmware虚拟机中一般为ens，从0开始依次编号。网卡激活命令 ifconfig eth0up 1[root@hadoop-centos-01 ~]# ifconfig ens33 up # ens33 为当前的虚拟网卡 第二步：设置网卡进入系统时启动想要每次开机就可以自动获取IP地址上网，就要设置网络服务在系统启动时也启动。Linux有一点与windows不同的是很多服务默认是停止的，而且你在某次使用该服务时启动这个服务，但是没设置它为默认启动，则下次进入系统这个服务依然是停止的。下面是设置网络服务在系统启动时也启动的方法。 使用chkconfig命令让网络服务在系统启动级别是2345时默认启动。 1[root@hadoop-centos-01 ~]# chkconfig --level 2345 network on 第三步：修改网卡文件ifcfg-eth*网络配置文件位于 /etc/sysconfig/network-scripts 目录下，文件为 ifcfg-ens*，*为文件其它字符，因为不同的虚拟机该文件名字可能不同。 ifcfg-eth33文件配置解析： TYPE=Ethernet # 配置文件接口类型，有Ethernet、IPsec等类型，网络接口类型为Ethernet DEVICE=eth33 # 网络接口名称 BOOTPROTO=none # 系统启动地址协议，none不使用启动地址协议 ONBOOT=yes # 系统启动时是否激活 IPADDR=192.168.16.12 NETMASK=255.255.255.0 GATEWAY=192.168.16.1 BROADCAST=192.168.16.255 HWADDR=00:0C:29:13:5D:74 PEERDNS=yes DNS1=10.0.1.41 USERCTL=no NM_CONTROLLED=no IPV6INIT=yes IPV6ADDR=FD55:fe80::28c2:e745:835f:c8d0/64 附. 配置参数说明 注：这些参数值不区分大小写，不区分单引号和双引号，甚至可以不用引号。 TYPE：配置文件接口类型。在/etc/sysconfig/network-scripts/目录有多种网络配置文件，有Ethernet、IPsec等类型，网络接口类型为Ethernet。 DEVICE：网络接口名称 BOOTPROTO：系统启动地址协议 none：不使用启动地址协议 bootp：BOOTP协议 dhcp：DHCP动态地址协议 static：静态地址协议 ONBOOT：系统启动时是否激活 yes：系统启动时激活该网络接口 no：系统启动时不激活该网络接口 IPADDR：IP地址 NETMASK：子网掩码 GATEWAY：网关地址 BROADCAST：广播地址 HWADDR/MACADDR：MAC地址。只需设置其中一个，同时设置时不能相互冲突。 PEERDNS：是否指定DNS。如果使用DHCP协议，默认为yes。 yes：如果DNS设置，修改/etc/resolv.conf中的DNS no：不修改/etc/resolv.conf中的DNS DNS{1, 2}：DNS地址。当PEERDNS为yes时会被写入/etc/resolv.conf中。 NM_CONTROLLED：是否由Network Manager控制该网络接口。修改保存后立即生效，无需重启。被其坑过几次，建议一般设为no。 yes：由NetworkManager控制 no：不由NetworkManager控制 USERCTL：用户权限控制 yes：非root用户允许控制该网络接口 no：非root用户不运行控制该网络接口 IPV6INIT：是否执行IPv6 yes：支持IPv6 no：不支持IPv6 IPV6ADDR：IPv6地址/前缀长度第四步：配置生效为了使网络配置永久有效，第二部中修改了/etc/sysconfig/network-scripts/下的网络接口配置文件。但是，这些文件修改后，并不能立即生效。可通过以下两种方式使修改文件的网络配置生效： 1） 重启网络服务（推荐） service network restart 2） 重启计算机 reboot Referencehttps://www.cnblogs.com/aventador/p/3375434.html]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式简述]]></title>
    <url>%2Fregex%2Fck9bgz7ew001bqov7sm2o4u7i.html</url>
    <content type="text"><![CDATA[何谓正则表达式正则表达式 英文为 Regular Expression，是使用字符和特殊符号组成的能够描述某一类字符串的表达式。可以用来检查一个字符串是否含有某种子串、将匹配的子串替换或者从某个字符串中取出符合某个条件的子串等。 正则表达式看似繁琐（有规律可寻），然功能强大。熟知，简化工作，提升效率。 语法正则表达式是由普通字符（例如字符 a 到 z）以及特殊字符（称为”元字符”）组成的文字模式，该模式可以是单个的字符、字符集合、字符范围、字符间的选择或者所有这些组件的任意组合。 普通字符普通字符包括没有显式指定为元字符的所有可打印和不可打印字符。这包括所有大写和小写字母、所有数字、所有标点符号和一些其他符号。 非打印字符非打印字符也可以是正则表达式的组成部分。下表列出了表示非打印字符的转义序列： 字符 描述 \cx 匹配由x指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。 \f 匹配一个换页符。等价于 \x0c 和 \cL。 \n 匹配一个换行符。等价于 \x0a 和 \cJ。 \r 匹配一个回车符。等价于 \x0d 和 \cM。 \s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。注意 Unicode 正则表达式会匹配全角空格符。 \S 匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。 \t 匹配一个制表符。等价于 \x09 和 \cI。 \v 匹配一个垂直制表符。等价于 \x0b 和 \cK。 元字符下表包含了元字符的完整列表以及它们在正则表达式上下文中的行为： 字符 描述 \ 将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，’n’ 匹配字符 “n”。’\n’ 匹配一个换行符。序列 ‘\‘ 匹配 “&quot; 而 “(“ 则匹配 “(“。 ^ 匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 ‘\n’ 或 ‘\r’ 之后的位置。 $ 匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 ‘\n’ 或 ‘\r’ 之前的位置。 * 匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,}。 + 匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。 ? 匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 或 “does” 。? 等价于 {0,1}。 {n} n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。 {n,} n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。 {n,m} m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。 ? 当该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 “oooo”，’o+?’ 将匹配单个 “o”，而 ‘o+’ 将匹配所有 ‘o’。 . 匹配除换行符（\n、\r）之外的任何单个字符。要匹配包括 ‘\n’ 在内的任何字符，请使用像”(.|\n)“的模式。 (pattern) 匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用 SubMatches 集合，在JScript 中则使用 $0…$9 属性。要匹配圆括号字符，请使用 ‘(‘ 或 ‘)‘。 (?:pattern) 匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 “或” 字符 (|) 来组合一个模式的各个部分是很有用。例如， ‘industr(?:y|ies) 就是一个比 ‘industry|industries’ 更简略的表达式。 (?=pattern) 正向肯定预查（look ahead positive assert），在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，”Windows(?=95|98|NT|2000)”能匹配”Windows2000”中的”Windows”，但不能匹配”Windows3.1”中的”Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 (?!pattern) 正向否定预查(negative assert)，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如”Windows(?!95|98|NT|2000)”能匹配”Windows3.1”中的”Windows”，但不能匹配”Windows2000”中的”Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 (?&lt;=pattern) 反向(look behind)肯定预查，与正向肯定预查类似，只是方向相反。例如，”`(?&lt;=95 (?&lt;!pattern) 反向否定预查，与正向否定预查类似，只是方向相反。例如”`(?&lt;!95 x|y 匹配 x 或 y。例如，’z|food’ 能匹配 “z” 或 “food”。’(z|f)ood’ 则匹配 “zood” 或 “food”。 [xyz] 字符集合。匹配所包含的任意一个字符。例如， ‘[abc]’ 可以匹配 “plain” 中的 ‘a’。 [^xyz] 负值字符集合。匹配未包含的任意字符。例如， ‘[^abc]’ 可以匹配 “plain” 中的’p’、’l’、’i’、’n’。 [a-z] 字符范围。匹配指定范围内的任意字符。例如，’[a-z]’ 可以匹配 ‘a’ 到 ‘z’ 范围内的任意小写字母字符。 [^a-z] 负值字符范围。匹配任何不在指定范围内的任意字符。例如，’[^a-z]’ 可以匹配任何不在 ‘a’ 到 ‘z’ 范围内的任意字符。 \b 匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。 \B 匹配非单词边界。’er\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。 \cx 匹配由 x 指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。 \d 匹配一个数字字符。等价于 [0-9]。 \D 匹配一个非数字字符。等价于 [^0-9]。 \f 匹配一个换页符。等价于 \x0c 和 \cL。 \n 匹配一个换行符。等价于 \x0a 和 \cJ。 \r 匹配一个回车符。等价于 \x0d 和 \cM。 \s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。 \S 匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。 \t 匹配一个制表符。等价于 \x09 和 \cI。 \v 匹配一个垂直制表符。等价于 \x0b 和 \cK。 \w 匹配字母、数字、下划线。等价于’[A-Za-z0-9_]’。 \W 匹配非字母、数字、下划线。等价于 ‘[^A-Za-z0-9_]’。 \xn 匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，’\x41’ 匹配 “A”。’\x041’ 则等价于 ‘\x04’ &amp; “1”。正则表达式中可以使用 ASCII 编码。 \num 匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。例如，’(.)\1’ 匹配两个连续的相同字符。 \n 标识一个八进制转义值或一个向后引用。如果 \n 之前至少 n 个获取的子表达式，则 n 为向后引用。否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值。 \nm 标识一个八进制转义值或一个向后引用。如果 \nm 之前至少有 nm 个获得子表达式，则 nm 为向后引用。如果 \nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的向后引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 \nm 将匹配八进制转义值 nm。 \nml 如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。 \un 匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。例如， \u00A9 匹配版权符号 (?)。 注：元字符自身的匹配需要进行转译，例如\. or \* 运算符优先级正则表达式从左到右进行计算，并遵循优先级顺序，这与算术表达式非常类似。 相同优先级的从左到右进行运算，不同优先级的运算先高后低。下表从最高到最低说明了各种正则表达式运算符的优先级顺序： 运算符 描述 \ 转义符 (), (?:), (?=), [] 圆括号和方括号 *, +, ?, {n}, {n,}, {n,m} 限定符 ^, $, \任何元字符、任何字符 定位点和序列（即：位置和顺序） | 替换，”或”操作 字符具有高于替换运算符的优先级，使得”m|food”匹配”m”或”food”。若要匹配”mood”或”food”，请使用括号创建子表达式，从而产生”(m|f)ood”。 上述摘自菜鸟教程：https://www.runoob.com/regexp/regexp-tutorial.html 推存一个学习链接：http://deerchao.net/tutorials/regex/regex.htm]]></content>
      <categories>
        <category>regex</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>regex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[执行chmod -R 777 命令误操作根目录补救的方法]]></title>
    <url>%2FLinux%2Fck9bgz7kd0026qov7zo9mzqcb.html</url>
    <content type="text"><![CDATA[使用 chmod -R 777 ./* 命令在更改某个目录下文件的权限时，由于操作失误，误用为 chmod -R 777 /*，在零点几秒的反应过后，果断 ctrl + c，奈何电脑反应更快，一切为时已晚（切记不要关闭该终端）。若何？ 查看当前根目录权限，如下： 123456789101112131415161718192021[root@hadoop-centos-03` /]# lltotal 24lrwxrwxrwx. 1 root root 7 Apr 28 07:32 bin -&gt; usr/bindrwxrwxrwx. 5 root root 4096 Apr 28 07:58 bootdrwxrwxrwx. 20 root root 3320 Aug 14 21:58 devdrwxrwxrwx. 138 root root 8192 May 12 21:05 etcdrwxrwxrwx. 3 root root 20 Apr 28 08:18 homelrwxrwxrwx. 1 root root 7 Apr 28 07:32 lib -&gt; usr/liblrwxrwxrwx. 1 root root 9 Apr 28 07:32 lib64 -&gt; usr/lib64drwxrwxrwx. 2 root root 6 Apr 11 2018 mediadrwxrwxrwx. 2 root root 6 Apr 11 2018 mntdrwxrwxrwx. 6 root root 77 Aug 14 22:10 optdrwxrwxrwx. 189 root root 0 Aug 14 21:57 procdrwxrwxrwx. 19 root root 4096 Aug 14 22:09 rootdrwxr-xr-x. 39 root root 1220 Aug 14 21:58 runlrwxrwxrwx. 1 root root 8 Apr 28 07:32 sbin -&gt; usr/sbindrwxr-xr-x. 2 root root 6 Apr 11 2018 srvdr-xr-xr-x. 13 root root 0 Aug 14 21:58 sysdrwxrwxrwt. 22 root root 4096 Aug 14 22:12 tmpdrwxr-xr-x. 13 root root 155 Apr 28 07:32 usrdrwxr-xr-x. 20 root root 282 Apr 28 08:00 var 由于 /etc 目录已经被更改，显示如下： 12345678910111213141516171819202122[root@hadoop-centos-03` etc]# ll | headtotal 1384drwxrwxrwx. 3 root root 101 Apr 28 07:36 abrt-rwxrwxrwx. 1 root root 16 Apr 28 07:57 adjtime-rwxrwxrwx. 1 root root 1518 Jun 7 2013 aliases-rwxrwxrwx. 1 root root 12288 Apr 28 08:00 aliases.dbdrwxrwxrwx. 3 root root 65 Apr 28 07:45 alsadrwxrwxrwx. 2 root root 4096 May 6 07:03 alternatives-rwxrwxrwx. 1 root root 541 Apr 11 2018 anacrontab-rwxrwxrwx. 1 root root 55 Oct 30 2018 asound.conf-rwxrwxrwx. 1 root root 1 Oct 31 2018 at.deny[root@hadoop-centos-03` etc]# ll | tail-rwxrwxrwx. 1 root root 4479 Oct 31 2018 wgetrcdrwxrwxrwx. 2 root root 33 Apr 28 07:36 wpa_supplicant-rwxrwxrwx. 1 root root 0 Jun 10 2014 wvdial.confdrwxrwxrwx. 6 root root 103 Apr 28 07:35 X11drwxrwxrwx. 6 root root 116 Apr 28 07:39 xdgdrwxrwxrwx. 2 root root 6 Apr 11 2018 xinetd.ddrwxrwxrwx. 2 root root 21 Apr 28 07:33 xmldrwxrwxrwx. 6 root root 100 Apr 28 07:35 yum-rwxrwxrwx. 1 root root 970 Nov 5 2018 yum.confdrwxrwxrwx. 2 root root 187 Nov 5 2018 yum.repos.d 故已无法通过ssh连接该节点，提示如下： 123456Session stopped - Press &lt;return&gt; to exit tab - Press R to restart session - Press S to save terminal output to fileServer unexpectedly closed network connection ssh 登录相关的文件信息在/etc/ssh目录下，相关文件可能还有passwd、group、shadow等，查找另外一台正常机器该目录的权限及相关文件的权限，根据其修改当前出错机器/etc/ssh目录下的文件及相关文件的权限，我试着将/etc/ssh目录下的文件更改为600，即执行chmod 600 /etc/ssh，发现通过ssh可以连接，示例如下： 12345678# 未修改前[root@hadoop-centos-01 ~]# ssh hadoop-centos-03ssh_exchange_identification: read: Connection reset by peer# 修改后[root@hadoop-centos-01 etc]# ssh hadoop-centos-03root@hadoop-centos-03&apos;s password:Last login: Wed Aug 14 22:48:39 2019 from 192.168.244.6 最头疼的问题（登陆问题）已经解决，只要能进去，剩下的就要慢慢折腾喽。 导出系统文件权限 如果你是在集群中出现上述情况，可以找一个相似的机器，如果你是单机模式，那就找一个比较干净（没有安装过多的额外应用）的机器，导出系统各目录层级的文件权限。 导出命令： 1getfacl -R /* &gt; /home/chmod.bak # 存储路径及文件名可以自定义 修改出错机器系统文件权限 命令： 1setfacl --restore=/home/chmod.bak 上述命令执行完后： 123456789101112131415161718192021[root@hadoop-centos-03` /]# lltotal 24lrwxrwxrwx. 1 root root 7 Apr 28 07:32 bin -&gt; usr/bindr-xr-xr-x. 5 root root 4096 Apr 28 07:58 bootdrwxr-xr-x. 20 root root 3320 Aug 14 21:58 devdrwxr-xr-x. 138 root root 8192 May 12 21:05 etcdrwxr-xr-x. 3 root root 20 Apr 28 08:18 homelrwxrwxrwx. 1 root root 7 Apr 28 07:32 lib -&gt; usr/liblrwxrwxrwx. 1 root root 9 Apr 28 07:32 lib64 -&gt; usr/lib64drwxr-xr-x. 2 root root 6 Apr 11 2018 mediadrwxr-xr-x. 2 root root 6 Apr 11 2018 mntdrwxr-xr-x. 6 root root 77 Aug 14 22:10 optdr-xr-xr-x. 234 root root 0 Aug 14 21:57 procdr-xr-x---. 19 root root 4096 Aug 14 22:48 rootdrwxr-xr-x. 40 root root 1240 Aug 14 23:06 runlrwxrwxrwx. 1 root root 8 Apr 28 07:32 sbin -&gt; usr/sbindrwxr-xr-x. 2 root root 6 Apr 11 2018 srvdr-xr-xr-x. 13 root root 0 Aug 14 21:58 sysdrwxrwxrwt. 26 root root 4096 Aug 14 23:06 tmpdrwxr-xr-x. 13 root root 155 Apr 28 07:32 usrdrwxr-xr-x. 20 root root 282 Apr 28 08:00 var 到目前为止，一切看似已恢复正常，如果重启方便，建议重启。 总结 操作失误后，切记不要关闭该终端，或许还可以回到从前； 更改/etc/ 目录下的 passwd、group、shadow、ssh等文件可恢复ssh远程登陆； 导出系统文件对应的权限可通过getfacl -R /* &gt; /home/chmod.bak命令实现； 更新系统文件的权限可通过setfacl --restore=/home/chmod.bak命令实现。 参考 传送门]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软连接与硬连接]]></title>
    <url>%2FLinux%2Fck9bgz7l1002jqov7jypcns80.html</url>
    <content type="text"><![CDATA[链接是一种文件共享的方式，是 POSIX 中的概念，主流文件系统都支持链接文件。 链接无非是把文件名和计算机文件系统使用的节点号链接起来。因此我们可以用多个文件名与同一个文件进行链接，这些文件名可以在同一目录或不同目录。 对链接进行编辑，实际上是对原始文件进行编辑。 硬链接硬链接只能引用同一文件系统中的文件。它引用的是文件在文件系统中的物理索引(也称为 inode)。当您移动或删除原始文件时，硬链接不会被破坏，因为它所引用的是文件的物理数据而不是文件在文件结构中的位置。硬链接的文件不需要用户有访问原始文件的权限，也不会显示原始文件的位置，这样有助于文件的安全。如果您删除的文件有相应的硬链接，那么这个文件依然会保留，直到所有对它的引用都被删除。 使用 1ln [源文件] [目标文件] 示例 1234567891011# 创建一个测试文件 test.txt[root@hadoop-centos-01 test]# echo &quot;Make deserts bloom&quot; &gt; text.txt[root@hadoop-centos-01 test]# lstext.txt# 以 text.txt 为源创建一个硬连接 text.txt.hard[root@hadoop-centos-01 test]# ln text.txt text.txt.hard[root@hadoop-centos-01 test]# ls -litotal 851936935 -rw-r--r--. 2 root root 19 Aug 14 06:43 text.txt51936935 -rw-r--r--. 2 root root 19 Aug 14 06:43 text.txt.hard 注意事项 修改源文件或者目标文件, 对应另外一个文件也会发生相应修改； 删除源文件或者目标文件, 对另外一个文件没有影响； 硬链接文件不占用存储空间； 不能对目录文件进行创建硬链接操作； 硬链接文件不能跨文件系统。 软链接软链接也称之为符号连接（Symbolic Link）。 软链接文件有类似于Windows的快捷方式。它实际上是一个特殊的文件。其包含了另一文件的位置信息。 使用： 1ln -s [源文件或目录] [目标文件或目录] 示例： 123456[root@hadoop-centos-01 test]# ln -s text.txt text.txt.soft[root@hadoop-centos-01 test]# ll -itotal 851936935 -rw-r--r--. 2 root root 19 Aug 14 06:43 text.txt51936935 -rw-r--r--. 2 root root 19 Aug 14 06:43 text.txt.hard # test.txt 的硬链接51936939 lrwxrwxrwx. 1 root root 8 Aug 14 06:51 text.txt.soft -&gt; text.txt # test.txt 的软链接 硬链接与软链接的区别在Linux的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号inode 。 软连接，其实就是新建立一个文件，这个文件就是专门用来指向别的文件的，类似于windows 下的快捷方式。删了这个软连接文件，不影响其指向的实体文件，但如果删除其指向的实体文件，则该软链接不可用。 硬连接，不会建立inode的，他只是在文件原来的inode link count域再增加1而已，也因此硬链接是不可以跨越文件系统的。相反都是软连接会重新建立一个inode，当然inode的结构跟其他的不一样，他只是一个指明源文件的字符串信息。一旦删除源文件，那么软连接将变得毫无意义。而硬链接删除的时候，系统调用会检查inode link count的数值，如果他大于等于1，那么inode不会被回收。因此文件的内容不会被删除。 创建硬链接实际上是为原文件在储存器中的资源再新建一个入口，所以硬链接和原文件指向的其实是储存器中的同一处资源（可以理解为硬链接和原文件就是同一个文件）。可以通过ls -i来查看一下，这两个文件的inode号是同一个，说明它们是同一个文件；而软链接建立的是一个指向，即链接文件内的内容是指向原文件的指针，它们是两个文件。 软链接可以跨文件系统，硬链接不可以；软链接可以对一个不存在的文件名(filename)进行链接（当然此时如果你vi这个软链接文件，linux会自动新建一个文件名为filename的文件）,硬链接不可以（其文件必须存在，inode必须存在）； 软链接可以对目录进行连接，硬链接不可以。两种链接都可以通过命令 ln 来创建。ln 默认创建的是硬链接。使用 -s 开关可以创建软链接。 参考： https://baike.baidu.com/item/%E7%A1%AC%E9%93%BE%E6%8E%A5]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux jps]]></title>
    <url>%2FLinux%2Fcommand%2Fjps%2Fck9bgz7x7008uqov7uvyqm0j2.html</url>
    <content type="text"><![CDATA[jps(Java Virtual Machine Process Status Tool) 说明：java提供的一个显示当前所有java进程pid的命令，适合在linux/unix平台上简单察看当前java进程的一些简单情况。它的作用是显示当前系统的java进程情况及进程id。我们可以通过它来查看我们到底启动了几个java进程（因为每一个java程序都会独占一个java虚拟机实例）并可通过opt来查看这些进程的详细启动参数。 使用方法：在当前命令行下打jps(jps存放在JAVA_HOME/bin/jps，使用时为了方便需将JAVA_HOME/bin/加入到Path) 。 12[root@hadoop-centos-01 bin]# jps13594 Jps 常用参数： 123456789101112131415-q 只显示pid，不显示class名称,jar文件名和传递给main方法的参数 [root@hadoop-centos-01 bin]# jps -q 13669-m 输出传递给main方法的参数，在嵌入式jvm上可能是null [root@hadoop-centos-01 bin]# jps -m 13716 Jps -m-l 输出应用程序main class的完整package名或者应用程序的jar文件完整路径名 [root@hadoop-centos-01 bin]# jps -l 13762 sun.tools.jps.Jps-v 输出传递给JVM的参数 [root@hadoop-centos-01 bin]# jps -v 13812 Jps -Denv.class.path=/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.212.b04-0.el7_6.x86_64/lib:/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.212.b04-0.el7_6.x86_64/jre/lib: -Dapplication.home=/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.212.b04-0.el7_6.x86_64 -Xms8m]]></content>
      <categories>
        <category>Linux</category>
        <category>command</category>
        <category>jps</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>command</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo 添加DaoVoice实现在线联系]]></title>
    <url>%2Fhexo%2Fck9bgz7mr0045qov7q0a0pnbp.html</url>
    <content type="text"><![CDATA[注册登录DaoVoice注册地址: http://www.daovoice.io/]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo 文章置顶]]></title>
    <url>%2Fhexo%2Fck9bgz7mo0042qov74smp8aem.html</url>
    <content type="text"><![CDATA[安装插件12npm uninstall hexo-generator-index --savenpm install hexo-generator-index-pin-top --save 在需要置顶的文章的Front-matter中加上top12345---title: 2019date: 2019-02-14 16:10:03top: 10--- 设置置顶标志打开：/themes/*/layout/_macro/post.ejs直接在最前面加入以下代码即可 12345&lt;% if (page.top) &#123; %&gt; &lt;i class=&quot;fa fa-thumb-tack&quot;&gt;&lt;/i&gt; &lt;font color=7D26CD&gt;置顶&lt;/font&gt; &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;&lt;% &#125; %&gt;]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 查看系统版本]]></title>
    <url>%2FLinux%2Fcommand%2Fifconfig%2Fck9bgz7jm001wqov7g9k6gauu.html</url>
    <content type="text"><![CDATA[linux系统版本信息（Oracle Linux、Centos Linux、Redhat Linux、Debian、Ubuntu）； 1、 查看Linux内核版本命令（两种方法）： 方法一 命令：cat /proc/version 12[root@hadoop-centos-01 ~]# cat /proc/versionLinux version 3.10.0-957.el7.x86_64 (mockbuild@kbuilder.bsys.centos.org) (gcc version 4.8.5 20150623 (Red Hat 4.8.5-36) (GCC) ) #1 SMP Thu Nov 8 23:39:32 UTC 2018 方法二 命令：uname -a 12[root@hadoop-centos-01 ~]# uname -aLinux hadoop-centos-01 3.10.0-957.el7.x86_64 #1 SMP Thu Nov 8 23:39:32 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux 2、 查看Linux系统版本的命令（3种方法）： 方法一 命令：cat /etc/redhat-release 1234[root@hadoop-centos-01 ~]# cat /etc/redhat-releaseCentOS Linux release 7.6.1810 (Core) 注：只适合Redhat系的Linux 方法二 命令：cat /etc/issue 123[root@hadoop-centos-01 ~]# cat /etc/issue\SKernel \r on an \m 注：此命令也适用于所有的Linux发行版。 方法三 命令：lsb_release -a 结果：无 注：适用于所有的Linux发行版，包括RedHat、SUSE、Debian…等发行版 附： lsb_release 显示发行版本信息 LSB是Linux Standard Base的缩写， lsb_release命令 用来显示LSB和特定版本的相关信息。如果使用该命令时不带参数，则默认加上-v参数。 -v 显示版本信息。 -i 显示发行版的id。 -d 显示该发行版的描述信息。 -r 显示当前系统是发行版的具体版本号。 -c 发行版代号。 -a 显示上面的所有信息。 -h 显示帮助信息。 如果当前发行版是LSB兼容的，那么/etc/lsb_release文件中会包含LSB_VERSION域。这个域的值可以是用冒号隔开的一系列支持的模块。这些模块名是当前版本支持的LSB的模块名。如果当前版本不是LSB兼容的，就不要包含这个域。 可选的域包括DISTRIB_ID, DISTRIB_RELEASE, DISTRIB_CODENAME,DISTRIB_DESCRIPTION，它们可以覆盖/etc/distrib-release文件中的内容。 注：这里的distrib要替换为当前的发行版的名字。如果存在/etc/lsb-release.d目录，会在该目录中查找文件名并作为附加的模块版本加在LSB_VERSION前面。文件/etc/distrib-release中包含了一些描述信息，用来说明应该分析哪些文件名。 一般的格式是Distributor release x.x (Codename) 注意：Debian系统中缺乏相应的描述信息（见/etc/debian-version），为了支持Debian系统，大部分信息都被加在了lsb-release文件中。 redhat和fedora系统中，还支持一个参数： -s, --short 输出简短的描述信息。 reference https://ipcmen.com/lsb_release]]></content>
      <categories>
        <category>Linux</category>
        <category>command</category>
        <category>ifconfig</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>command</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux ping command]]></title>
    <url>%2FLinux%2Fcommand%2Fping%2Fck9bgz7yc0095qov7b36o7acc.html</url>
    <content type="text"><![CDATA[作用：网络命令，用来测试与目标主机的连通性。 场景：ping一下某机器，看是不是开着，如不能打开网页时会说“你先ping网关地址192.168.1.1试试” 原理：通过发送ICMP ECHO_REQUEST数据包到网络主机（send ICMP ECHO_REQUEST to network hosts），并显示响应情况，这样我们就可以根据它输出的信息来确定目标主机是否可访问（但这不是绝对的）。有些服务器为了防止通过ping探测到，通过防火墙设置了禁止ping或者在内核参数中禁止ping，这样就不能通过ping确定该主机是否还处于开启状态。 用法： 命令格式：ping [参数] [主机名或IP地址] 命令功能： 确定网络和各外部主机的状态； 跟踪和隔离硬件和软件问题； 测试、评估和管理网络。 实现原理： 如果主机正在运行并连在网上，它就对回送信号进行响应。每个回送信号请求包含一个网际协议（IP）和 ICMP 头，后面紧跟一个 tim 结构，以及来填写这个信息包的足够的字节。缺省情况是连续发送回送信号请求直到接收到中断信号（Ctrl-C）。 ping 命令每秒发送一个数据报并且为每个接收到的响应打印一行输出。ping 命令计算信号往返时间和(信息)包丢失情况的统计信息，并且在完成之后显示一个简要总结。ping 命令在程序超时或当接收到 SIGINT 信号时结束。Host 参数或者是一个有效的主机名或者是因特网地址。 命令参数： -d：使用Socket的SO_DEBUG功能；-c&lt;完成次数&gt;：设置完成要求回应的次数；-f：极限检测；-i&lt;间隔秒数&gt;：指定收发信息的间隔时间；-I&lt;网络界面&gt;：使用指定的网络界面送出数据包；-l&lt;前置载入&gt;：设置在送出要求信息之前，先行发出的数据包；-n：只输出数值；-p&lt;范本样式&gt;：设置填满数据包的范本样式；-q：不显示指令执行过程，开头和结尾的相关信息除外；-r：忽略普通的Routing Table，直接将数据包送到远端主机上；-R：记录路由过程；-s&lt;数据包大小&gt;：设置数据包的大小；-t&lt;存活数值&gt;：设置存活数值TTL的大小；-v：详细显示指令的执行过程。 示例 1234567[root@hadoop-centos-01 ~]# ping www.baidu.comPING www.a.shifen.com (182.61.200.7) 56(84) bytes of data.64 bytes from 182.61.200.7 (182.61.200.7): icmp_seq=1 ttl=128 time=1169 ms64 bytes from 182.61.200.7 (182.61.200.7): icmp_seq=2 ttl=128 time=1178 ms64 bytes from 182.61.200.7 (182.61.200.7): icmp_seq=3 ttl=128 time=1138 ms64 bytes from 182.61.200.7 (182.61.200.7): icmp_seq=4 ttl=128 time=1095 ms64 bytes from 182.61.200.7 (182.61.200.7): icmp_seq=5 ttl=128 time=1496 ms]]></content>
      <categories>
        <category>Linux</category>
        <category>command</category>
        <category>ping</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>command</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo 添加页面萌宠]]></title>
    <url>%2Fhexo%2Fck9bgz7mv0048qov7h4xlys0y.html</url>
    <content type="text"><![CDATA[安装Live2D插件在hexo根目录下执行以下命令 1234567891011121314151617181920212223242526npm install --save hexo-helper-live2dnpm install xxx # xxx 为下载的model# model 列表live2d-widget-model-chitoselive2d-widget-model-epsilon2_1live2d-widget-model-gflive2d-widget-model-haru/01 (use npm install --save live2d-widget-model-haru)live2d-widget-model-haru/02 (use npm install --save live2d-widget-model-haru)live2d-widget-model-harutolive2d-widget-model-hibikilive2d-widget-model-hijikilive2d-widget-model-izumilive2d-widget-model-koharulive2d-widget-model-mikulive2d-widget-model-ni-jlive2d-widget-model-nicolive2d-widget-model-nietzschelive2d-widget-model-nipsilonlive2d-widget-model-nitolive2d-widget-model-shizukulive2d-widget-model-tororolive2d-widget-model-tsumikilive2d-widget-model-unitychanlive2d-widget-model-wankolive2d-widget-model-z16 Config向Hexo的 _config.yml 文件或主题的 _config.yml 文件中添加配置. 123456789101112131415161718live2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ tagMode: false log: false model: use: live2d-widget-model-wanko display: position: right width: 150 height: 300 mobile: show: true react: opacity: 0.7 12345678910111213141516171819# Live2D## https://github.com/EYHN/hexo-helper-live2dlive2d: enable: true # enable: false scriptFrom: local # 默认 pluginRootPath: live2dw/ # 插件在站点上的根目录(相对路径) pluginJsPath: lib/ # 脚本文件相对与插件根目录路径 pluginModelPath: assets/ # 模型文件相对与插件根目录路径 # scriptFrom: jsdelivr # jsdelivr CDN # scriptFrom: unpkg # unpkg CDN # scriptFrom: https://cdn.jsdelivr.net/npm/live2d-widget@3.x/lib/L2Dwidget.min.js # 你的自定义 url tagMode: false # 标签模式, 是否仅替换 live2d tag标签而非插入到所有页面中 debug: false # 调试, 是否在控制台输出日志 model: use: live2d-widget-model-wanko # npm-module package name # use: wanko # 博客根目录/live2d_models/ 下的目录名 # use: ./wives/wanko # 相对于博客根目录的路径 # use: https://cdn.jsdelivr.net/npm/live2d-widget-model-wanko@1.0.5/assets/wanko.model.json # 你的自定义 url 重新生成并部署12$ hexo clean$ hexo g -d 详细教程 中文版：https://github.com/EYHN/hexo-helper-live2d/blob/master/README.zh-CN.md 英文版：https://github.com/EYHN/hexo-helper-live2d/blob/master/README.md 看板娘图片： https://blog.csdn.net/wang_123_zy/article/details/87181892#_1 https://huaji8.top/post/live2d-plugin-2.0/]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux grep command]]></title>
    <url>%2FLinux%2Fcommand%2Fgrep%2Fck9bgz83800deqov7waczy9cp.html</url>
    <content type="text"><![CDATA[作用grep（global search regular expression(RE) and print out the line，全面搜索正则表达式并把行打印出来）是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。 语法及选项12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970[root@hadoop-centos-01 ~]# grep --helpUsage: grep [OPTION]... PATTERN [FILE]...Search for PATTERN in each FILE or standard input.PATTERN is, by default, a basic regular expression (BRE).Example: grep -i &apos;hello world&apos; menu.h main.cRegexp selection and interpretation: -E, --extended-regexp PATTERN is an extended regular expression (ERE) -F, --fixed-strings PATTERN is a set of newline-separated fixed strings -G, --basic-regexp PATTERN is a basic regular expression (BRE) -P, --perl-regexp PATTERN is a Perl regular expression -e, --regexp=PATTERN use PATTERN for matching -f, --file=FILE obtain PATTERN from FILE -i, --ignore-case ignore case distinctions -w, --word-regexp force PATTERN to match only whole words -x, --line-regexp force PATTERN to match only whole lines -z, --null-data a data line ends in 0 byte, not newlineMiscellaneous: -s, --no-messages suppress error messages -v, --invert-match select non-matching lines -V, --version display version information and exit --help display this help text and exitOutput control: -m, --max-count=NUM stop after NUM matches -b, --byte-offset print the byte offset with output lines -n, --line-number print line number with output lines --line-buffered flush output on every line -H, --with-filename print the file name for each match -h, --no-filename suppress the file name prefix on output --label=LABEL use LABEL as the standard input file name prefix -o, --only-matching show only the part of a line matching PATTERN -q, --quiet, --silent suppress all normal output --binary-files=TYPE assume that binary files are TYPE; TYPE is &apos;binary&apos;, &apos;text&apos;, or &apos;without-match&apos; -a, --text equivalent to --binary-files=text -I equivalent to --binary-files=without-match -d, --directories=ACTION how to handle directories; ACTION is &apos;read&apos;, &apos;recurse&apos;, or &apos;skip&apos; -D, --devices=ACTION how to handle devices, FIFOs and sockets; ACTION is &apos;read&apos; or &apos;skip&apos; -r, --recursive like --directories=recurse -R, --dereference-recursive likewise, but follow all symlinks --include=FILE_PATTERN search only files that match FILE_PATTERN --exclude=FILE_PATTERN skip files and directories matching FILE_PATTERN --exclude-from=FILE skip files matching any file pattern from FILE --exclude-dir=PATTERN directories that match PATTERN will be skipped. -L, --files-without-match print only names of FILEs containing no match -l, --files-with-matches print only names of FILEs containing matches -c, --count print only a count of matching lines per FILE -T, --initial-tab make tabs line up (if needed) -Z, --null print 0 byte after FILE nameContext control: -B, --before-context=NUM print NUM lines of leading context -A, --after-context=NUM print NUM lines of trailing context -C, --context=NUM print NUM lines of output context -NUM same as --context=NUM --group-separator=SEP use SEP as a group separator --no-group-separator use empty string as a group separator --color[=WHEN], --colour[=WHEN] use markers to highlight the matching strings; WHEN is &apos;always&apos;, &apos;never&apos;, or &apos;auto&apos; -U, --binary do not strip CR characters at EOL (MSDOS/Windows) -u, --unix-byte-offsets report offsets as if CRs were not there (MSDOS/Windows) -a 不要忽略二进制数据。-A&lt;显示列数&gt; 除了显示符合范本样式的那一行之外，并显示该行之后的内容。-b 在显示符合范本样式的那一行之外，并显示该行之前的内容。-c 计算符合范本样式的列数。-C&lt;显示列数&gt;或-&lt;显示列数&gt; 除了显示符合范本样式的那一列之外，并显示该列之前后的内容。-d&lt;进行动作&gt; 当指定要查找的是目录而非文件时，必须使用这项参数，否则grep命令将回报信息并停止动作。-e&lt;范本样式&gt; 指定字符串作为查找文件内容的范本样式。-E 将范本样式为延伸的普通表示法来使用，意味着使用能使用扩展正则表达式。-f&lt;范本文件&gt; 指定范本文件，其内容有一个或多个范本样式，让grep查找符合范本条件的文件内容，格式为每一列的范本样式。-F 将范本样式视为固定字符串的列表。-G 将范本样式视为普通的表示法来使用。-h 在显示符合范本样式的那一列之前，不标示该列所属的文件名称。-H 在显示符合范本样式的那一列之前，标示该列的文件名称。-i 忽略字符大小写的差别。-l 列出文件内容符合指定的范本样式的文件名称。-L 列出文件内容不符合指定的范本样式的文件名称。-n 在显示符合范本样式的那一列之前，标示出该列的编号。-q 不显示任何信息。-R/-r 此参数的效果和指定“-d recurse”参数相同。-s 不显示错误信息。-v 反转查找。-w 只显示全字符合的列。-x 只显示全列符合的列。-y 此参数效果跟“-i”相同。-o 只输出文件中匹配到的部分。 常见用法搜索文件中包含 match_pattern 的文本行语法 1234grep match_pattern file_name1 fie_name2 ...grep &quot;match_pattern&quot; file_name1 fie_name2 ...注：match_pattern中若有空格等，请将其用双引号（&quot;&quot;）括起来，匹配文件可以是多个，中间用空格分开 示例 123[root@hadoop-centos-01 ~]# grep &quot;bin/bash&quot; /etc/passwdroot:x:0:0:root:/root:/bin/bashhadoop:x:1000:1000:hadoop:/home/hadoop:/bin/bash 输出除匹配之外的所有行 -v 选项 12345678[root@hadoop-centos-01 test]# grep -v &quot;bin/bash&quot; /etc/passwdbin:x:1:1:bin:/bin:/sbin/nologindaemon:x:2:2:daemon:/sbin:/sbin/nologinadm:x:3:4:adm:/var/adm:/sbin/nologinlp:x:4:7:lp:/var/spool/lpd:/sbin/nologinsync:x:5:0:sync:/sbin:/bin/syncshutdown:x:6:0:shutdown:/sbin:/sbin/shutdown... 标记匹配颜色 –color=auto 选项 1grep &quot;match_pattern&quot; file_name --color=auto 使用正则表达式 -E 选项 123grep -E &quot;[1-9]+&quot;或egrep &quot;[1-9]+&quot; 1234567[root@hadoop-centos-01 test]# echo this is a test line. | grep -o -E &quot;[a-z]+\.&quot;line.[root@hadoop-centos-01 test]# echo this is a test line. | egrep -o &quot;[a-z]+\.&quot;line.注: -o 选项只输出文件中匹配到的部分 统计文件或者文本中包含匹配字符串的总行数 -c 选项 1grep -c &quot;text&quot; file_name 12[root@hadoop-centos-01 test]# grep -c &apos;bin/bash&apos; /etc/passwd2 输出包含匹配字符串的行数 -n 选项： 123456grep &quot;text&quot; -n file_name或cat file_name | grep &quot;text&quot; -n#多个文件grep &quot;text&quot; -n file_1 file_2 123[root@hadoop-centos-01 test]# grep -n &apos;bin/bash&apos; /etc/passwd1:root:x:0:0:root:/root:/bin/bash43:hadoop:x:1000:1000:hadoop:/home/hadoop:/bin/bash 打印样式匹配所位于的字符或字节偏移 123456[root@hadoop-centos-01 test]# echo gun is not unix | grep -b -o &quot;not&quot;7:not注：一行中字符串的字符是从该行的第一个字符开始计算，起始值为0。选项 -b -o 一般总是配合使用。 -b 在显示符合范本样式的那一行之外，并显示该行之前的内容。 -o 只输出文件中匹配到的部分。 搜索多个文件并查找匹配文本在哪些文件中 1grep -l &quot;text&quot; file1 file2 file3... grep递归搜索文件在多级目录中对文本进行递归搜索 1grep &quot;text&quot; . -r -n # .表示当前目录。 1234[root@hadoop-centos-01 test]# grep love . -r -n./ts.txt:1:He likes his lover./ts.txt:2:He loves his lover./ts.txt:4:She loves her liker 忽略匹配样式中的字符大小写 12[root@hadoop-centos-01 test]# echo &quot;hello world&quot; | grep -i &quot;HELLO&quot;hello world 选项 -e 进行多个匹配样式 1234567[root@hadoop-centos-01 test]# echo this is a text line | grep -e &quot;is&quot; -e &quot;line&quot; -oisisline[root@hadoop-centos-01 test]# echo this is a text line | grep -e &quot;is&quot; -e &quot;line&quot; -n1:this is a text line 在grep搜索结果中包括或者排除指定文件 12345678#只在目录中所有的.php和.html文件中递归搜索字符&quot;main()&quot;grep &quot;main()&quot; . -r --include *.&#123;php,html&#125;#在搜索结果中排除所有README文件grep &quot;main()&quot; . -r --exclude &quot;README&quot;#在搜索结果中排除filelist文件列表里的文件grep &quot;main()&quot; . -r --exclude-from filelist Reference https://man.linuxde.net/grep]]></content>
      <categories>
        <category>Linux</category>
        <category>command</category>
        <category>grep</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>command</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo 添加页面点击特效]]></title>
    <url>%2Fhexo%2Fck9bgz7mz004cqov70yaopp7f.html</url>
    <content type="text"><![CDATA[本文主要介绍点击页面出现心形图标。 红心 鼠标的点击红心特效如下： 在/themes/next/source/js/src下新建文件 clicklove.js，接着把下面的代码拷贝粘贴到 clicklove.js 文件中： 1!function(e,t,a)&#123;function n()&#123;c(&quot;.heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: &apos;&apos;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;&quot;),o(),r()&#125;function r()&#123;for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText=&quot;left:&quot;+d[e].x+&quot;px;top:&quot;+d[e].y+&quot;px;opacity:&quot;+d[e].alpha+&quot;;transform:scale(&quot;+d[e].scale+&quot;,&quot;+d[e].scale+&quot;) rotate(45deg);background:&quot;+d[e].color+&quot;;z-index:99999&quot;);requestAnimationFrame(r)&#125;function o()&#123;var t=&quot;function&quot;==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a=t.createElement(&quot;div&quot;);a.className=&quot;heart&quot;,d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a=t.createElement(&quot;style&quot;);a.type=&quot;text/css&quot;;try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName(&quot;head&quot;)[0].appendChild(a)&#125;function s()&#123;return&quot;rgb(&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;)&quot;&#125;var d=[];e.requestAnimationFrame=function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document); 在\themes\next\layout_layout.swig文件末尾添加： 12&lt;!-- 页面点击小红心 --&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/clicklove.js&quot;&gt;&lt;/script&gt; fireworks 鼠标的点击红心特效如下： 在themes/next/source/js/src里面建一个叫fireworks.js的文件，添加如下代码： 1&quot;use strict&quot;;function updateCoords(e)&#123;pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top&#125;function setParticuleDirection(e)&#123;var t=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return&#123;x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)&#125;&#125;function createParticule(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function()&#123;ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()&#125;,a&#125;function createCircle(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color=&quot;#F00&quot;,a.radius=0.1,a.alpha=0.5,a.lineWidth=6,a.draw=function()&#123;ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1&#125;,a&#125;function renderParticule(e)&#123;for(var t=0;t&lt;e.animatables.length;t++)&#123;e.animatables[t].target.draw()&#125;&#125;function animateParticules(e,t)&#123;for(var a=createCircle(e,t),n=[],i=0;i&lt;numberOfParticules;i++)&#123;n.push(createParticule(e,t))&#125;anime.timeline().add(&#123;targets:n,x:function(e)&#123;return e.endPos.x&#125;,y:function(e)&#123;return e.endPos.y&#125;,radius:0.1,duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule&#125;).add(&#123;targets:a,radius:anime.random(80,160),lineWidth:0,alpha:&#123;value:0,easing:&quot;linear&quot;,duration:anime.random(600,800)&#125;,duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule,offset:0&#125;)&#125;function debounce(e,t)&#123;var a;return function()&#123;var n=this,i=arguments;clearTimeout(a),a=setTimeout(function()&#123;e.apply(n,i)&#125;,t)&#125;&#125;var canvasEl=document.querySelector(&quot;.fireworks&quot;);if(canvasEl)&#123;var ctx=canvasEl.getContext(&quot;2d&quot;),numberOfParticules=30,pointerX=0,pointerY=0,tap=&quot;mousedown&quot;,colors=[&quot;#FF1461&quot;,&quot;#18FF92&quot;,&quot;#5A87FF&quot;,&quot;#FBF38C&quot;],setCanvasSize=debounce(function()&#123;canvasEl.width=2*window.innerWidth,canvasEl.height=2*window.innerHeight,canvasEl.style.width=window.innerWidth+&quot;px&quot;,canvasEl.style.height=window.innerHeight+&quot;px&quot;,canvasEl.getContext(&quot;2d&quot;).scale(2,2)&#125;,500),render=anime(&#123;duration:1/0,update:function()&#123;ctx.clearRect(0,0,canvasEl.width,canvasEl.height)&#125;&#125;);document.addEventListener(tap,function(e)&#123;&quot;sidebar&quot;!==e.target.id&amp;&amp;&quot;toggle-sidebar&quot;!==e.target.id&amp;&amp;&quot;A&quot;!==e.target.nodeName&amp;&amp;&quot;IMG&quot;!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))&#125;,!1),setCanvasSize(),window.addEventListener(&quot;resize&quot;,setCanvasSize,!1)&#125;&quot;use strict&quot;;function updateCoords(e)&#123;pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top&#125;function setParticuleDirection(e)&#123;var t=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return&#123;x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)&#125;&#125;function createParticule(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function()&#123;ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()&#125;,a&#125;function createCircle(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color=&quot;#F00&quot;,a.radius=0.1,a.alpha=0.5,a.lineWidth=6,a.draw=function()&#123;ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1&#125;,a&#125;function renderParticule(e)&#123;for(var t=0;t&lt;e.animatables.length;t++)&#123;e.animatables[t].target.draw()&#125;&#125;function animateParticules(e,t)&#123;for(var a=createCircle(e,t),n=[],i=0;i&lt;numberOfParticules;i++)&#123;n.push(createParticule(e,t))&#125;anime.timeline().add(&#123;targets:n,x:function(e)&#123;return e.endPos.x&#125;,y:function(e)&#123;return e.endPos.y&#125;,radius:0.1,duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule&#125;).add(&#123;targets:a,radius:anime.random(80,160),lineWidth:0,alpha:&#123;value:0,easing:&quot;linear&quot;,duration:anime.random(600,800)&#125;,duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule,offset:0&#125;)&#125;function debounce(e,t)&#123;var a;return function()&#123;var n=this,i=arguments;clearTimeout(a),a=setTimeout(function()&#123;e.apply(n,i)&#125;,t)&#125;&#125;var canvasEl=document.querySelector(&quot;.fireworks&quot;);if(canvasEl)&#123;var ctx=canvasEl.getContext(&quot;2d&quot;),numberOfParticules=30,pointerX=0,pointerY=0,tap=&quot;mousedown&quot;,colors=[&quot;#FF1461&quot;,&quot;#18FF92&quot;,&quot;#5A87FF&quot;,&quot;#FBF38C&quot;],setCanvasSize=debounce(function()&#123;canvasEl.width=2*window.innerWidth,canvasEl.height=2*window.innerHeight,canvasEl.style.width=window.innerWidth+&quot;px&quot;,canvasEl.style.height=window.innerHeight+&quot;px&quot;,canvasEl.getContext(&quot;2d&quot;).scale(2,2)&#125;,500),render=anime(&#123;duration:1/0,update:function()&#123;ctx.clearRect(0,0,canvasEl.width,canvasEl.height)&#125;&#125;);document.addEventListener(tap,function(e)&#123;&quot;sidebar&quot;!==e.target.id&amp;&amp;&quot;toggle-sidebar&quot;!==e.target.id&amp;&amp;&quot;A&quot;!==e.target.nodeName&amp;&amp;&quot;IMG&quot;!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))&#125;,!1),setCanvasSize(),window.addEventListener(&quot;resize&quot;,setCanvasSize,!1)&#125;; 打开themes/next/layout/_layout.swig,在L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/01/assets/haru01.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.7}});上面写下如下代码： 12345 &#123;% if theme.fireworks %&#125; &lt;canvas class=&quot;fireworks&quot; style=&quot;position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;&quot; &gt;&lt;/canvas&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;//cdn.bootcss.com/animejs/2.2.0/anime.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/fireworks.js&quot;&gt;&lt;/script&gt; &#123;% endif %&#125; 打开主题配置文件，在里面最后写下： 12# Fireworksfireworks: true]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo 增加浏览次数与访客数量统计功能]]></title>
    <url>%2Fhexo%2Fconfig%2Fck9bgz7n3004gqov7o8dixfgi.html</url>
    <content type="text"><![CDATA[以NexT主题（其他主题类似）为例 安装busuanzi.js脚本 在 /theme/next/layout/_partial/footer.swig文件开头添加下面的代码： 1&lt;script async src=&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; 显示统计标签 编辑 /themes/next/_config.yml（主题配置文件）文件：在 footer（通过查找定位）下面添加如下内容，注意缩进： 1234footer: # 用于控制浏览次数和访问数量显示与否 counter: enable: true 在 /theme/next/layout/_partial/footer.swig文件结尾添加下面的代码： 12345&#123;% if theme.footer.counter &amp;&amp; theme.footer.counter.enable %&#125; &lt;span id=&quot;busuanzi_container_site_pv&quot;&gt;总访问量&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次&lt;/span&gt; &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt; &lt;span id=&quot;busuanzi_container_site_uv&quot;&gt;总访客数&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;人&lt;/span&gt;&#123;% endif %&#125; 附录 不蒜子是一款用来记录访客和访问量的插件，其可直接将访问次数显示在您在网页上（也可不显示）；对于已经上线一段时间的网站，“不蒜子”允许您初始化首次数据。不蒜子有两种算法可选： 算法a：pv的方式，单个用户连续点击n篇文章，记录n次访问量。 123&lt;span id=&quot;busuanzi_container_site_pv&quot;&gt; 本站总访问量&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次&lt;/span&gt; 算法b：uv的方式，单个用户连续点击n篇文章，只记录1次访客数。 &lt;span id=&quot;busuanzi_container_site_uv&quot;&gt; 本站访客数&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;人次 &lt;/span&gt;]]></content>
      <categories>
        <category>hexo</category>
        <category>config</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux pkill command]]></title>
    <url>%2FLinux%2Fcommand%2Fpkill%2Fck9bgz7yg0098qov7qnjzr84f.html</url>
    <content type="text"><![CDATA[作用pkill 用做管理进程时，pkill 命令和 killall 命令的用法相同，都是通过进程名杀死一类进程pkill 另一重要的功能就是按照终端用户来剔出用户登录 用法 语法格式 1pkill [options] pattern 参数选项 123456789101112131415161718192021222324-&lt;sig&gt;, --signal &lt;sig&gt; signal to send (either number or name)-e, --echo display what is killed-c, --count count of matching processes-f, --full use full process name to match-g, --pgroup &lt;PGID,...&gt; match listed process group IDs-G, --group &lt;GID,...&gt; match real group IDs-n, --newest select most recently started-o, --oldest select least recently started-P, --parent &lt;PPID,...&gt; match only child processes of the given parent-s, --session &lt;SID,...&gt; match session IDs-t, --terminal &lt;tty,...&gt; match by controlling terminal-u, --euid &lt;ID,...&gt; match by effective IDs-U, --uid &lt;ID,...&gt; match by real IDs-x, --exact match exactly with the command name-F, --pidfile &lt;file&gt; read PIDs from file-L, --logpidfile fail if PID file is not locked--ns &lt;PID&gt; match the processes that belong to the same namespace as &lt;pid&gt;--nslist &lt;ns,...&gt; list which namespaces will be considered for the --ns option. Available namespaces: ipc, mnt, net, pid, user, uts -h, --help display this help and exit-V, --version output version information and exi 用法示例 用做进程管理，根据进程名杀死一类进程 语法格式 1pkill [信号] 进程名 命令常用的信号及其含义 信号编号 信号名 含义 0 EXIT 程序退出时收到该信息。 1 HUP 挂掉电话线或终端连接的挂起信号，这个信号也会造成某些进程在没有终止的情况下重新初始化。 2 INT 表示结束进程，但并不是强制性的，常用的 “Ctrl+C” 组合键发出就是一个 kill -2 的信号。 3 QUIT 退出。 9 KILL 杀死进程，即强制结束进程。 11 SEGV 段错误。 15 TERM 正常结束进程，是 kill 命令的默认信号。 用法示例 12345678910111213# 查看python进程[root@hadoop-centos-01 ~]# pstree -p | grep python | |-sshd(33793)---bash(33803)---python(34176)[root@hadoop-centos-01 ~]#[root@hadoop-centos-01 ~]# ps -ef | grep pythonroot 34176 33803 0 22:30 pts/2 00:00:00 pythonroot 34188 33542 0 22:31 pts/1 00:00:00 grep --color=auto python# 执行pkill后再去查看，python进程已被杀死[root@hadoop-centos-01 ~]# pkill -kill python[root@hadoop-centos-01 ~]# pstree -p | grep python[root@hadoop-centos-01 ~]# ps -ef | grep pythonroot 34241 33542 0 22:33 pts/1 00:00:00 grep --color=auto python 踢出登陆用户 语法格式 1pkill [-t 终端号] 进程名 用法示例 12345678910111213141516[root@hadoop-centos-01 ~]# w # 查看当前登陆的用户 22:47:54 up 1 day, 16:20, 4 users, load average: 0.00, 0.01, 0.05USER TTY FROM LOGIN@ IDLE JCPU PCPU WHATroot pts/0 192.168.244.6 08:03 14:43m 0.13s 0.13s -bashroot pts/1 192.168.244.6 21:56 2.00s 0.41s 0.01s wroot pts/2 192.168.244.6 22:03 18.00s 0.10s 0.10s -bashroot pts/3 192.168.244.6 06:35 14:43m 0.17s 0.17s -bash[root@hadoop-centos-01 ~]#[root@hadoop-centos-01 ~]# pkill -kill -t pts/2[root@hadoop-centos-01 ~]# w # 再次查看，pts/2已被杀掉 22:51:26 up 1 day, 16:24, 3 users, load average: 0.01, 0.02, 0.05USER TTY FROM LOGIN@ IDLE JCPU PCPU WHATroot pts/0 192.168.244.6 08:03 14:46m 0.13s 0.13s -bashroot pts/1 192.168.244.6 21:56 6.00s 0.43s 0.02s wroot pts/3 192.168.244.6 06:35 14:47m 0.17s 0.17s -bash]]></content>
      <categories>
        <category>Linux</category>
        <category>command</category>
        <category>pkill</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>command</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git 不同仓库间进行项目迁移]]></title>
    <url>%2Fgit%2Fck9bgz7mf003uqov7wvuc97wj.html</url>
    <content type="text"><![CDATA[需求 将仓库A的某个branch的代码独立成为一个新的仓库B。并且提交的代码为当前分支最新的，且保留整个提交历史。这种需求对于git来说小菜一碟，可通过git remote命令来实现。 实现 拉取仓库A当前分支(例如 master 分支)，保持其为最新的 123456789git pull origin master # 拉取远程master分支的代码注：origin 代表远程仓库，其指向当前仓库的git地址, git remote 可进行查看，如下：$ git remoteorigin$ git remote -vorigin https://github.com/forgetST/blog.git (fetch)origin https://github.com/forgetST/blog.git (push) 创建仓库B(例如 test)，若不存在 在仓库A（blog）中增加仓库B的远程地址，即git地址 123456789101112131415# 当前只关联了一个远程仓库A$ git remote -vorigin https://github.com/forgetST/blog.git (fetch)origin https://github.com/forgetST/blog.git (push)# 关联远程仓库B(test)# test只是别名，可以随意起，但不能与已有远程名同名，至于原因，大家都想自己是独一无二的吗^-^$ git remote add test https://github.com/forgetST/test.git# 仓库test已关联成功$ git remote -vorigin https://github.com/forgetST/blog.git (fetch)origin https://github.com/forgetST/blog.git (push)test https://github.com/forgetST/test.git (fetch)test https://github.com/forgetST/test.git (push) 仓库A（blog）代码推送到仓库A（test） 12$ git push test master # 一般会失败，错误见附录$ git push -f test master # 强制推送，有风险，慎用 附录 git remote add 用法： 12345678910usage: git remote add [&lt;options&gt;] &lt;name&gt; &lt;url&gt; -f, --fetch fetch the remote branches --tags import all tags and associated objects when fetching or do not fetch any tag at all (--no-tags) -t, --track &lt;branch&gt; branch(es) to track -m, --master &lt;branch&gt; master branch --mirror[=(push|fetch)] set up remote as a mirror to push to or fetch from *git push origin_name origin_branch出错 * 1234567891011$ git push test masterTo https://github.com/forgetST/test.git ! [rejected] master -&gt; master (fetch first)error: failed to push some refs to &apos;https://github.com/forgetST/test.git&apos;hint: Updates were rejected because the remote contains work that you dohint: not have locally. This is usually caused by another repository pushinghint: to the same ref. You may want to first integrate the remote changeshint: (e.g., &apos;git pull ...&apos;) before pushing again.hint: See the &apos;Note about fast-forwards&apos; in &apos;git push --help&apos; for details.注：当前分支有改动，可新建新的分支进行推送，新建分支不能与推送的仓库已有分支重名。或者强制推送，加选项 -f，视情况而用（慎用）。]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux kill command]]></title>
    <url>%2FLinux%2Fcommand%2Fkill%2Fck9bgz7xq008yqov7rp0wwreh.html</url>
    <content type="text"><![CDATA[作用kill 命令是用来向进程发送一个用户指定的信号，对进程进行相应的操作。 kill 命令的执行原理是向操作系统内核发送一个信号（多是终止信号）和目标进程的 PID，系统内核根据收到的信号类型，对指定进程进行相应的操作。 进程PID可用ps、pidof、pstree、top等工具获取，然后使用kill命令来结束该进程。 用法命令格式123456kill [options] &lt;pid&gt; [...]options : -&lt;signal&gt; : 指定发送给进程的信号，指定信号的名称或号码都可以。 -l : 列出所有信号的名称和号码。&lt;pid&gt; […] : 把信号发送给列出的所有进程。 命令参数123456-l 参数为信号名称，显示该信号的数字。如果不加信号参数，显示全部信号名称-p 指定kill 命令只打印相关进程的进程号，而不发送任何信号-s 指定发送信号-u 指定用户-signal_name 指定进程发送信号名称-signal_number 指定进程发送信号数字 使用实例12345678910111213141516[root@hadoop-centos-01 ~]# kill -l 1) SIGHUP 2) SIGINT 3) SIGQUIT 4) SIGILL 5) SIGTRAP 6) SIGABRT 7) SIGBUS 8) SIGFPE 9) SIGKILL 10) SIGUSR111) SIGSEGV 12) SIGUSR2 13) SIGPIPE 14) SIGALRM 15) SIGTERM16) SIGSTKFLT 17) SIGCHLD 18) SIGCONT 19) SIGSTOP 20) SIGTSTP21) SIGTTIN 22) SIGTTOU 23) SIGURG 24) SIGXCPU 25) SIGXFSZ26) SIGVTALRM 27) SIGPROF 28) SIGWINCH 29) SIGIO 30) SIGPWR31) SIGSYS 34) SIGRTMIN 35) SIGRTMIN+1 36) SIGRTMIN+2 37) SIGRTMIN+338) SIGRTMIN+4 39) SIGRTMIN+5 40) SIGRTMIN+6 41) SIGRTMIN+7 42) SIGRTMIN+843) SIGRTMIN+9 44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+1348) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-1253) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9 56) SIGRTMAX-8 57) SIGRTMAX-758) SIGRTMAX-6 59) SIGRTMAX-5 60) SIGRTMAX-4 61) SIGRTMAX-3 62) SIGRTMAX-2[root@hadoop-centos-01 ~]# kill -l SIGRTMIN+1246 代号 名称 内容 1 SIGHUP 启动被终止的程序，可让该进程重新读取自己的配置文件，类似重新启动。 2 SIGINT 相当于用键盘输入 [ctrl]-c 来中断一个程序的进行。 9 SIGKILL 代表强制中断一个程序的进行，如果该程序进行到一半，那么尚未完成的部分可能会有“半产品”产生，类似 vim会有 .filename.swp 保留下来。 15 SIGTERM 以正常的方式来终止该程序。由于是正常的终止，所以后续的动作会将他完成。不过，如果该程序已经发生问题，就是无法使用正常的方法终止时，输入这个 signal 也是没有用的。 19 SIGSTOP 相当于用键盘输入 [ctrl]-z 来暂停一个程序的进行。 12[root@hadoop-centos-01 ~]# kill -15 pid# 这条命令发信号让进程正常退出。所谓的正常退出是指按应用程序自己的退出流程完成退出，这样就可以清理并释放资源。 12[root@hadoop-centos-01 ~]# kill -9 pid# 强制结束进程，这样结束掉的进程不会进行资源的清理工作。 12[root@hadoop-centos-01 ~]# kill -19 pid# 暂停进程 1234# 杀死指定用户所有进程[root@hadoop-centos-01 ~]# kill -9 $(ps -ef | grep username)# 或[root@hadoop-centos-01 ~]# kill -u username 总结kill命令可以带信号选项，也可以不带信号。如果没有信号号码，kill命令就会发出终止信号（15），该信号可以被进程捕获，使进程在退出之前可以清理并释放资源。也可以向进程发送发送指定信号； 可以向多个进程发信号或终止它们，当kill成功地发送了信号后，shell会在屏幕上显示出进程的终止信息； 应注意，信号使进程强行终止，这常会带来一些副作用，如数据丢失或者终端无法恢复到正常状态。发送信号时必须小心，只有在万不得已时，才用kill信号(9)，因为进程不能首先捕获它。要撤销所有的后台作业，可以输入kill 0。因为有些在后台运行的命令会启动多个进程，跟踪并找到所有要杀掉的进程的PID是件很麻烦的事。这时，使用kill 0来终止所有由当前shell启动的进程，是个有效的方法； kill 命令并不能100%终止进程，kill 命令只是“发送”一个信号，故只有当信号被程序成功“捕获”，系统才会执行 kill 命令指定的操作；反之，如果信号被“封锁”或者“忽略”，则 kill 命令将会失效。]]></content>
      <categories>
        <category>Linux</category>
        <category>command</category>
        <category>kill</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>command</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux killall command]]></title>
    <url>%2FLinux%2Fcommand%2Fkillall%2Fck9bgz7y70091qov71m5uy1l1.html</url>
    <content type="text"><![CDATA[作用killall - kill processes by name killall sends a signal to all processes running any of the specified commands. If no signal name is specified, SIGTERM is sent. Signals can be specified either by name (e.g. -HUP or -SIGHUP) or by number (e.g. -1) or by option -s. If the command name is not regular expression (option -r) and contains a slash (/), processes executing that particular file will be selected for killing, independent of their name. killall returns a zero return code if at least one process has been killed for each listed command, or no commands were listed and at least one process matched the -u and -Z search criteria. killall returns non-zero otherwise. A killall process never kills itself (but may kill other killall processes) 用法命令格式123killall [-Z CONTEXT] [-u USER] [ -eIgiqrvw ] [ -SIGNAL ] NAME...killall -l, --listkillall -V, --version 命令参数12345678910111213141516-e,--exact require exact match for very long names-I,--ignore-case case insensitive process name match-g,--process-group kill process group instead of process-y,--younger-than kill processes younger than TIME-o,--older-than kill processes older than TIME-i,--interactive ask for confirmation before killing-l,--list list all known signal names-q,--quiet don&apos;t print complaints-r,--regexp interpret NAME as an extended regular expression-s,--signal SIGNAL send this signal instead of SIGTERM-u,--user USER kill only process(es) running as USER-v,--verbose report if the signal was successfully sent-V,--version display version information-w,--wait wait for processes to die-Z,--context REGEXP kill only process(es) having context (must precede other arguments) 123456789101112131415-e,--exact 精准匹配。由于命令名长于15个字符时，会杀死匹配前15个字符的所有进程。此时需要使用-e选项进行精准匹配。-g,--process-group 杀死属于该进程组的所有进程。-i,--interactive 交互式，杀死进程前请求确认-I,--ignore-case 进程名匹配不区分大小写-l,--list 列出所有信号名-o,--older-than 仅匹配指定时间之前（在指定时间之前开始）的进程。单位s、m、h、d、w（周）、M、y-q,--quiet 静默模式，不报错-r,--regexp 使用扩展正则表达式解释name-s,--signal 发送指定信号等同[-signal]-u.--user 仅终止指定用户拥有的进程。命令名是可选的。-v,--verbose 报告是否发送成功-V,version 显示版本-w,--wait 等待killall执行完成，每秒检测一次，直到完成返回。如果信号被忽略或不起作用，或停留在僵尸状态，killall会永久等待。-y,--younger-than 仅匹配指定时间之后的进程，与-o选项相反。-z,--context （仅限SELinux）指定环境（变量）：仅杀死含有与指定扩展正则表达式匹配的环境（变量）的进程。必须在其他参数之前，命令名是可选的。 用法示例查看版本 12345678[root@hadoop-centos-01 ~]# killall -Vkillall (PSmisc) 22.20Copyright (C) 1993-2012 Werner Almesberger and Craig SmallPSmisc comes with ABSOLUTELY NO WARRANTY.This is free software, and you are welcome to redistribute it underthe terms of the GNU General Public License.For more information about these matters, see the files named COPYING. 查看信号列表 1234[root@hadoop-centos-01 ~]# killall -lHUP INT QUIT ILL TRAP ABRT IOT BUS FPE KILL USR1 SEGV USR2 PIPE ALRM TERMSTKFLT CHLD CONT STOP TSTP TTIN TTOU URG XCPU XFSZ VTALRM PROF WINCH IO PWR SYSUNUSED 常用的信号说明： HUP（1，终端断线）， INT（2，中断，同&lt;Ctrl&gt;+c） QUIT（3，退出，同&lt;Ctrl&gt;+\） KILL（9，强制终止） TERM（15，缺省信号，终止，正常结束） CONT（18，继续，同fg/bg命令） STOP（19，停止） TSTP（20，暂停，同&lt;Ctrl&gt;+Z） 杀死所有同名进程 12345678910111213[root@hadoop-centos-01 ~]# ps -aux | grep pythonroot 32618 0.0 0.0 112708 980 pts/0 S+ 07:18 0:00 grep --color=auto python# 启动一个python后台进程[root@hadoop-centos-01 ~]# ps -aux | grep pythonroot 32619 0.2 0.5 130456 5040 pts/3 S+ 07:18 0:00 pythonroot 32621 0.0 0.0 112708 980 pts/0 S+ 07:18 0:00 grep --color=auto python# 执行 killall python 命令， 等效于 killall -15 python[root@hadoop-centos-01 ~]# killall python# 再次过滤发现该进程以终止[root@hadoop-centos-01 ~]# ps -aux | grep pythonroot 32624 0.0 0.0 112708 980 pts/0 S+ 07:18 0:00 grep --color=auto python 向进程发送指定信号 123456789101112131415161718[root@hadoop-centos-01 ~]# ps -aux | grep pythonroot 32670 0.1 0.5 130456 5044 pts/3 T 07:22 0:00 pythonroot 32684 0.0 0.0 112708 980 pts/0 S+ 07:23 0:00 grep --color=auto python[root@hadoop-centos-01 ~]# killall python; ps -aux | grep pythonroot 32670 0.0 0.5 130456 5044 pts/3 T 07:22 0:00 pythonroot 32734 0.0 0.0 112708 980 pts/0 S+ 07:26 0:00 grep --color=auto python# 正常无法终止进程时，需要强制终止，需发送指定信号，终止进程[root@hadoop-centos-01 ~]# killall -9 pythonPython 2.7.15 (default, May 17 2019, 07:26:27)[GCC 4.8.5 20150623 (Red Hat 4.8.5-36)] on linux2Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt;[1]+ Stopped python[root@hadoop-centos-01 ~]# ps -aux | grep pythonroot 32766 0.0 0.0 112708 980 pts/0 S+ 07:29 0:00 grep --color=auto python 杀掉所有的登录后的shell 123456[root@hadoop-centos-01 ~]# killall -9 bashSession stopped - Press &lt;return&gt; to exit tab - Press R to restart session - Press S to save terminal output to file]]></content>
      <categories>
        <category>Linux</category>
        <category>command</category>
        <category>killall</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>command</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python __future__ module]]></title>
    <url>%2Fpython%2Fmodule%2Fck9bgz7zt00a6qov7xgv57zh6.html</url>
    <content type="text"><![CDATA[简介将下一个新版本的特性导入到当前版本并进行测试（新版的改动不兼容老版本，就是这么任性）。 py2.7-源代码: Lib/__future__.py py3.7-源代码：Lib/__future__.py 属性python2.7123&gt;&gt;&gt; import __future__ as ft&gt;&gt;&gt; dir(ft)[&apos;CO_FUTURE_ABSOLUTE_IMPORT&apos;, &apos;CO_FUTURE_DIVISION&apos;, &apos;CO_FUTURE_PRINT_FUNCTION&apos;, &apos;CO_FUTURE_UNICODE_LITERALS&apos;, &apos;CO_FUTURE_WITH_STATEMENT&apos;, &apos;CO_GENERATOR_ALLOWED&apos;, &apos;CO_NESTED&apos;, &apos;_Feature&apos;, &apos;__all__&apos;, &apos;__builtins__&apos;, &apos;__doc__&apos;, &apos;__file__&apos;, &apos;__name__&apos;, &apos;__package__&apos;, &apos;absolute_import&apos;, &apos;all_feature_names&apos;, &apos;division&apos;, &apos;generators&apos;, &apos;nested_scopes&apos;, &apos;print_function&apos;, &apos;unicode_literals&apos;, &apos;with_statement&apos;] python3.7123&gt;&gt;&gt; import __future__ as ft&gt;&gt;&gt; dir(ft) [&apos;CO_FUTURE_ABSOLUTE_IMPORT&apos;, &apos;CO_FUTURE_ANNOTATIONS&apos;, &apos;CO_FUTURE_BARRY_AS_BDFL&apos;, &apos;CO_FUTURE_DIVISION&apos;, &apos;CO_FUTURE_GENERATOR_STOP&apos;, &apos;CO_FUTURE_PRINT_FUNCTION&apos;, &apos;CO_FUTURE_UNICODE_LITERALS&apos;, &apos;CO_FUTURE_WITH_STATEMENT&apos;, &apos;CO_GENERATOR_ALLOWED&apos;, &apos;CO_NESTED&apos;, &apos;_Feature&apos;, &apos;__all__&apos;, &apos;__builtins__&apos;, &apos;__cached__&apos;, &apos;__doc__&apos;, &apos;__file__&apos;, &apos;__loader__&apos;, &apos;__name__&apos;, &apos;__package__&apos;, &apos;__spec__&apos;, &apos;absolute_import&apos;, &apos;all_feature_names&apos;, &apos;annotations&apos;, &apos;barry_as_FLUFL&apos;, &apos;division&apos;, &apos;generator_stop&apos;, &apos;generators&apos;, &apos;nested_scopes&apos;, &apos;print_function&apos;, &apos;unicode_literals&apos;, &apos;with_statement&apos;] __future__.py 中的每一条语句都是以下格式的： 1FeatureName = _Feature(OptionalRelease, MandatoryRelease, CompilerFlag) OptionalRelease 和 MandatoryRelease 的格式为 5 元素元组，如下： 123456(PY_MAJOR_VERSION, # the 2 in 2.1.0a3; an int PY_MINOR_VERSION, # the 1; an int PY_MICRO_VERSION, # the 0; an int PY_RELEASE_LEVEL, # &quot;alpha&quot;, &quot;beta&quot;, &quot;candidate&quot; or &quot;final&quot;; string PY_RELEASE_SERIAL # the 3; an int) OptionalRelease 记录一个特性首次发布时的 Python 版本。 MandatoryRelases 未发布时，表示该特性会变成语言的一部分的预测时间。 发布后，用来记录这个特性是何时成为语言的一部分的。从该版本往后，使用该特性将不需要 future 语句，不过很多人还是会加上对应的 import。 若是 None, 表示这个特性已经被撤销。 CompilerFlag 若代码需要动态编译，在调用内建函数compile() 时需传入以开启对应的特性，其存储在对应实例的compiler_flag变量中。 __future__ 中不会删除特性的描述。从 Python 2.1 中首次加入以来，通过这种方式引入了以下特性： 特性 可选版本 强制加入版本 效果 nested_scopes 2.1.0b1 2.2 PEP 227: Statically Nested Scopes generators 2.2.0a1 2.3 PEP 255: Simple Generators division 2.2.0a2 3.0 PEP 238: Changing the Division Operator absolute_import 2.5.0a1 3.0 PEP 328: Imports: Multi-Line and Absolute/Relative with_statement 2.5.0a1 2.6 PEP 343: The “with” Statement print_function 2.6.0a2 3.0 PEP 3105: Make print a function unicode_literals 2.6.0a2 3.0 PEP 3112: Bytes literals in Python 3000 generator_stop 3.5.0b1 3.7 PEP 479: StopIteration handling inside generators annotations 3.7.0b1 4.0 PEP 563: Postponed evaluation of annotations 用法divisionpython 2.7示例： 123456789# Python 2.x中，对于除法有两种情况，如果是整数相除，结果仍是整数，余数会被扔掉，这种除法叫“地板除”&gt;&gt;&gt; 10 / 33&gt;&gt;&gt; 10.0 / 3 3.3333333333333335&gt;&gt;&gt; from __future__ import division # 导入后除法将变为精确除法&gt;&gt;&gt; 10 / 33.3333333333333335 12345# Python 3.x中，所有的除法都是精确除法，地板除用//表示&gt;&gt;&gt; 10 / 3 3.3333333333333335&gt;&gt;&gt; 10 // 3 3 unicode_literalspython2.7示例： 123456789101112131415&gt;&gt;&gt; type(&apos;hello world&apos;)&lt;type &apos;str&apos;&gt;&gt;&gt;&gt; type(b&apos;hello world&apos;)&lt;type &apos;str&apos;&gt;&gt;&gt;&gt; type(u&apos;hello world&apos;)&lt;type &apos;unicode&apos;&gt;# python3 默认字符编码为 unicode， 类型为 str&gt;&gt;&gt; from __future__ import unicode_literals&gt;&gt;&gt; type(&apos;hello world&apos;)&lt;type &apos;unicode&apos;&gt;&gt;&gt;&gt; type(b&apos;hello world&apos;)&lt;type &apos;str&apos;&gt;&gt;&gt;&gt; type(u&apos;hello world&apos;)&lt;type &apos;unicode&apos;&gt; python3.7示例： 123456&gt;&gt;&gt; type(&apos;hello world&apos;) &lt;class &apos;str&apos;&gt;&gt;&gt;&gt; type(b&apos;hello world&apos;) &lt;class &apos;bytes&apos;&gt;&gt;&gt;&gt; type(u&apos;hello world&apos;) &lt;class &apos;str&apos;&gt; 注：如果你是python2.X版本，在导入新的功能特性后，就应该按照新功能的特性进行编写。 absolute_import加入绝对引入新特性]]></content>
      <categories>
        <category>python</category>
        <category>module</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>module</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux ps command]]></title>
    <url>%2FLinux%2Fcommand%2Fps%2Fck9bgz7yp009cqov7maus6tmo.html</url>
    <content type="text"><![CDATA[作用ps 命令是Process Status的缩写，用于进程的监测和控制。 ps 命令是最基本进程查看命令，使用该命令可以确定有哪些进程正在运行和运行的状态、进程是否结束、进程有没有僵尸、哪些进程占用了过多的资源等。 ps 命令显示的是瞬间进程的状态，并不是动态连续的；如果想对进程进行实时监控可用top命令。 用法命令格式1ps [options] [--help] 命令参数1234567891011121314[root@hadoop-centos-01 ~]# ps --help simpleUsage: ps [options]Basic options: -A, -e all processes -a all with tty, except session leaders a all with tty, including other users -d all except session leaders -N, --deselect negate selection r only running processes T all processes on this terminal x processes without controlling tty 123456789101112131415161718192021[root@hadoop-centos-01 ~]# ps --help listUsage: ps [options]Selection by list: -C &lt;command&gt; command name -G, --Group &lt;GID&gt; real group id or name -g, --group &lt;group&gt; session or effective group name -p, p, --pid &lt;PID&gt; process id --ppid &lt;PID&gt; parent process id -q, q, --quick-pid &lt;PID&gt; process id (quick mode) -s, --sid &lt;session&gt; session id -t, t, --tty &lt;tty&gt; terminal -u, U, --user &lt;UID&gt; effective user id or name -U, --User &lt;UID&gt; real user id or name The selection options take as their argument either: a comma-separated list e.g. &apos;-u root,nobody&apos; or a blank-separated list e.g. &apos;-p 123 4567&apos; 12345678910111213141516171819202122232425262728293031[root@hadoop-centos-01 ~]# ps --help outputUsage: ps [options]Output formats: -F extra full -f full-format, including command lines f, --forest ascii art process tree -H show process hierarchy -j jobs format j BSD job control format -l long format l BSD long format -M, Z add security data (for SELinux) -O &lt;format&gt; preloaded with default columns O &lt;format&gt; as -O, with BSD personality -o, o, --format &lt;format&gt; user-defined format s signal format u user-oriented format v virtual memory format X register format -y do not show flags, show rss vs. addr (used with -l) --context display security context (for SELinux) --headers repeat header lines, one per page --no-headers do not print header at all --cols, --columns, --width &lt;num&gt; set screen width --rows, --lines &lt;num&gt; set screen height 12345678910[root@hadoop-centos-01 ~]# ps --help threadsUsage: ps [options]Show threads: H as if they were processes -L possibly with LWP and NLWP columns -m, m after processes -T possibly with SPID column 12345678910111213141516171819[root@hadoop-centos-01 ~]# ps --help miscUsage: ps [options]Miscellaneous options: -c show scheduling class with -l option c show true command name e show the environment after command k, --sort specify sort order as: [+|-]key[,[+|-]key[,...]] L show format specifiers n display numeric uid and wchan S, --cumulative include some dead child process data -y do not show flags, show rss (only with -l) -V, V, --version display version information and exit -w, w unlimited output width --help &lt;simple|list|output|threads|misc|all&gt; display help and exit 用法示例123456789101112131415161718192021222324252627282930313233343536To see every process on the system using standard syntax: ps -e ps -ef ps -eF ps -elyTo see every process on the system using BSD syntax: ps ax ps axuTo print a process tree: ps -ejH ps axjfTo get info about threads: ps -eLf ps axmsTo get security info: ps -eo euser,ruser,suser,fuser,f,comm,label ps axZ ps -eMTo see every process running as root (real &amp; effective ID) in user format: ps -U root -u root uTo see every process with a user-defined format: ps -eo pid,tid,class,rtprio,ni,pri,psr,pcpu,stat,wchan:14,comm ps axo stat,euid,ruid,tty,tpgid,sess,pgrp,ppid,pid,pcpu,comm ps -Ao pid,tt,user,fname,tmout,f,wchanPrint only the process IDs of syslogd: ps -C syslogd -o pid=Print only the name of PID 42: ps -q 42 -o comm= 附录Linux上进程有5种状态 运行 – 正在运行或在运行队列中等待 中断 – 休眠中, 受阻, 在等待某个条件的形成或接受到信号 不可中断 – 收到信号不唤醒和不可运行, 进程必须等待直到有中断发生 僵死 – 进程已终止, 但进程描述符存在, 直到父进程调用wait4()系统调用后释放 停止 – 进程收到SIGSTOP, SIGSTP, SIGTIN, SIGTOU信号后停止运行运行 ps工具标识进程的5种状态码 R 运行 runnable (on run queue) S 中断 sleeping D 不可中断 uninterruptible sleep (usually IO) Z 僵死 a defunct (”zombie”) process T 停止 traced or stopped ps命令输出信息含义 表头 含义 USER 该进程是由哪个用户产生的。 PID 进程的 ID。 %CPU 该进程占用 CPU 资源的百分比，占用的百分比越高，进程越耗费资源。 %MEM 该进程占用物理内存的百分比，占用的百分比越高，进程越耗费资源。 VSZ 该进程占用虚拟内存的大小，单位为 KB。 RSS 该进程占用实际物理内存的大小，单位为 KB。 TTY 该进程是在哪个终端运行的。其中，tty1 ~ tty7 代表本地控制台终端（可以通过 Alt+F1 ~ F7 快捷键切换不同的终端），tty1~tty6 是本地的字符界面终端，tty7 是图形终端。pts/0 ~ 255 代表虚拟终端，一般是远程连接的终端，第一个远程连接占用 pts/0，第二个远程连接占用 pts/1，依次増长。 STAT 进程状态。常见的状态有以下几种：-D：不可被唤醒的睡眠状态，通常用于 I/O 情况。-R：该进程正在运行。-S：该进程处于睡眠状态，可被唤醒。-T：停止状态，可能是在后台暂停或进程处于除错状态。-W：内存交互状态（从 2.6 内核开始无效）。-X：死掉的进程（应该不会出现）。-Z：僵尸进程。进程已经中止，但是部分程序还在内存当中。-&lt;：高优先级（以下状态在 BSD 格式中出现）。-N：低优先级。-L：被锁入内存。-s：包含子进程。-l：多线程（小写 L）。-+：位于后台。 START 该进程的启动时间。 TIME 该进程占用 CPU 的运算时间，注意不是系统时间。 COMMAND 产生此进程的命令名。]]></content>
      <categories>
        <category>Linux</category>
        <category>command</category>
        <category>ps</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>command</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux netstat command]]></title>
    <url>%2FLinux%2Fcommand%2Fnetstat%2Fck9bgz83b00dhqov7b3peb6vu.html</url>
    <content type="text"><![CDATA[简介在Internet RFC标准中， Netstat是在内核中访问网络连接状态及其相关信息的程序，它能提供TCP连接，TCP和UDP监听，进程内存管理的相关报告。 Netstat 是控制台命令，是一个监控TCP/IP网络的非常有用的工具，它可以显示路由表、实际的网络连接以及每一个网络接口设备的状态信息。 Netstat 用于显示与IP、TCP、UDP和ICMP协议相关的统计数据，一般用于检验本机各端口的网络连接情况。 作用netstat 命令用于显示各种网络相关信息，如网络连接，路由表，接口状态 (Interface Statistics)，masquerade 连接，多播成员 (Multicast Memberships) 等等。 用法一般用netstat -an 来显示所有连接的端口并用数字表示。若使用时不带参数，netstat显示活动的 TCP 连接。 1234567891011121314[root@hadoop-centos-01 ~]# netstat | moreActive Internet connections (w/o servers)Proto Recv-Q Send-Q Local Address Foreign Address Statetcp 0 48 hadoop-centos-01:ssh 192.168.xxx.x:49299 ESTABLISHEDtcp 0 0 hadoop-centos-01:ssh 192.168.xxx.x:49304 ESTABLISHEDActive UNIX domain sockets (w/o servers)Proto RefCnt Flags Type State I-Node Pathunix 3 [ ] DGRAM 9134 /run/systemd/notifyunix 2 [ ] DGRAM 9136 /run/systemd/cgroups-agentunix 2 [ ] DGRAM 277787unix 3 [ ] STREAM CONNECTED 48707unix 3 [ ] STREAM CONNECTED 48794 /run/systemd/journal/stdoutunix 3 [ ] STREAM CONNECTED 36513 /run/systemd/journal/stdoutunix 3 [ ] STREAM CONNECTED 48948 @/tmp/dbus-iOMFhoTUUK 输出结果可分为两个部分： Active Internet connections（有源TCP连接） Proto ：显示连接使用的协议 Recv-Q ： 接收队列 Send-Q ： 发送队列 Local Address Foreign Address State 注： “Recv-Q”和”Send-Q”一般都应该是0。如果不是则表示软件包正在队列中堆积，这种情况非常少见。 Active UNIX domain sockets （有源Unix域套接口） Proto ：显示连接使用的协议 RefCnt ：表示连接到本套接口上的进程数量 Flags Type： 显示套接口的类型 State ：显示套接口当前的状态 I-Node Path ：表示连接到套接口的其它进程使用的路径名 语法格式 1234netstat [-vWeenNcCF] [&lt;Af&gt;] -r netstat &#123;-V|--version|-h|--help&#125; netstat [-vWnNcaeol] [&lt;Socket&gt; ...] netstat &#123; [-vWeenNac] -I[&lt;Iface&gt;] | [-veenNac] -i | [-cnNe] -M | -s [-6tuw] &#125; [delay] 参数选项 123456789101112131415161718192021222324-a或--all：显示所有连线中的Socket； -A&lt;网络类型&gt;或--&lt;网络类型&gt;：列出该网络类型连线中的相关地址； -c或--continuous：持续列出网络状态； -C或--cache：显示路由器配置的快取信息； -e或--extend：显示网络其他相关信息； -F或--fib：显示FIB； -g或--groups：显示多重广播功能群组组员名单； -h或--help：在线帮助； -i或--interfaces：显示网络界面信息表单； -l或--listening：显示监控中的服务器的Socket； -M或--masquerade：显示伪装的网络连线； -n或--numeric：直接使用ip地址，而不通过域名服务器； -N或--netlink或--symbolic：显示网络硬件外围设备的符号连接名称； -o或--timers：显示计时器； -p或--programs：显示正在使用Socket的程序识别码和程序名称； -r或--route：显示Routing Table； -s或--statistice：显示网络工作信息统计表； -t或--tcp：显示TCP传输协议的连线状况； -u或--udp：显示UDP传输协议的连线状况； -v或--verbose：显示指令执行过程； -V或--version：显示版本信息； -w或--raw：显示RAW传输协议的连线状况； -x或--unix：此参数的效果和指定&quot;-A unix&quot;参数相同； --ip或--inet：此参数的效果和指定&quot;-A inet&quot;参数相同。 参数示例 列出所有端口情况 123[root@hadoop-centos-01 ~]# netstat -a # 列出所有端口[root@hadoop-centos-01 ~]# netstat -au # 列出所有UDP端口[root@hadoop-centos-01 ~]# netstat -at # 列出所有TCP端口 列出所有处于监听状态的 Sockets 1234[root@hadoop-centos-01 ~]# netstat -l # 只显示监听端口[root@hadoop-centos-01 ~]# netstat -lt # 显示监听TCP端口[root@hadoop-centos-01 ~]# netstat -lu # 显示监听UDP端口[root@hadoop-centos-01 ~]# netstat -lx # 显示监听UNIX端口 显示每个协议的统计信息 123[root@hadoop-centos-01 ~]# netstat -s # 显示所有端口的统计信息[root@hadoop-centos-01 ~]# netstat -st # 显示所有TCP的统计信息[root@hadoop-centos-01 ~]# netstat -su # 显示所有UDP的统计信息 显示 PID 和进程名称 123456789101112[root@hadoop-centos-01 ~]# netstat -p | moreActive Internet connections (w/o servers)Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program nametcp 0 0 hadoop-centos-01:ssh 192.168.244.6:49299 ESTABLISHED 28069/sshd: root@pttcp 0 0 hadoop-centos-01:ssh 192.168.244.6:49304 ESTABLISHED 28073/sshd: root@noActive UNIX domain sockets (w/o servers)Proto RefCnt Flags Type State I-Node PID/Program name Pathunix 3 [ ] DGRAM 9134 1/systemd /run/systemd/notifyunix 3 [ ] STREAM CONNECTED 48948 7427/dbus-daemon @/tmp/dbus-iOMFhoTUUKunix 3 [ ] STREAM CONNECTED 48796 7568/gsd-powerunix 3 [ ] STREAM CONNECTED 48947 7571/gsd-rfkillunix 3 [ ] STREAM CONNECTED 37682 6618/abrt-watch-log 显示核心路由信息 123456789101112131415[root@hadoop-centos-01 ~]# netstat -rKernel IP routing tableDestination Gateway Genmask Flags MSS Window irtt Ifacedefault gateway 0.0.0.0 UG 0 0 0 ens33link-local 0.0.0.0 255.255.0.0 U 0 0 0 ens33192.168.122.0 0.0.0.0 255.255.255.0 U 0 0 0 virbr0192.168.244.0 0.0.0.0 255.255.255.0 U 0 0 0 ens33[root@hadoop-centos-01 ~]# netstat -rnKernel IP routing tableDestination Gateway Genmask Flags MSS Window irtt Iface0.0.0.0 192.168.244.2 0.0.0.0 UG 0 0 0 ens33169.254.0.0 0.0.0.0 255.255.0.0 U 0 0 0 ens33192.168.122.0 0.0.0.0 255.255.255.0 U 0 0 0 virbr0192.168.244.0 0.0.0.0 255.255.255.0 U 0 0 0 ens33 查看端口和服务 123456789101112131415[root@hadoop-centos-01 ~]# netstat -anp | grep sshtcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN 7039/sshdtcp 0 0 127.0.0.1:6010 0.0.0.0:* LISTEN 28069/sshd: root@pttcp 0 0 192.168.244.11:22 192.168.244.6:49299 ESTABLISHED 28069/sshd: root@pttcp 0 0 192.168.244.11:22 192.168.244.6:49304 ESTABLISHED 28073/sshd: root@notcp6 0 0 :::22 :::* LISTEN 7039/sshdtcp6 0 0 ::1:6010 :::* LISTEN 28069/sshd: root@ptunix 3 [ ] STREAM CONNECTED 42737 7039/sshdunix 2 [ ] DGRAM 278152 28069/sshd: root@ptunix 2 [ ] DGRAM 278281 28073/sshd: root@no[root@hadoop-centos-01 ~]# netstat -anp | grep 7039tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN 7039/sshdtcp6 0 0 :::22 :::* LISTEN 7039/sshdunix 3 [ ] STREAM CONNECTED 42737 7039/sshd]]></content>
      <categories>
        <category>Linux</category>
        <category>command</category>
        <category>netstat</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>command</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python glob module]]></title>
    <url>%2Fpython%2Fmodule%2Fck9bgz7zh009vqov7l8e0bqdz.html</url>
    <content type="text"><![CDATA[简介glob —查找符合特定规则的文件路径名 Source code: Lib/glob.py 匹配符： * 匹配0个或多个字符 ? 匹配单个字符 [] 匹配指定范围内的字符，如：[0-9]匹配数字 属性python2.7123&gt;&gt;&gt; import glob&gt;&gt;&gt; dir(glob)[&apos;__all__&apos;, &apos;__builtins__&apos;, &apos;__doc__&apos;, &apos;__file__&apos;, &apos;__name__&apos;, &apos;__package__&apos;, &apos;_unicode&apos;, &apos;fnmatch&apos;, &apos;glob&apos;, &apos;glob0&apos;, &apos;glob1&apos;, &apos;has_magic&apos;, &apos;iglob&apos;, &apos;magic_check&apos;, &apos;os&apos;, &apos;re&apos;, &apos;sys&apos;] python3.7123&gt;&gt;&gt; import glob &gt;&gt;&gt; dir(glob) [&apos;__all__&apos;, &apos;__builtins__&apos;, &apos;__cached__&apos;, &apos;__doc__&apos;, &apos;__file__&apos;, &apos;__loader__&apos;, &apos;__name__&apos;, &apos;__package__&apos;, &apos;__spec__&apos;, &apos;_glob0&apos;, &apos;_glob1&apos;, &apos;_glob2&apos;, &apos;_iglob&apos;, &apos;_ishidden&apos;, &apos;_isrecursive&apos;, &apos;_iterdir&apos;, &apos;_rlistdir&apos;, &apos;escape&apos;, &apos;fnmatch&apos;, &apos;glob&apos;, &apos;glob0&apos;, &apos;glob1&apos;, &apos;has_magic&apos;, &apos;iglob&apos;, &apos;magic_check&apos;, &apos;magic_check_bytes&apos;, &apos;os&apos;, &apos;re&apos;] 用法1234567目录结构：D:\Practice： 1.gif 2.txt card.gif sub 3.txt python2.7glob.glob(pathname)根据路径名匹配模式，返回一个路径名列表，可能为空。 路径名应是包含路径规范的字符串，可以是相对路径，亦可是绝对路径，返回形式取决于匹配模式。 1234567891011121314151617&gt;&gt;&gt; import os&gt;&gt;&gt; import glob&gt;&gt;&gt; os.getcwd()&apos;D:\\Practice&apos;# 相对路径&gt;&gt;&gt; glob.glob(&apos;*.txt&apos;)[&apos;2.txt&apos;]&gt;&gt;&gt; glob.glob(&apos;[0-9].*&apos;)[&apos;1.gif&apos;, &apos;2.txt&apos;]# 绝对路径&gt;&gt;&gt; glob.glob(os.getcwd() + os.sep +&apos;*.txt&apos;)[&apos;D:\\Practice\\2.txt&apos;]&gt;&gt;&gt; glob.glob(os.getcwd() + os.sep +&apos;[0-9].*&apos;)[&apos;D:\\Practice\\1.gif&apos;, &apos;D:\\Practice\\2.txt&apos;] glob.iglob(pathname)根据路径名匹配模式，返回一个路径名列表的迭代器 python3.7glob.glob(pathname, *, recursive=False)根据路径名匹配模式，返回一个路径名列表，可能为空。 路径名应是包含路径规范的字符串，可以是相对路径，亦可是绝对路径，返回形式取决于匹配模式。 recursive为真，则模式“**”将匹配任何文件以及零个或多个目录和子目录。如果模式后面跟着一个os.sep，只有目录和子目录匹配。 123456789101112131415161718192021222324252627282930&gt;&gt;&gt; import os&gt;&gt;&gt; import glob&gt;&gt;&gt; os.getcwd()&apos;D:\\Practice&apos;&gt;&gt;&gt; os.listdir()[&apos;1.gif&apos;, &apos;2.txt&apos;, &apos;card.gif&apos;, &apos;sub&apos;]# 相对路径&gt;&gt;&gt; glob.glob(&apos;*.txt&apos;, recursive=False)[&apos;2.txt&apos;]&gt;&gt;&gt; glob.glob(&apos;[0-9].*&apos;， recursive=False)[&apos;1.gif&apos;, &apos;2.txt&apos;]# 绝对路径&gt;&gt;&gt; glob.glob(os.getcwd() + os.sep +&apos;*.txt&apos;, recursive=False)[&apos;D:\\Practice\\2.txt&apos;]&gt;&gt;&gt; glob.glob(os.getcwd() + os.sep +&apos;[0-9].*&apos;, recursive=False)[&apos;D:\\Practice\\1.gif&apos;, &apos;D:\\Practice\\2.txt&apos;]# 若recursive=True，需配合&quot;**&quot;使用&gt;&gt;&gt; glob.glob(&apos;**&apos; + os.sep + &apos;*.txt&apos;, recursive=True)[&apos;2.txt&apos;, &apos;sub\\3.txt&apos;]&gt;&gt;&gt; glob.glob(&apos;**&apos; + os.sep, recursive=True)[&apos;sub\\&apos;]&gt;&gt;&gt; glob.glob(&apos;.&apos; + os.sep + &apos;**&apos; + os.sep, recursive=True)[&apos;.\\&apos;, &apos;.\\sub\\&apos;]注： 在一个较大的目录树中使用 &quot;**&quot; 模式可能会消耗非常多的时间。 glob.iglob(pathname, *, recursive=False)根据路径名匹配模式，返回一个路径名列表的迭代器 escape(pathname)转义所有特殊字符。]]></content>
      <categories>
        <category>python</category>
        <category>module</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>module</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python 查找最大或最小的 N 个元素]]></title>
    <url>%2Fpython%2Ftips%2Fck9bgz85r00fqqov7ksihy4xd.html</url>
    <content type="text"><![CDATA[查找最大或最小的 N 个元素 问题 获得一个列表(列表元素很多)中最大或者最小的 N 个元素列表？ 实现 当要查找的元素个数 N 相对比较小的时候 1234567891011&gt;&gt;&gt; import heapq&gt;&gt;&gt; nums = [1, 8, 2, 23, 7, -4, 18, 23, 42, 37, 2]# 取最大的 3 个数&gt;&gt;&gt; heapq.nlargest(3, nums)[42, 37, 23]# 取最小的 3 个数&gt;&gt;&gt; heapq.nsmallest(3, nums)[-4, 1, 2] 当要查找的元素个数 N 接近要查找的可迭代对象的长度时，出于性能考虑，可用切片替代 123456789&gt;&gt;&gt; nums = [1, 8, 2, 23, 7, -4, 18, 23, 42, 37, 2]# 取最大的 3 个数&gt;&gt;&gt; sorted(nums, reverse=True)[:3][42, 37, 23]# 取最小的 3 个数&gt;&gt;&gt; sorted(nums)[:3][-4, 1, 2] 当取一个最大值或最小值，通过 max 和min函数获得 123456789&gt;&gt;&gt; nums = [1, 8, 2, 23, 7, -4, 18, 23, 42, 37, 2]# 取最大数&gt;&gt;&gt; max(nums)42# 取最小数&gt;&gt;&gt; min(nums)-4 测试示例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&gt;&gt;&gt; import heapq&gt;&gt;&gt; import timeit&gt;&gt;&gt; import random&gt;&gt;&gt; nums = random.choices(range(50000), k=20000) &gt;&gt;&gt; len(nums)20000# ---------------------------------------------------------------------------------# 从nums中取10个最小的数# 通过 sorted(nums)[:10] 方式&gt;&gt;&gt; timeit.repeat(&apos;sorted(nums)[:10]&apos;, &apos;import heapq;from __main__ import nums&apos;, number=1000, repeat=3)[5.283976222000092, 5.281303266000577, 5.272159137000017] # 执行1000遍，重复3次用时列表# 通过heapq.nsmallest(10, nums) 方式&gt;&gt;&gt; timeit.repeat(&apos;heapq.nsmallest(10, nums)&apos;, &apos;import heapq;from __main__ import nums&apos;, number=1000, repeat=3)[1.1154322049997063, 1.065238846000284, 1.0126771430004737] # 执行1000遍，重复3次用时列表# ---------------------------------------------------------------------------------# 从nums中取10个最大的数# 通过 sorted(nums)[:10] 方式&gt;&gt;&gt; timeit.repeat(&apos;sorted(nums, reverse=True)[:10]&apos;, &apos;import heapq;from __main__ import nums&apos;, number=1000, repeat=3)[5.402307174000271, 5.62465228200017, 5.546984251999675]# 通过 heapq.nlargest(10, nums) 方式&gt;&gt;&gt; timeit.repeat(&apos;heapq.nlargest(10, nums)&apos;, &apos;import heapq;from __main__ import nums&apos;, number=1000, repeat=3) [1.0458967599997777, 1.060633938999672, 1.0392043130004822] # 执行1000遍，重复3次用时列表# ---------------------------------------------------------------------------------# 从nums中取10000个最小的数# 通过 sorted(nums)[:10000] 方式&gt;&gt;&gt; timeit.repeat(&apos;sorted(nums)[:10000]&apos;, &apos;import heapq;from __main__ import nums&apos;, number=1000, repeat=3)[5.616329210999538, 5.384628143000555, 5.36661329799972] # 执行1000遍，重复3次用时列表# 通过heapq.nsmallest(10000, nums) 方式&gt;&gt;&gt; timeit.repeat(&apos;heapq.nsmallest(10000, nums)&apos;, &apos;import heapq;from __main__ import nums&apos;, number=1000, repeat=3)[30.37623528200038, 30.471836461999374, 30.748560685000484] # 执行1000遍，重复3次用时列表# ---------------------------------------------------------------------------------# 从nums中取10000个最大的数# 通过 sorted(nums， reverse=True)[:10000] 方式&gt;&gt;&gt; timeit.repeat(&apos;sorted(nums, reverse=True)[:10000]&apos;, &apos;import heapq;from __main__ import nums&apos;, number=1000, repeat=3)[5.462146738999763, 5.569061694000084, 5.482768033999491] # 执行1000遍，重复3次用时列表# 通过 heapq.nlargest(10000, nums) 方式&gt;&gt;&gt; timeit.repeat(&apos;heapq.nlargest(10000, nums)&apos;, &apos;import heapq;from __main__ import nums&apos;, number=1000, repeat=3)[33.05006609500015, 30.762279339999623, 33.79276524299985] # 执行1000遍，重复3次用时列表]]></content>
      <categories>
        <category>python</category>
        <category>tips</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python 保留最后N个元素]]></title>
    <url>%2Fpython%2Ftips%2Fck9bgz84x00ezqov7l0brqt5c.html</url>
    <content type="text"><![CDATA[保留最后 N 个元素 问题 在迭代操作或者其他操作的时候，怎样只保留最后有限几个元素的历史记录？ 实现 保留有限历史记录可通过 collections.deque 实现。例如下面的代码在多行上面做简单的文本匹配， 并返回匹配所在行的最后N行： 1234567891011121314151617from collections import dequedef search(lines, pattern, history=5): previous_lines = deque(maxlen=history) for line in lines: if pattern in line: yield line, previous_lines previous_lines.append(line) # Example use on a fileif __name__ == &apos;__main__&apos;: with open(r&apos;../../cookbook/somefile.txt&apos;) as f: for line, prevlines in search(f, &apos;python&apos;, 5): for pline in prevlines: print(pline, end=&apos;&apos;) print(line, end=&apos;&apos;) print(&apos;-&apos; * 20) deque 用法简述 1234567891011121314151617181920212223from collections import deque语法: deque([iterable[, maxlen]]) --&gt; deque object iterable：init iterable maxlen： maximum size of a deque or None if unbounded 方法: append(...) Add an element to the right side of the deque. appendleft(...) Add an element to the left side of the deque. clear(...) Remove all elements from the deque. copy(...) Return a shallow copy of a deque. count(...) D.count(value) -&gt; integer -- return number of occurrences of value extend(...) Extend the right side of the deque with elements from the iterable extendleft(...) Extend the left side of the deque with elements from the iterable index(...) D.index(value, [start, [stop]]) -&gt; integer -- return first index of value. Raises ValueError if the value is not present. insert(...) D.insert(index, object) -- insert object before index pop(...) Remove and return the rightmost element. popleft(...) Remove and return the leftmost element. remove(...) D.remove(value) -- remove first occurrence of value. reverse(...) D.reverse() -- reverse *IN PLACE* rotate(...) Rotate the deque n steps to the right (default n=1). If n is negative Reference&emsp;&emsp;https://python3-cookbook.readthedocs.io/zh_CN/latest/c01/p03_keep_last_n_items.html]]></content>
      <categories>
        <category>python</category>
        <category>tips</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python timeit module]]></title>
    <url>%2Fpython%2Fmodule%2Fck9bgz80600ajqov7fg19he4z.html</url>
    <content type="text"><![CDATA[简介用于计算一小段 Python 代码耗时的模块。 源码： Lib/timeit.py 用法包含方法 1234&gt;&gt;&gt; import timeit&gt;&gt;&gt; timeit.__all__[&apos;Timer&apos;, &apos;timeit&apos;, &apos;repeat&apos;, &apos;default_timer&apos;] timeit.Timer(…)class timeit.Timer(stmt=’pass’, setup=’pass’, timer=&lt;timer function&gt;, globals=None) stmt：用于传入要测试时间的代码块，可以直接接受字符串的表达式，也可以接受单个变量或函数。传入函数时要把函数申明在当前文件中，然后在 stmt = ‘func()’ 执行函数，然后使用 setup = ‘from __main__ import func’ setup：传入stmt的运行环境，比如stmt中使用到的参数、变量，要导入的模块等。可以写一行语句，也可以写多行语句，写多行语句时要用分号;隔开语句。 timer：一个定时器函数，与平台有关。 globals： 参数指定用于执行代码的命名空间。 123456789101112&gt;&gt;&gt; import timeit# test function&gt;&gt;&gt; def f(x): max(x) &gt;&gt;&gt; nums = [1, 8, 2, 23, 7, -4, 18, 23, 42, 37, 2]# create timer object&gt;&gt;&gt; timer = timeit.Timer(stmt=&apos;f(nums)&apos;, setup=&apos;from __main__ import f, nums&apos;)&gt;&gt;&gt; [_ for _ in dir(timer) if not _.startswith(&apos;_&apos;)][&apos;autorange&apos;, &apos;inner&apos;, &apos;print_exc&apos;, &apos;repeat&apos;, &apos;src&apos;, &apos;timeit&apos;, &apos;timer&apos;] timeit.timeit(…)timeit.timeit(stmt=’pass’, setup=’pass’, timer=&lt;default timer&gt;, number=1000000, globals=None) 其余参数说明见 timeit.Timer number：要测试的代码的运行次数，默认100000次，对于耗时的代码，运行太多次会比较慢，此时建议自己修改一下运行次数 12&gt;&gt;&gt; timer.timeit(number=100)0.00013752799986832542 timeit.repeat(…)timeit.repeat(stmt=’pass’, setup=’pass’, timer=&lt;default timer&gt;, repeat=5, number=1000000, globals=None) 其余参数说明见 timeit.Timer repeat：指测试要重复几次，每次的结果构成列表返回，默认5次。 number：要测试的代码的运行次数，默认100000次。 12&gt;&gt;&gt; timer.repeat(number=100)[0.0002869599998120975, 0.00013793800007988466, 0.00012151600003562635, 0.00021511800014195614, 0.00019376999989617616] timeit.default_timer(…)默认的计时器，总是 time.perf_counter() 12&gt;&gt;&gt; timeit.default_timer()2506.128862259]]></content>
      <categories>
        <category>python</category>
        <category>module</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>module</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python 解压序列赋值给多个变量]]></title>
    <url>%2Fpython%2Ftips%2Fck9bgz85l00fkqov73dx4fvke.html</url>
    <content type="text"><![CDATA[问题现在有一个包含 N 个元素的元组或者是序列，怎样将它里面的值解压后同时赋值给 N 个变量？ 实现 123456789101112131415161718# test_seq is sequence or iterable objects # 通过等长个数的变量赋值, 即变量个数等于 len(test_seq)var1, var2, var3, ... = test_seq # 取 test 首尾head, *_, tail = test_seq # 取 test_seq 指定个数的前3个数var1, var2, var3, *_ = test_seq # 取 test_seq 指定个数的后3个数*_, var1, var2, var3 = test_seq 注： 1. 任何的序列（或者是可迭代对象）可以通过一个简单的赋值语句解压并赋值给多个变量。 2. 变量的数量必须跟序列元素的数量是一样的。 3. *_ 会将剩余数据储存于一个列表中]]></content>
      <categories>
        <category>python</category>
        <category>tips</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git推送本地分支到远端]]></title>
    <url>%2Fgit%2Fck9bgz7mc003qqov7n0q0divx.html</url>
    <content type="text"><![CDATA[1234567git push origin :DstBranchgit push origin localBranch:DstBranchgit branch --set-upstream-to=origin/DstBranch localBranch# 清空远端分支# 以本地分支为基础推送并创建远端分支# 关联本地分支与远端分支]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python datetime module]]></title>
    <url>%2Fpython%2Fmodule%2Fck9bgz88000gxqov7qixzwql2.html</url>
    <content type="text"><![CDATA[Introductiondatetime Basic date and time types Source code: Lib/datetime.py The datetime module supplies classes for manipulating dates and times in both simple and complex ways. While date and time arithmetic is supported, the focus of the implementation is on efficient attribute extraction for output formatting and manipulation. For related functionality, see also the time and calendar modules. datetime include constants and available types 123&gt;&gt;&gt; import datetime&gt;&gt;&gt; dir(datetime)[&apos;MAXYEAR&apos;, &apos;MINYEAR&apos;, &apos;__builtins__&apos;, &apos;__cached__&apos;, &apos;__doc__&apos;, &apos;__file__&apos;, &apos;__loader__&apos;, &apos;__name__&apos;, &apos;__package__&apos;, &apos;__spec__&apos;, &apos;date&apos;, &apos;datetime&apos;, &apos;datetime_CAPI&apos;, &apos;sys&apos;, &apos;time&apos;, &apos;timedelta&apos;, &apos;timezone&apos;, &apos;tzinfo&apos;] The datetime module constantsdatetime.MINYEARThe smallest year number allowed in a date or datetime object. MINYEAR is 1. datatime.MAXYEARThe largest year number allowed in a date or datetime object. MAXYEAR is 9999. The datetime module available typesclass datetime.timedeltaA duration expressing the difference between two date, time, or datetime instances to microsecond resolution. class datetime.dateAn idealized naive date, assuming the current Gregorian calendar always was, and always will be, in effect. Attributes: year, month, and day. class datetime.timeAn idealized time, independent of any particular day, assuming that every day has exactly 246060 seconds (there is no notion of “leap seconds” here). Attributes: hour, minute, second, microsecond, and tzinfo. class datetime.datetimeA combination of a date and a time. Attributes: year, month, day, hour, minute, second, microsecond, and tzinfo. class datetime.tzinfoAn abstract base class for time zone information objects. These are used by the datetime and time classes to provide a customizable notion of time adjustment (for example, to account for time zone and/or daylight saving time). class datetime.timezoneA class that implements the tzinfo abstract base class as a fixed offset from the UTC. timedelta ObjectsA timedelta object represents a duration, the difference between two dates or times. 1class datetime.timedelta(days=0, seconds=0, microseconds=0, milliseconds=0, minutes=0, hours=0, weeks=0) All arguments are optional and default to 0. Arguments may be integers or floats, and may be positive or negative. Only days, seconds and microseconds are stored internally. Arguments are converted to those units: A millisecond is converted to 1000 microseconds. A minute is converted to 60 seconds. An hour is converted to 3600 seconds. A week is converted to 7 days. days, seconds and microseconds are then normalized so that the representation is unique, with 0 &lt;= microseconds &lt; 1000000 0 &lt;= seconds &lt; 3600*24 (the number of seconds in one day) -999999999 &lt;= days &lt;= 999999999 1234&gt;&gt;&gt; from datetime import timedelta &gt;&gt;&gt; dir(timedelta)[&apos;__abs__&apos;, &apos;__add__&apos;, &apos;__bool__&apos;, &apos;__class__&apos;, &apos;__delattr__&apos;, &apos;__dir__&apos;, &apos;__divmod__&apos;, &apos;__doc__&apos;, &apos;__eq__&apos;, &apos;__floordiv__&apos;, &apos;__format__&apos;, &apos;__ge__&apos;, &apos;__getattribute__&apos;, &apos;__gt__&apos;, &apos;__hash__&apos;, &apos;__init__&apos;, &apos;__init_subclass__&apos;, &apos;__le__&apos;, &apos;__lt__&apos;, &apos;__mod__&apos;, &apos;__mul__&apos;, &apos;__ne__&apos;, &apos;__neg__&apos;, &apos;__new__&apos;, &apos;__pos__&apos;, &apos;__radd__&apos;, &apos;__rdivmod__&apos;, &apos;__reduce__&apos;, &apos;__reduce_ex__&apos;, &apos;__repr__&apos;, &apos;__rfloordiv__&apos;, &apos;__rmod__&apos;, &apos;__rmul__&apos;, &apos;__rsub__&apos;, &apos;__rtruediv__&apos;, &apos;__setattr__&apos;, &apos;__sizeof__&apos;, &apos;__str__&apos;, &apos;__sub__&apos;, &apos;__subclasshook__&apos;, &apos;__truediv__&apos;, &apos;days&apos;, &apos;max&apos;, &apos;microseconds&apos;, &apos;min&apos;, &apos;resolution&apos;, &apos;seconds&apos;, &apos;total_seconds&apos;] Class attributestimedelta.minThe most negative timedelta object, timedelta(-999999999). 12&gt;&gt;&gt; timedelta.min datetime.timedelta(days=-999999999) timedelta.maxThe most positive timedelta object, timedelta(days=999999999, hours=23, minutes=59, seconds=59, microseconds=999999). 12&gt;&gt;&gt; timedelta.max datetime.timedelta(days=999999999, seconds=86399, microseconds=999999) timedelta.resolutionThe smallest possible difference between non-equal timedelta objects, timedelta(microseconds=1). 12&gt;&gt;&gt; timedelta.resolution datetime.timedelta(microseconds=1) Instance attributes (read-only)timedelta.daystimedelta.secondstimedelta.microseconds Attribute Value days Between -999999999 and 999999999 inclusive seconds Between 0 and 86399 inclusive microseconds Between 0 and 999999 inclusive 1234&gt;&gt;&gt; from datetime import timedelta&gt;&gt;&gt; d = timedelta(days=1,seconds=1,microseconds=1) &gt;&gt;&gt; (d.days, d.seconds, d.microseconds)(1, 1, 1) Instance methodstimedelta.total_seconds()Return the total number of seconds contained in the duration. Equivalent to td / timedelta(seconds=1). For interval units other than seconds, use the division form directly (e.g. td / timedelta(microseconds=1)). Note that for very large time intervals (greater than 270 years on most platforms) this method will lose microsecond accuracy. Example usage: 1234567891011121314151617181920&gt;&gt;&gt; from datetime import timedelta&gt;&gt;&gt; year = timedelta(days=365)&gt;&gt;&gt; another_year = timedelta(weeks=40, days=84, hours=23, minutes=50, seconds=600)&gt;&gt;&gt; year.total_seconds()31536000.0&gt;&gt;&gt; year == another_yearTrue&gt;&gt;&gt; ten_years = 10 * year&gt;&gt;&gt; ten_yearsdatetime.timedelta(3650)&gt;&gt;&gt; ten_years, ten_years.days // 365(datetime.timedelta(3650), 10)&gt;&gt;&gt; nine_years = ten_years - year&gt;&gt;&gt; nine_years, nine_years.days // 365(datetime.timedelta(3285), 9)&gt;&gt;&gt; three_years = nine_years // 3&gt;&gt;&gt; three_years, three_years.days // 365(datetime.timedelta(1095), 3)&gt;&gt;&gt; abs(three_years - ten_years) == 2 * three_years + yearTrue Supported operations123456789101112131415161718192021222324252627282930&gt;&gt;&gt; from datetime import timedelta&gt;&gt;&gt; t1 = timedelta(days=1,seconds=1,microseconds=1) &gt;&gt;&gt; t2 = timedelta(days=2,seconds=2,microseconds=2) &gt;&gt;&gt; t1 + t2 datetime.timedelta(days=3, seconds=3, microseconds=3)&gt;&gt;&gt; t2 - t1 datetime.timedelta(days=1, seconds=1, microseconds=1)&gt;&gt;&gt; t1 - t2 datetime.timedelta(days=-2, seconds=86398, microseconds=999999)&gt;&gt;&gt; 6 * t1 datetime.timedelta(days=6, seconds=6, microseconds=6)&gt;&gt;&gt; 6.6 * t1 datetime.timedelta(days=6, seconds=51846, microseconds=600007)&gt;&gt;&gt; abs(t1) datetime.timedelta(days=1, seconds=1, microseconds=1)&gt;&gt;&gt; abs(t1 - t2)datetime.timedelta(days=1, seconds=1, microseconds=1)# equivalent to +t when t.days &gt;= 0, and to -t when t.days &lt; 0. (2)&gt;&gt;&gt; str(t1) &apos;1 day, 0:00:01.000001&apos;# Returns a string in the form [D day[s], ][H]H:MM:SS[.UUUUUU], where D is negative for negative t. (5)&gt;&gt;&gt; repr(t1) &apos;datetime.timedelta(days=1, seconds=1, microseconds=1)&apos;# Returns a string representation of the timedelta object as a constructor call with canonical attribute values. In addition to the operations listed above timedelta objects support certain additions and subtractions with date and datetime objects . date ObjectsA date object represents a date (year, month and day) in an idealized calendar, the current Gregorian calendar indefinitely extended in both directions. January 1 of year 1 is called day number 1, January 2 of year 1 is called day number 2, and so on. 1class datetime.date(year, month, day) All arguments are required. Arguments may be integers, in the following ranges: MINYEAR &lt;= year &lt;= MAXYEAR 1 &lt;= month &lt;= 12 1 &lt;= day &lt;= number of days in the given month and year If an argument outside those ranges is given, ValueError is raised. 1234&gt;&gt;&gt; from datetime import date&gt;&gt;&gt; dir(date)[&apos;__add__&apos;, &apos;__class__&apos;, &apos;__delattr__&apos;, &apos;__dir__&apos;, &apos;__doc__&apos;, &apos;__eq__&apos;, &apos;__format__&apos;, &apos;__ge__&apos;, &apos;__getattribute__&apos;, &apos;__gt__&apos;, &apos;__hash__&apos;, &apos;__init__&apos;, &apos;__init_subclass__&apos;, &apos;__le__&apos;, &apos;__lt__&apos;, &apos;__ne__&apos;, &apos;__new__&apos;, &apos;__radd__&apos;, &apos;__reduce__&apos;, &apos;__reduce_ex__&apos;, &apos;__repr__&apos;, &apos;__rsub__&apos;, &apos;__setattr__&apos;, &apos;__sizeof__&apos;, &apos;__str__&apos;, &apos;__sub__&apos;, &apos;__subclasshook__&apos;, &apos;ctime&apos;, &apos;day&apos;, &apos;fromisoformat&apos;, &apos;fromordinal&apos;, &apos;fromtimestamp&apos;, &apos;isocalendar&apos;, &apos;isoformat&apos;, &apos;isoweekday&apos;, &apos;max&apos;, &apos;min&apos;, &apos;month&apos;, &apos;replace&apos;, &apos;resolution&apos;, &apos;strftime&apos;, &apos;timetuple&apos;, &apos;today&apos;, &apos;toordinal&apos;, &apos;weekday&apos;, &apos;year&apos;] Class attributesdate.minThe earliest representable date, date(MINYEAR, 1, 1). 1234&gt;&gt;&gt; from datetime import date&gt;&gt;&gt; date.min datetime.date(1, 1, 1) date.maxThe latest representable date, date(MAXYEAR, 12, 31). 1234&gt;&gt;&gt; from datetime import date&gt;&gt;&gt; date.maxdatetime.date(9999, 12, 31) date.resolutionThe smallest possible difference between non-equal date objects, timedelta(days=1). 1234&gt;&gt;&gt; from datetime import date&gt;&gt;&gt; date.resolutiondatetime.timedelta(days=1) Instance attributes (read-only)date.yearBetween MINYEAR and MAXYEAR inclusive. date.monthBetween 1 and 12 inclusive. date.dayBetween 1 and the number of days in the given month of the given year. Class methodsdate.today()Return the current local date. This is equivalent to date.fromtimestamp(time.time()). 123&gt;&gt;&gt; from datetime import date&gt;&gt;&gt; date.today() datetime.date(2019, 8, 3) date.fromtimestamp(timestamp)Return the local date corresponding to the POSIX timestamp, such as is returned by time.time(). 12345&gt;&gt;&gt; import time&gt;&gt;&gt; from datetime import date &gt;&gt;&gt; date.fromtimestamp(time.time()) datetime.date(2019, 8, 3) date.fromordinal(ordinal)Return the date corresponding to the proleptic Gregorian ordinal, where January 1 of year 1 has ordinal 1. ValueError is raised unless 1 &lt;= ordinal &lt;= date.max.toordinal(). For any date d, date.fromordinal(d.toordinal()) == d. 12345678910&gt;&gt;&gt; from datetime import date&gt;&gt;&gt; date.fromordinal(1) datetime.date(1, 1, 1)&gt;&gt;&gt; date.fromordinal(31)datetime.date(1, 1, 31)&gt;&gt;&gt; date.fromordinal(35)datetime.date(1, 2, 4) date.fromisoformat(date_string)Return a date corresponding to a date_string in the format emitted by date.isoformat(). Specifically, this function supports strings in the format(s) YYYY-MM-DD. Caution This does not support parsing arbitrary ISO 8601 strings - it is only intended as the inverse operation of date.isoformat(). 12345&gt;&gt;&gt; from datetime import date&gt;&gt;&gt; d = &quot;2018-10-10&quot;&gt;&gt;&gt; date.fromisoformat(d) datetime.date(2018, 10, 10) Instance methodsdate.replace(year=self.year, month=self.month, day=self.day)Return a date with the same value, except for those parameters given new values by whichever keyword arguments are specified. For example 12345678&gt;&gt;&gt; from datetime import date &gt;&gt;&gt; d = date(2018, 10, 10) &gt;&gt;&gt; d.replace(month=12)datetime.date(2018, 12, 10)&gt;&gt;&gt; d.replace(month=12) == date(2018, 12, 10) True date.timetuple()Return a time.struct_time such as returned by time.localtime(). The hours, minutes and seconds are 0, and the DST flag is -1. d.timetuple() is equivalent to time.struct_time((d.year, d.month, d.day, 0, 0, 0, d.weekday(), yday, -1)), where yday = d.toordinal() - date(d.year, 1, 1).toordinal() + 1 is the day number within the current year starting with 1 for January 1st. 12345&gt;&gt;&gt; from datetime import date &gt;&gt;&gt; d = date(2018, 10, 10)&gt;&gt;&gt; d.timetuple() time.struct_time(tm_year=2018, tm_mon=10, tm_mday=10, tm_hour=0, tm_min=0, tm_sec=0, tm_wday=2, tm_yday=283, tm_isdst=-1) date.toordinal()Return the proleptic Gregorian ordinal of the date, where January 1 of year 1 has ordinal 1. For any date object d, date.fromordinal(d.toordinal()) == d. 12345678&gt;&gt;&gt; from datetime import date &gt;&gt;&gt; d = date(2018, 10, 10)&gt;&gt;&gt; d.toordinal() 736977&gt;&gt;&gt; date.fromordinal(d.toordinal()) == dTrue date.weekday()Return the day of the week as an integer, where Monday is 0 and Sunday is 6. For example,date(2018, 10, 10).weekday() == 2, a Wednesday. 12345&gt;&gt;&gt; from datetime import date &gt;&gt;&gt; d = date(2018, 10, 10)&gt;&gt;&gt; d.weekday() 2 # is Wednesday date.isoweekday()Return the day of the week as an integer, where Monday is 1 and Sunday is 7. For example,date(2018, 10, 10).isoweekday() == 3, a Wednesday 12345&gt;&gt;&gt; from datetime import date&gt;&gt;&gt; d = date(2018, 10, 10)&gt;&gt;&gt; d.isoweekday()3 # is Wednesday date.isocalendar()Return a 3-tuple, (ISO year, ISO week number, ISO weekday). The ISO year consists of 52 or 53 full weeks, and where a week starts on a Monday and ends on a Sunday. The first week of an ISO year is the first (Gregorian) calendar week of a year containing a Thursday. This is called week number 1, and the ISO year of that Thursday is the same as its Gregorian year. For example, 2004 begins on a Thursday, so the first week of ISO year 2004 begins on Monday, 29 Dec 2003 and ends on Sunday, 4 Jan 2004, so that date(2003, 12, 29).isocalendar() == (2004, 1, 1) and date(2004, 1, 4).isocalendar() == (2004, 1, 7). 12345&gt;&gt;&gt; from datetime import date&gt;&gt;&gt; d = date(2004, 1, 1)&gt;&gt;&gt; d.isocalendar()(2004, 1, 4) date.isoformat()Return a string representing the date in ISO 8601 format, ‘YYYY-MM-DD’. For example 12345&gt;&gt;&gt; from datetime import date&gt;&gt;&gt; d = date(2018, 10, 10)&gt;&gt;&gt; d.isoformat() &apos;2018-10-10&apos; date.__str__()For a date d, str(d) is equivalent to d.isoformat(). 12345&gt;&gt;&gt; from datetime import date&gt;&gt;&gt; d = date(2018, 10, 10)&gt;&gt;&gt; str(d)&apos;2018-10-10&apos; date.ctime()Return a string representing the date, is equivalent to time.ctime(time.mktime(d.timetuple())) on platforms where the native C ctime() function (which time.ctime() invokes, but which date.ctime() does not invoke) conforms to the C standard. 12345&gt;&gt;&gt; from datetime import date&gt;&gt;&gt; d = date(2018, 10, 10)&gt;&gt;&gt; d.ctime() &apos;Wed Oct 10 00:00:00 2018&apos; date.strftime(format)Return a string representing the date, controlled by an explicit format string. Format codes referring to hours, minutes or seconds will see 0 values 1234567&gt;&gt;&gt; from datetime import date&gt;&gt;&gt; d = date(2018, 10, 10)&gt;&gt;&gt; d.strftime(&apos;%Y-%m-%d&apos;) &apos;2018-10-10&apos;&gt;&gt;&gt; d.strftime(&apos;%Y-%m-%d %H:%M:%S&apos;)&apos;2018-10-10 00:00:00&apos; date.__format__(format)Same as date.strftime(). This makes it possible to specify a format string for a date object in formatted string literals and when using str.format(). Supported operations1234567891011121314151617181920&gt;&gt;&gt; from datetime import date&gt;&gt;&gt; from datetime import timedelta&gt;&gt;&gt; d1 = date(2018, 10, 10) &gt;&gt;&gt; d2 = date(2019, 11, 11)&gt;&gt;&gt; day = timedelta(days=15)&gt;&gt;&gt; d2 - d1datetime.timedelta(days=397)&gt;&gt;&gt; d1 - d2 datetime.timedelta(days=-397)&gt;&gt;&gt; d1 &lt; d2True&gt;&gt;&gt; d1 + day datetime.date(2018, 10, 25)&gt;&gt;&gt; d2 - day datetime.date(2019, 10, 27) time ObjectsA time object represents a (local) time of day, independent of any particular day, and subject to adjustment via a tzinfo object. 1class datetime.time(hour=0, minute=0, second=0, microsecond=0, tzinfo=None, *, fold=0) All arguments are optional. tzinfo may be None, or an instance of a tzinfo subclass. The remaining arguments may be integers, in the following ranges: 0 &lt;= hour &lt; 24, 0 &lt;= minute &lt; 60, 0 &lt;= second &lt; 60, 0 &lt;= microsecond &lt; 1000000, fold in [0, 1]. If an argument outside those ranges is given,ValueError is raised. All default to 0 except tzinfo, which defaults to None. 1234&gt;&gt;&gt; from datetime import time&gt;&gt;&gt; dir(time)[&apos;__class__&apos;, &apos;__delattr__&apos;, &apos;__dir__&apos;, &apos;__doc__&apos;, &apos;__eq__&apos;, &apos;__format__&apos;, &apos;__ge__&apos;, &apos;__getattribute__&apos;, &apos;__gt__&apos;, &apos;__hash__&apos;, &apos;__init__&apos;, &apos;__init_subclass__&apos;, &apos;__le__&apos;, &apos;__lt__&apos;, &apos;__ne__&apos;, &apos;__new__&apos;, &apos;__reduce__&apos;, &apos;__reduce_ex__&apos;, &apos;__repr__&apos;, &apos;__setattr__&apos;, &apos;__sizeof__&apos;, &apos;__str__&apos;, &apos;__subclasshook__&apos;, &apos;dst&apos;, &apos;fold&apos;, &apos;fromisoformat&apos;, &apos;hour&apos;, &apos;isoformat&apos;, &apos;max&apos;, &apos;microsecond&apos;, &apos;min&apos;, &apos;minute&apos;, &apos;replace&apos;, &apos;resolution&apos;, &apos;second&apos;, &apos;strftime&apos;, &apos;tzinfo&apos;, &apos;tzname&apos;, &apos;utcoffset&apos;] Class attributestime.minThe earliest representable time, time(0, 0, 0, 0). 1234&gt;&gt;&gt; from datetime import time&gt;&gt;&gt; time.min datetime.time(0, 0) time.maxThe latest representable time, time(23, 59, 59, 999999). 1234&gt;&gt;&gt; from datetime import time&gt;&gt;&gt; time.max datetime.time(23, 59, 59, 999999) time.resolutionThe smallest possible difference between non-equal time objects, timedelta(microseconds=1), although note that arithmetic on time objects is not supported. 1234&gt;&gt;&gt; from datetime import time&gt;&gt;&gt; time.resolution datetime.timedelta(microseconds=1) Instance attributestime.hourIn range(24). time.minuteIn range(60). time.secondIn range(60). time.microsecondIn range(1000000). time.tzinfoThe object passed as the tzinfo argument to the time constructor, or None if none was passed. time.foleIn [0, 1]. Used to disambiguate wall times during a repeated interval. (A repeated interval occurs when clocks are rolled back at the end of daylight saving time or when the UTC offset for the current zone is decreased for political reasons.) The value 0 (1) represents the earlier (later) of the two moments with the same wall time representation. 12345&gt;&gt;&gt; from datetime import time&gt;&gt;&gt; t = time(10, 23, 56)&gt;&gt;&gt; t.hour, t.minute, t.second, t.microsecond, t.tzinfo, t.fold (10, 23, 56, 0, None, 0) Class methodstime.fromisoformat(time_sting)Return a time corresponding to a time_string in one of the formats emitted by time.isoformat(). Specifically, this function supports strings in the format(s) HH[:MM[:SS[.fff[fff]]]][+HH:MM[:SS[.ffffff]]]. Instance methodstime.replace(hour=self.hour, minute=self.minute, second=self.second, microsecond=self.microsecond, tzinfo=self.tzinfo, * fold=0)Return a time with the same value, except for those attributes given new values by whichever keyword arguments are specified. Note that tzinfo=None can be specified to create a naive time from an aware time, without conversion of the time data. New in version 3.6: Added the fold argument. time.isoformat(timespec=’auto’)Return a string representing the time in ISO 8601 format, HH:MM:SS.ffffff or, if microsecond is 0, HH:MM:SS If utcoffset() does not return None, a string is appended, giving the UTC offset: HH:MM:SS.ffffff+HH:MM[:SS[.ffffff]] or, if self.microsecond is 0, HH:MM:SS+HH:MM[:SS[.ffffff]]. The optional argument timespec specifies the number of additional components of the time to include (the default is ‘auto’). It can be one of the following: ‘auto’: Same as ‘seconds’ if microsecond is 0, same as ‘microseconds’ otherwise. ‘hours’: Include the hour in the two-digit HH format. ‘minutes’: Include hour and minute in HH:MM format. ‘seconds’: Include hour, minute, and second in HH:MM:SS format. ‘milliseconds’: Include full time, but truncate fractional second part to milliseconds. HH:MM:SS.sss format. ‘microseconds’: Include full time in HH:MM:SS.ffffff format. ValueError will be raised on an invalid timespec argument. 12345678910111213&gt;&gt;&gt; from datetime import time &gt;&gt;&gt; t = time(hour=12, minute=34, second=56, microsecond=123456) &gt;&gt;&gt; t.isoformat() &apos;12:34:56.123456&apos;&gt;&gt;&gt; t.isoformat(timespec=&apos;minutes&apos;) &apos;12:34&apos;&gt;&gt;&gt; t = time(hour=12, minute=34, second=56, microsecond=0) &gt;&gt;&gt; t.isoformat(timespec=&apos;microseconds&apos;) &apos;12:34:56.000000&apos;&gt;&gt;&gt; t.isoformat(timespec=&apos;auto&apos;) &apos;12:34:56&apos; time.str()For a time t, str(t) is equivalent to t.isoformat(). time.strftime(format)Return a string representing the time, controlled by an explicit format string. 12345&gt;&gt;&gt; from datetime import time&gt;&gt;&gt; t = time(hour=12, minute=34, second=56, microsecond=0)&gt;&gt;&gt; t.strftime(&apos;%H:%M:%S&apos;) &apos;12:34:56&apos; time.__format__(format)Same as time.strftime(). This makes it possible to specify a format string for a time object in formatted string literals and when using str.format(). time.utcoffset()If tzinfo is None, returns None, else returns self.tzinfo.utcoffset(None), and raises an exception if the latter doesn’t return None or a timedelta object with magnitude less than one day. Changed in version 3.7: The UTC offset is not restricted to a whole number of minutes. time.dst()If tzinfo is None, returns None, else returns self.tzinfo.dst(None), and raises an exception if the latter doesn’t return None, or a timedelta object with magnitude less than one day. Changed in version 3.7: The DST offset is not restricted to a whole number of minutes. time.tzname()If tzinfo is None, returns None, else returns self.tzinfo.tzname(None), or raises an exception if the latter doesn’t return None or a string object. 123456789101112131415161718192021222324&gt;&gt;&gt; from datetime import time, tzinfo, timedelta&gt;&gt;&gt; class TZ1(tzinfo):... def utcoffset(self, dt):... return timedelta(hours=1)... def dst(self, dt):... return timedelta(0)... def tzname(self,dt):... return &quot;+01:00&quot;... def __repr__(self):... return f&quot;&#123;self.__class__.__name__&#125;()&quot;...&gt;&gt;&gt; t = time(12, 10, 30, tzinfo=TZ1())&gt;&gt;&gt; tdatetime.time(12, 10, 30, tzinfo=TZ1())&gt;&gt;&gt; t.isoformat()&apos;12:10:30+01:00&apos;&gt;&gt;&gt; t.dst()datetime.timedelta(0)&gt;&gt;&gt; t.tzname()&apos;+01:00&apos;&gt;&gt;&gt; t.strftime(&quot;%H:%M:%S %Z&quot;)&apos;12:10:30 +01:00&apos;&gt;&gt;&gt; &apos;The &#123;&#125; is &#123;:%H:%M&#125;.&apos;.format(&quot;time&quot;, t)&apos;The time is 12:10.&apos; datetime ObjectsA datetime object is a single object containing all the information from a date object and a time object. Like a date object, datetime assumes the current Gregorian calendar extended in both directions; like a time object, datetime assumes there are exactly 3600*24 seconds in every day. 1class datetime.datetime(year, month, day, hour=0, minute=0, second=0, microsecond=0, tzinfo=None, *, fold=0) The year, month and day arguments are required. tzinfo may be None, or an instance of a tzinfo subclass. The remaining arguments may be integers, in the following ranges: MINYEAR &lt;= year &lt;= MAXYEAR, 1 &lt;= month &lt;= 12, 1 &lt;= day &lt;= number of days in the given month and year, 0 &lt;= hour &lt; 24, 0 &lt;= minute &lt; 60, 0 &lt;= second &lt; 60, 0 &lt;= microsecond &lt; 1000000, fold in [0, 1]. If an argument outside those ranges is given, ValueError is raised. New in version 3.6: Added the fold argument. 1234&gt;&gt;&gt; from datetime import datetime &gt;&gt;&gt; dir(datetime) [&apos;__add__&apos;, &apos;__class__&apos;, &apos;__delattr__&apos;, &apos;__dir__&apos;, &apos;__doc__&apos;, &apos;__eq__&apos;, &apos;__format__&apos;, &apos;__ge__&apos;, &apos;__getattribute__&apos;, &apos;__gt__&apos;, &apos;__hash__&apos;, &apos;__init__&apos;, &apos;__init_subclass__&apos;, &apos;__le__&apos;, &apos;__lt__&apos;, &apos;__ne__&apos;, &apos;__new__&apos;, &apos;__radd__&apos;, &apos;__reduce__&apos;, &apos;__reduce_ex__&apos;, &apos;__repr__&apos;, &apos;__rsub__&apos;, &apos;__setattr__&apos;, &apos;__sizeof__&apos;, &apos;__str__&apos;, &apos;__sub__&apos;, &apos;__subclasshook__&apos;, &apos;astimezone&apos;, &apos;combine&apos;, &apos;ctime&apos;, &apos;date&apos;, &apos;day&apos;, &apos;dst&apos;, &apos;fold&apos;, &apos;fromisoformat&apos;, &apos;fromordinal&apos;, &apos;fromtimestamp&apos;, &apos;hour&apos;, &apos;isocalendar&apos;, &apos;isoformat&apos;, &apos;isoweekday&apos;, &apos;max&apos;, &apos;microsecond&apos;, &apos;min&apos;, &apos;minute&apos;, &apos;month&apos;, &apos;now&apos;, &apos;replace&apos;, &apos;resolution&apos;, &apos;second&apos;, &apos;strftime&apos;, &apos;strptime&apos;, &apos;time&apos;, &apos;timestamp&apos;, &apos;timetuple&apos;, &apos;timetz&apos;, &apos;today&apos;, &apos;toordinal&apos;, &apos;tzinfo&apos;, &apos;tzname&apos;, &apos;utcfromtimestamp&apos;, &apos;utcnow&apos;, &apos;utcoffset&apos;, &apos;utctimetuple&apos;, &apos;weekday&apos;, &apos;year&apos;] Class attributesdatetime.minThe earliest representable datetime, datetime(MINYEAR, 1, 1, tzinfo=None). datetime.maxThe latest representable datetime, datetime(MAXYEAR, 12, 31, 23, 59, 59, 999999, tzinfo=None). datetime.resolutionThe smallest possible difference between non-equal datetime objects, timedelta(microseconds=1). Instance attributes (read-only)datetime.yearBetween MINYEAR and MAXYEAR inclusive. datetime.monthBetween 1 and 12 inclusive. datetime.dayBetween 1 and the number of days in the given month of the given year. datetime.hourIn range(24). datetime.minuteIn range(60). datetime.secondIn range(60). datetime.microsecondIn range(1000000). datetime.tzinfoThe object passed as the tzinfo argument to the datetime constructor, or None if none was passed. datetime.foldIn [0, 1]. Used to disambiguate wall times during a repeated interval. (A repeated interval occurs when clocks are rolled back at the end of daylight saving time or when the UTC offset for the current zone is decreased for political reasons.) The value 0 (1) represents the earlier (later) of the two moments with the same wall time representation. Class methodsdatetime.today()Return the current local datetime, with tzinfo None. This is equivalent to datetime.fromtimestamp(time.time()). 123&gt;&gt;&gt; from datetime import datetime&gt;&gt;&gt; datetime.today()datetime.datetime(2019, 8, 3, 23, 38, 14, 444364) datetime.now(tz=None)Return the current local date and time. If optional argument tz is None or not specified, this is like today(), but, if possible, supplies more precision than can be gotten from going through a time.time() timestamp (for example, this may be possible on platforms supplying the C gettimeofday() function). If tz is not None, it must be an instance of a tzinfo subclass, and the current date and time are converted to tz’s time zone. In this case the result is equivalent to tz.fromutc(datetime.utcnow().replace(tzinfo=tz)). datetime.utcnow()Return the current UTC date and time, with tzinfo None. This is like now(), but returns the current UTC date and time, as a naive datetime object. An aware current UTC datetime can be obtained by calling datetime.now(timezone.utc). See also now(). datetime.fromtimestamp(timestamp, tz=None)Return the local date and time corresponding to the POSIX timestamp, such as is returned by time.time(). If optional argument tz is None or not specified, the timestamp is converted to the platform’s local date and time, and the returned datetime object is naive. If tz is not None, it must be an instance of a tzinfo subclass, and the timestamp is converted to tz’s time zone. In this case the result is equivalent to tz.fromutc(datetime.utcfromtimestamp(timestamp).replace(tzinfo=tz)). datetime.utcfromtimestamp(timestamp)Return the UTC datetime corresponding to the POSIX timestamp, with tzinfo None. This may raise OverflowError, if the timestamp is out of the range of values supported by the platform C gmtime() function, and OSError on gmtime() failure. It’s common for this to be restricted to years in 1970 through 2038. datetime.fromordinal(ordinal)Return the datetime corresponding to the proleptic Gregorian ordinal, where January 1 of year 1 has ordinal 1. ValueError is raised unless 1 &lt;= ordinal &lt;= datetime.max.toordinal(). The hour, minute, second and microsecond of the result are all 0, and tzinfo is None. datetime.combine(date, time, tzinfo=self.tzinfo)Return a new datetime object whose date components are equal to the given date object’s, and whose time components are equal to the given time object’s. If the tzinfo argument is provided, its value is used to set the tzinfo attribute of the result, otherwise the tzinfo attribute of the time argument is used. For any datetime object d, d == datetime.combine(d.date(), d.time(), d.tzinfo). If date is a datetime object, its time components and tzinfo attributes are ignored. Changed in version 3.6: Added the tzinfo argument. datetime.fromisoformat(date_string)Return a datetime corresponding to a date_string in one of the formats emitted by date.isoformat() and datetime.isoformat(). Specifically, this function supports strings in the format(s) YYYY-MM-DD[*HH[:MM[:SS[.fff[fff]]]][+HH:MM[:SS[.ffffff]]]], where * can match any single character. datetime.strptime(date_string, format)Return a datetime corresponding to date_string, parsed according to format. This is equivalent to datetime(*(time.strptime(date_string, format)[0:6])). ValueError is raised if the date_string and format can’t be parsed by time.strptime() or if it returns a value which isn’t a time tuple. For a complete list of formatting directives, see strftime() and strptime() Behavior. Instance methodsdatetime.date()Return date object with same year, month and day. datetime.time()Return time object with same hour, minute, second, microsecond and fold. tzinfo is None. See also method timetz(). Changed in version 3.6: The fold value is copied to the returned time object. datetime.timetz()Return time object with same hour, minute, second, microsecond, fold, and tzinfo attributes. See also method time(). Changed in version 3.6: The fold value is copied to the returned time object. datetime.replace(year=self.year, month=self.month, day=self.day, hour=self.hour, minute=self.minute, second=self.second, microsecond=self.microsecond, tzinfo=self.tzinfo, * fold=0)Return a datetime with the same attributes, except for those attributes given new values by whichever keyword arguments are specified. Note that tzinfo=None can be specified to create a naive datetime from an aware datetime with no conversion of date and time data. New in version 3.6: Added the fold argument. datetime.astimezone(tz=None)Return a datetime object with new tzinfo attribute tz, adjusting the date and time data so the result is the same UTC time as self, but in tz’s local time. If provided, tz must be an instance of a tzinfo subclass, and its utcoffset() and dst() methods must not return None. If self is naive, it is presumed to represent time in the system timezone. datetime.utcoffset()If tzinfo is None, returns None, else returns self.tzinfo.utcoffset(self), and raises an exception if the latter doesn’t return None or a timedelta object with magnitude less than one day. Changed in version 3.7: The UTC offset is not restricted to a whole number of minutes. datetime.dst()If tzinfo is None, returns None, else returns self.tzinfo.dst(self), and raises an exception if the latter doesn’t return None or a timedelta object with magnitude less than one day. Changed in version 3.7: The DST offset is not restricted to a whole number of minutes. datetime.tzname()If tzinfo is None, returns None, else returns self.tzinfo.tzname(self), raises an exception if the latter doesn’t return None or a string object, datetime.timetuple()Return a time.struct_time such as returned by time.localtime(). d.timetuple() is equivalent to time.struct_time((d.year, d.month, d.day, d.hour, d.minute, d.second, d.weekday(), yday, dst)), where yday = d.toordinal() - date(d.year, 1, 1).toordinal() + 1 is the day number within the current year starting with 1 for January 1st. The tm_isdst flag of the result is set according to the dst() method: tzinfo is None or dst() returns None, tm_isdst is set to -1; else if dst() returns a non-zero value, tm_isdst is set to 1; else tm_isdst is set to 0. datetime.utctimetuple()If datetime instance d is naive, this is the same as d.timetuple() except that tm_isdst is forced to 0 regardless of what d.dst() returns. DST is never in effect for a UTC time. If d is aware, d is normalized to UTC time, by subtracting d.utcoffset(), and a time.struct_time for the normalized time is returned. tm_isdst is forced to 0. Note that an OverflowError may be raised if d.year was MINYEAR or MAXYEAR and UTC adjustment spills over a year boundary. datetime.toordinal()Return the proleptic Gregorian ordinal of the date. The same as self.date().toordinal(). datetime.timestamp()Return POSIX timestamp corresponding to the datetime instance. The return value is a float similar to that returned by time.time(). Naive datetime instances are assumed to represent local time and this method relies on the platform C mktime() function to perform the conversion. Since datetime supports wider range of values than mktime() on many platforms, this method may raise OverflowError for times far in the past or far in the future. datetime.weekday()Return the day of the week as an integer, where Monday is 0 and Sunday is 6. The same as self.date().weekday(). See also isoweekday(). datetime.isoweekday()Return the day of the week as an integer, where Monday is 1 and Sunday is 7. The same as self.date().isoweekday(). See also weekday(), isocalendar(). datetime.isocalendar()Return a 3-tuple, (ISO year, ISO week number, ISO weekday). The same as self.date().isocalendar(). datetime.isoformat(sep=’T’, timespec=’auto’)Return a string representing the date and time in ISO 8601 format, YYYY-MM-DDTHH:MM:SS.ffffff or, if microsecond is 0, YYYY-MM-DDTHH:MM:SS If utcoffset() does not return None, a string is appended, giving the UTC offset: YYYY-MM-DDTHH:MM:SS.ffffff+HH:MM[:SS[.ffffff]] or, if microsecond is 0 YYYY-MM-DDTHH:MM:SS+HH:MM[:SS[.ffffff]]. The optional argument sep (default ‘T’) is a one-character separator, placed between the date and time portions of the result. For example, 123456&gt;&gt;&gt; from datetime import tzinfo, timedelta, datetime&gt;&gt;&gt; class TZ(tzinfo):... def utcoffset(self, dt): return timedelta(minutes=-399)...&gt;&gt;&gt; datetime(2002, 12, 25, tzinfo=TZ()).isoformat(&apos; &apos;)&apos;2002-12-25 00:00:00-06:39&apos; The optional argument timespec specifies the number of additional components of the time to include (the default is ‘auto’). It can be one of the following: ‘auto’: Same as ‘seconds’ if microsecond is 0, same as ‘microseconds’ otherwise. ‘hours’: Include the hour in the two-digit HH format. ‘minutes’: Include hour and minute in HH:MM format. ‘seconds’: Include hour, minute, and second in HH:MM:SS format. ‘milliseconds’: Include full time, but truncate fractional second part to milliseconds. HH:MM:SS.sss format. ‘microseconds’: Include full time in HH:MM:SS.ffffff format. ValueError will be raised on an invalid timespec argument. 123456&gt;&gt;&gt; from datetime import datetime&gt;&gt;&gt; datetime.now().isoformat(timespec=&apos;minutes&apos;) # doctest: +SKIP&apos;2002-12-25T00:00&apos;&gt;&gt;&gt; dt = datetime(2015, 1, 1, 12, 30, 59, 0)&gt;&gt;&gt; dt.isoformat(timespec=&apos;microseconds&apos;)&apos;2015-01-01T12:30:59.000000&apos; datetime.str()For a datetime instance d, str(d) is equivalent to d.isoformat(‘ ‘). datetime.ctime()Return a string representing the date and time, for example datetime(2002, 12, 4, 20, 30, 40).ctime() == ‘Wed Dec 4 20:30:40 2002’. d.ctime() is equivalent to time.ctime(time.mktime(d.timetuple())) on platforms where the native C ctime() function (which time.ctime() invokes, but which datetime.ctime() does not invoke) conforms to the C standard. datetime.strftime(format)Return a string representing the date and time, controlled by an explicit format string. For a complete list of formatting directives, see strftime() and strptime() Behavior. datetime.format(format)Same as datetime.strftime(). This makes it possible to specify a format string for a datetime object in formatted string literals and when using str.format(). For a complete list of formatting directives, see strftime() and strptime() Behavior. Examples of working with datetime objects: 123456789101112131415161718192021222324252627282930313233343536373839404142&gt;&gt;&gt; from datetime import datetime, date, time&gt;&gt;&gt; # Using datetime.combine()&gt;&gt;&gt; d = date(2005, 7, 14)&gt;&gt;&gt; t = time(12, 30)&gt;&gt;&gt; datetime.combine(d, t)datetime.datetime(2005, 7, 14, 12, 30)&gt;&gt;&gt; # Using datetime.now() or datetime.utcnow()&gt;&gt;&gt; datetime.now() datetime.datetime(2007, 12, 6, 16, 29, 43, 79043) # GMT +1&gt;&gt;&gt; datetime.utcnow() datetime.datetime(2007, 12, 6, 15, 29, 43, 79060)&gt;&gt;&gt; # Using datetime.strptime()&gt;&gt;&gt; dt = datetime.strptime(&quot;21/11/06 16:30&quot;, &quot;%d/%m/%y %H:%M&quot;)&gt;&gt;&gt; dtdatetime.datetime(2006, 11, 21, 16, 30)&gt;&gt;&gt; # Using datetime.timetuple() to get tuple of all attributes&gt;&gt;&gt; tt = dt.timetuple()&gt;&gt;&gt; for it in tt: ... print(it)...2006 # year11 # month21 # day16 # hour30 # minute0 # second1 # weekday (0 = Monday)325 # number of days since 1st January-1 # dst - method tzinfo.dst() returned None&gt;&gt;&gt; # Date in ISO format&gt;&gt;&gt; ic = dt.isocalendar()&gt;&gt;&gt; for it in ic: ... print(it)...2006 # ISO year47 # ISO week2 # ISO weekday&gt;&gt;&gt; # Formatting datetime&gt;&gt;&gt; dt.strftime(&quot;%A, %d. %B %Y %I:%M%p&quot;)&apos;Tuesday, 21. November 2006 04:30PM&apos;&gt;&gt;&gt; &apos;The &#123;1&#125; is &#123;0:%d&#125;, the &#123;2&#125; is &#123;0:%B&#125;, the &#123;3&#125; is &#123;0:%I:%M%p&#125;.&apos;.format(dt, &quot;day&quot;, &quot;month&quot;, &quot;time&quot;)&apos;The day is 21, the month is November, the time is 04:30PM.&apos; Using datetime with tzinfo: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&gt;&gt;&gt; from datetime import timedelta, datetime, tzinfo, timezone&gt;&gt;&gt; class KabulTz(tzinfo):... # Kabul used +4 until 1945, when they moved to +4:30... UTC_MOVE_DATE = datetime(1944, 12, 31, 20, tzinfo=timezone.utc)... def utcoffset(self, dt):... if dt.year &lt; 1945:... return timedelta(hours=4)... elif (1945, 1, 1, 0, 0) &lt;= dt.timetuple()[:5] &lt; (1945, 1, 1, 0, 30):... # If dt falls in the imaginary range, use fold to decide how... # to resolve. See PEP495... return timedelta(hours=4, minutes=(30 if dt.fold else 0))... else:... return timedelta(hours=4, minutes=30)...... def fromutc(self, dt):... # A custom implementation is required for fromutc as... # the input to this function is a datetime with utc values... # but with a tzinfo set to self... # See datetime.astimezone or fromtimestamp...... # Follow same validations as in datetime.tzinfo... if not isinstance(dt, datetime):... raise TypeError(&quot;fromutc() requires a datetime argument&quot;)... if dt.tzinfo is not self:... raise ValueError(&quot;dt.tzinfo is not self&quot;)...... if dt.replace(tzinfo=timezone.utc) &gt;= self.UTC_MOVE_DATE:... return dt + timedelta(hours=4, minutes=30)... else:... return dt + timedelta(hours=4)...... def dst(self, dt):... return timedelta(0)...... def tzname(self, dt):... if dt &gt;= self.UTC_MOVE_DATE:... return &quot;+04:30&quot;... else:... return &quot;+04&quot;...... def __repr__(self):... return f&quot;&#123;self.__class__.__name__&#125;()&quot;...&gt;&gt;&gt; tz1 = KabulTz()&gt;&gt;&gt; # Datetime before the change&gt;&gt;&gt; dt1 = datetime(1900, 11, 21, 16, 30, tzinfo=tz1)&gt;&gt;&gt; print(dt1.utcoffset())4:00:00&gt;&gt;&gt; # Datetime after the change&gt;&gt;&gt; dt2 = datetime(2006, 6, 14, 13, 0, tzinfo=tz1)&gt;&gt;&gt; print(dt2.utcoffset())4:30:00&gt;&gt;&gt; # Convert datetime to another time zone&gt;&gt;&gt; dt3 = dt2.astimezone(timezone.utc)&gt;&gt;&gt; dt3datetime.datetime(2006, 6, 14, 8, 30, tzinfo=datetime.timezone.utc)&gt;&gt;&gt; dt2datetime.datetime(2006, 6, 14, 13, 0, tzinfo=KabulTz())&gt;&gt;&gt; dt2.utctimetuple() == dt3.utctimetuple()True tzinfo Objects1class datetime.tzinfo 12345&gt;&gt;&gt; from datetime import tzinfo &gt;&gt;&gt; dir(tzinfo) [&apos;__class__&apos;, &apos;__delattr__&apos;, &apos;__dir__&apos;, &apos;__doc__&apos;, &apos;__eq__&apos;, &apos;__format__&apos;, &apos;__ge__&apos;, &apos;__getattribute__&apos;, &apos;__gt__&apos;, &apos;__hash__&apos;, &apos;__init__&apos;, &apos;__init_subclass__&apos;, &apos;__le__&apos;, &apos;__lt__&apos;, &apos;__ne__&apos;, &apos;__new__&apos;, &apos;__reduce__&apos;, &apos;__reduce_ex__&apos;, &apos;__repr__&apos;, &apos;__setattr__&apos;, &apos;__sizeof__&apos;, &apos;__str__&apos;, &apos;__subclasshook__&apos;, &apos;dst&apos;, &apos;fromutc&apos;, &apos;tzname&apos;, &apos;utcoffset&apos;] 123456789101112131415161718192021222324252627282930Help on class tzinfo in module datetime:class tzinfo(builtins.object) | Abstract base class for time zone info objects. | | Methods defined here: | | __getattribute__(self, name, /) | Return getattr(self, name). | | __reduce__(...) | -&gt; (cls, state) | | dst(...) | datetime -&gt; DST offset as timedelta positive east of UTC. | | fromutc(...) | datetime in UTC -&gt; datetime in local time. | | tzname(...) | datetime -&gt; string name of time zone. | | utcoffset(...) | datetime -&gt; timedelta showing offset from UTC, negative values indicating West of UTC | | ---------------------------------------------------------------------- | Static methods defined here: | | __new__(*args, **kwargs) from builtins.type | Create and return a new object. See help(type) for accurate signature. timezone ObjectsThe timezone class is a subclass of tzinfo, each instance of which represents a timezone defined by a fixed offset from UTC. Note that objects of this class cannot be used to represent timezone information in the locations where different offsets are used in different days of the year or where historical changes have been made to civil time. 1class datetime.timezone(offset, name=None) The offset argument must be specified as a timedelta object representing the difference between the local time and UTC. It must be strictly between -timedelta(hours=24) and timedelta(hours=24), otherwise ValueError is raised. The name argument is optional. If specified it must be a string that will be used as the value returned by the datetime.tzname() method. 1234&gt;&gt;&gt; from datetime import timezone &gt;&gt;&gt; dir(timezone) [&apos;__class__&apos;, &apos;__delattr__&apos;, &apos;__dir__&apos;, &apos;__doc__&apos;, &apos;__eq__&apos;, &apos;__format__&apos;, &apos;__ge__&apos;, &apos;__getattribute__&apos;, &apos;__getinitargs__&apos;, &apos;__gt__&apos;, &apos;__hash__&apos;, &apos;__init__&apos;, &apos;__init_subclass__&apos;, &apos;__le__&apos;, &apos;__lt__&apos;, &apos;__ne__&apos;, &apos;__new__&apos;, &apos;__reduce__&apos;, &apos;__reduce_ex__&apos;, &apos;__repr__&apos;, &apos;__setattr__&apos;, &apos;__sizeof__&apos;, &apos;__str__&apos;, &apos;__subclasshook__&apos;, &apos;dst&apos;, &apos;fromutc&apos;, &apos;max&apos;, &apos;min&apos;, &apos;tzname&apos;, &apos;utc&apos;, &apos;utcoffset&apos;] 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677Help on class timezone in module datetime:class timezone(tzinfo) | Fixed offset from UTC implementation of tzinfo. | | Method resolution order: | timezone | tzinfo | builtins.object | | Methods defined here: | | __eq__(self, value, /) | Return self==value. | | __ge__(self, value, /) | Return self&gt;=value. | | __getinitargs__(...) | pickle support | | __gt__(self, value, /) | Return self&gt;value. | | __hash__(self, /) | Return hash(self). | | __le__(self, value, /) | Return self&lt;=value. | | __lt__(self, value, /) | Return self&lt;value. | | __ne__(self, value, /) | Return self!=value. | | __repr__(self, /) | Return repr(self). | | __str__(self, /) | Return str(self). | | dst(...) | Return None. | | fromutc(...) | datetime in UTC -&gt; datetime in local time. | | tzname(...) | If name is specified when timezone is created, returns the name. Otherwise returns offset as &apos;UTC(+|-)HH:MM&apos;. | | utcoffset(...) | Return fixed offset. | | ---------------------------------------------------------------------- | Static methods defined here: | | __new__(*args, **kwargs) from builtins.type | Create and return a new object. See help(type) for accurate signature. | | ---------------------------------------------------------------------- | Data and other attributes defined here: | | max = datetime.timezone(datetime.timedelta(seconds=86340)) | | min = datetime.timezone(datetime.timedelta(days=-1, seconds=60)) | | utc = datetime.timezone.utc | | ---------------------------------------------------------------------- | Methods inherited from tzinfo: | | __getattribute__(self, name, /) | Return getattr(self, name). | | __reduce__(...) | -&gt; (cls, state) Appendix1234567891011121314151617181920212223格式 说明%a 显示简化星期名称%A 显示完整星期名称%b 显示简化月份名称%B 显示完整月份名称%c 本地相应的日期和时间表示%d 显示当月第几天%H 按24小时制显示小时%I 按12小时制显示小时%j 显示当年第几天%m 显示月份%M 显示分钟数）%p 本地am或者pm的相应符%S 显示秒数）%U 一年中的星期数%w 显示在星期中的第几天，默认从0开始表示周一%W 和%U基本相同%x 本地相应日期%X 本地相应时间%y 去掉世纪的年份（00 - 99）%Y 完整的年份%Z 时区的名字（如果不存在为空字符）%% ‘%’字符 summary123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251NAME datetime - Fast implementation of the datetime type.CLASSES builtins.object date datetime time timedelta tzinfo timezone class date(builtins.object) date(year, month, day) --&gt; date object td = date(year=2018, month=10, day=10) # td is instance of date Instance Methods defined here: ctime() # Return ctime() style string. isocalendar() # Return a 3-tuple containing ISO year, week number, and weekday. isoformat() # Return string in ISO 8601 format, YYYY-MM-DD. isoweekday() # Return the day of the week represented by the date. Monday == 1 ... Sunday == 7 replace(year=self.year, month=self.month, day=self.day) # Return date with new specified fields. strftime(format) # format -&gt; strftime() style string. timetuple() # Return time tuple, compatible with time.localtime(). toordinal() # Return proleptic Gregorian ordinal. January 1 of year 1 is day 1. weekday() # Return the day of the week represented by the date. Monday == 0 ... Sunday == 6 Class methods defined here: fromisoformat(date_string) from builtins.type str -&gt; Construct a date from the output of date.isoformat() fromordinal(ordinal) from builtins.type int -&gt; date corresponding to a proleptic Gregorian ordinal. fromtimestamp(timestamp) from builtins.type timestamp -&gt; local date from a POSIX timestamp (like time.time()). today() from builtins.type Current date or datetime: same as self.__class__.fromtimestamp(time.time()). Data descriptors defined here: day month year Data and other attributes defined here: max = datetime.date(9999, 12, 31) min = datetime.date(1, 1, 1) resolution = datetime.timedelta(days=1) class datetime(date) datetime(year, month, day[, hour[, minute[, second[, microsecond[,tzinfo]]]]]) The year, month and day arguments are required. tzinfo may be None, or an instance of a tzinfo subclass. The remaining arguments may be ints. Method resolution order: datetime date builtins.object Instance Methods defined here: astimezone(tz=None) # tz -&gt; convert to local time in new timezone tz ctime() # Return ctime() style string. date() # Return date object with same year, month and day. dst() # Return self.tzinfo.dst(self). isoformat(sep=’T’, timespec=’auto’) [sep] -&gt; string in ISO 8601 format, YYYY-MM-DDT[HH[:MM[:SS[.mmm[uuu]]]]][+HH:MM]. sep is used to separate the year from the time, and defaults to &apos;T&apos;. timespec specifies what components of the time to include (allowed values are &apos;auto&apos;, &apos;hours&apos;, &apos;minutes&apos;, &apos;seconds&apos;, &apos;milliseconds&apos;, and &apos;microseconds&apos;). replace(year=self.year, month=self.month, day=self.day, hour=self.hour, minute=self.minute, second=self.second, microsecond=self.microsecond, tzinfo=self.tzinfo, * fold=0) Return datetime with new specified fields. time() # Return time object with same time but with tzinfo=None. timestamp() # Return POSIX timestamp as float. timetuple() # Return time tuple, compatible with time.localtime(). timetz() # Return time object with same time and tzinfo. tzname() # Return self.tzinfo.tzname(self). utcoffset() # Return self.tzinfo.utcoffset(self). utctimetuple() # Return UTC time tuple, compatible with time.localtime(). Class methods defined here: combine(date, time, tzinfo=self.tzinfo) from builtins.type date, time -&gt; datetime with same date and time fields fromisoformat(date_string) from builtins.type string -&gt; datetime from datetime.isoformat() output fromtimestamp(timestamp, tz=None) from builtins.type timestamp[, tz] -&gt; tz&apos;s local time from POSIX timestamp. timestamp is &apos;datetime.datetime&apos; object now(tz=None) from builtins.type Returns new datetime object representing current time local to tz. tz Timezone object. If no tz is specified, uses local timezone. strptime(date_string, format) from builtins.type date_string, format -&gt; new datetime parsed from a string (like time.strptime()). utcfromtimestamp(timestamp) from builtins.type Construct a naive UTC datetime from a POSIX timestamp. utcnow() from builtins.type Return a new datetime representing UTC day and time. Data descriptors defined here: fold hour microsecond minute second tzinfo Data and other attributes defined here: max = datetime.datetime(9999, 12, 31, 23, 59, 59, 999999) min = datetime.datetime(1, 1, 1, 0, 0) resolution = datetime.timedelta(microseconds=1) Methods inherited from date: isocalendar() # Return a 3-tuple containing ISO year, week number, and weekday. isoweekday() Return the day of the week represented by the date. Monday == 1 ... Sunday == 7 strftime(format) format -&gt; strftime() style string. toordinal() Return proleptic Gregorian ordinal. January 1 of year 1 is day 1. weekday() Return the day of the week represented by the date. Monday == 0 ... Sunday == 6 Class methods inherited from date: fromordinal(ordinal) from builtins.type int -&gt; date corresponding to a proleptic Gregorian ordinal. today() from builtins.type Current date or datetime: same as self.__class__.fromtimestamp(time.time()). Data descriptors inherited from date: day month year class time(builtins.object) time([hour[, minute[, second[, microsecond[, tzinfo]]]]]) --&gt; a time object All arguments are optional. tzinfo may be None, or an instance of a tzinfo subclass. The remaining arguments may be ints. Methods defined here: dst() # Return self.tzinfo.dst(self). isoformat(timespec=’auto’) Return string in ISO 8601 format, [HH[:MM[:SS[.mmm[uuu]]]]][+HH:MM]. timespec specifies what components of the time to include. replace(hour=self.hour, minute=self.minute, second=self.second, microsecond=self.microsecond, tzinfo=self.tzinfo, * fold=0) Return time with new specified fields. strftime(format) format -&gt; strftime() style string. tzname() Return self.tzinfo.tzname(self). utcoffset() Return self.tzinfo.utcoffset(self). Class methods defined here: fromisoformat(time_string) from builtins.type string -&gt; time from time.isoformat() output Data descriptors defined here: fold hour microsecond minute second tzinfo Data and other attributes defined here: max = datetime.time(23, 59, 59, 999999) min = datetime.time(0, 0) resolution = datetime.timedelta(microseconds=1) class timedelta(builtins.object) Difference between two datetime values. Methods defined here: total_seconds() Total seconds in the duration. Data descriptors defined here: days # Number of days. microseconds # Number of microseconds (&gt;= 0 and less than 1 second). seconds # Number of seconds (&gt;= 0 and less than 1 day). Data and other attributes defined here: max = datetime.timedelta(days=999999999, seconds=86399, microseconds=9... min = datetime.timedelta(days=-999999999) resolution = datetime.timedelta(microseconds=1) class timezone(tzinfo) Fixed offset from UTC implementation of tzinfo. Method resolution order: timezone tzinfo builtins.object Methods defined here: dst() # Return None. fromutc() # datetime in UTC -&gt; datetime in local time. tzname(...) If name is specified when timezone is created, returns the name. Otherwise returns offset as &apos;UTC(+|-) HH:MM&apos;. utcoffset(...) Return fixed offset. Data and other attributes defined here: max = datetime.timezone(datetime.timedelta(seconds=86340)) min = datetime.timezone(datetime.timedelta(days=-1, seconds=60)) utc = datetime.timezone.utc class tzinfo(builtins.object) Abstract base class for time zone info objects. Methods defined here: dst(...) datetime -&gt; DST offset as timedelta positive east of UTC. fromutc(...) datetime in UTC -&gt; datetime in local time. tzname(...) datetime -&gt; string name of time zone. utcoffset(...) datetime -&gt; timedelta showing offset from UTC, negative values indicating West of UTCDATA MAXYEAR = 9999 MINYEAR = 1 datetime_CAPI = &lt;capsule object &quot;datetime.datetime_CAPI&quot;&gt;]]></content>
      <categories>
        <category>python</category>
        <category>module</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>module</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML 笔记]]></title>
    <url>%2Fweb%2FHTML%2Fck9bgz7oa005cqov7j2icnjgx.html</url>
    <content type="text"><![CDATA[总得记点啥。。。 认识windows快捷键 Ctrl+c 复制 Ctrl+v 粘贴 Ctrl+x 剪切 Ctrl+a 全选 Ctrl+s 保存 Ctrl+z 撤销一步 Windows+d 返回桌面 Windows+e 我的电脑 Windows+r 打开运行 Alt+tab 切换软件 Ctrl+tab 软件文档之间的切换 F2 重命名 F5 刷新页面 认识大前端前端即网站前台部分，运行在 pc端、移动端 等浏览器上展现给用户浏览的网页。 前端核心技术：HTML、CSS、JavaScript HTML (Hyper Text Markup Language) —&gt; 结构 CSS (Cascading Style Sheet) —&gt; 样式 JavaScript —&gt; 行为动作 认识网页网页由文字、图片、输入框、视频、音频、超链接等组成。 web标准w3c 万维网联盟组织：用来制定web标准的机构（组织）web标准：制作网页要遵循的规范web标准规范的分类： 结构标准 —&gt; html，相当于人的身体 表现标准 —&gt; css，相当于人的衣服 行为标准 —&gt; javascript，相当于人的动作 浏览器浏览器 是网页运行的平台，常用的浏览器有IE、火狐（Firefox）、谷歌（Chrome）、Safari和Opera等。 扩展，待补充 。。。 初识HTMLhtml (Hyper Text Markup Language ) 中文译为“超文本标记语言”，主要是通过html标记对网页中的文本，图片，声音等内容进行描述。 HTML之所以称为超文本标记语言，不仅是因为他通过标记描述网页内容，同时也由于文本中包含了所谓的“超级链接”，通过超链接可以实现网页的跳转。从而构成了丰富多彩的Web页面。 HTML文件后缀名为 .html 或 .htm HTML结构标准123456789101112&lt;!DOCTYPE html&gt; # 声明文档类型&lt;html lang=&quot;en&quot;&gt; # 根标签&lt;head&gt; # 头标签 &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; # 标题标签&lt;/head&gt;&lt;body&gt; # 主题标签 。。。&lt;/body&gt;&lt;/html&gt; HTML标签分类单标签 单标签 注释标签 12&lt;!-- 注释内容 --&gt;注： 快捷键 Ctrl + / 换行标签 1&lt;br /&gt; 水平线标签 1&lt;hr /&gt; 图片标签 1&lt;img src=&quot;/path/filename&quot; alt=&quot;替代文字&quot; /&gt; 。。。。。。 双标签 双标签 段落标签 1&lt;p&gt;段落内容&lt;/p&gt; 标题标签 123&lt;h#&gt; 标题 &lt;/h#&gt;注： # 为 1-6 文本标签 1&lt;font&gt;文本内容&lt;/font&gt; 文本加粗标签 123&lt;strong&gt;文本内容&lt;/strong&gt; # 建议使用或&lt;b&gt;文本内容&lt;/b&gt; 下划线标签 123&lt;ins&gt;文本内容&lt;/ins&gt;或&lt;u&gt;文本内容&lt;/u&gt; 文本倾斜标签 123&lt;em&gt;文本内容&lt;/em&gt; # 建议使用或&lt;i&gt;文本内容&lt;/i&gt; 删除线标签 123&lt;del&gt;文本内容&lt;/del&gt; # 建议使用或&lt;s&gt;&lt;/s&gt; 超链接 1&lt;a href=&quot;link path&quot;&gt;链接名&lt;/a&gt; 。。。。。。 路径相对路径相对于文件自身出发的路径，就是相对路径。 绝对路径从根目录出发的路径，即位绝对路径。]]></content>
      <categories>
        <category>web</category>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux 安装ssh以及ssh用法与免密登录]]></title>
    <url>%2FLinux%2Fssh%2Fck9bgz7k30023qov71eeggvo3.html</url>
    <content type="text"><![CDATA[ssh 简述SSH ( Secure Shell) 由 IETF 的网络工作小组（Network Working Group）所制定； SSH 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。其是建立在应用层和传输层基础上的安全协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。 SSH最初是UNIX系统上的一个程序，后来又迅速扩展到其他操作平台。SSH在正确使用时可弥补网络中的漏洞。 SSH客户端适用于多种平台。几乎所有UNIX平台—包括HP-UX、Linux、AIX、Solaris、Digital UNIX、Irix，以及其他平台，都可运行SSH。 ssh 安装命令： yum install -y openssh-server openssh-clients 启动ssh： service sshd start 或 /etc/init.d/sshd start 配置开机启动： chkconfig –level 2345 sshd on 配置hosts文件编辑 /etc/hosts文件，在文件尾部添加： ​ IP hostname ​ 例： ​ 192.168.10.10 linux ssh免密登录生成密钥命令：ssh-keygen -t rsa 注：上述操作后一路回车，生成之后会在用户的根目录生成一个 “.ssh”的文件夹。 123456789101112131415161718192021[root@hadoop-centos-01 bin]# ssh-keygen -t rsaGenerating public/private rsa key pair.Enter file in which to save the key (/root/.ssh/id_rsa):Enter passphrase (empty for no passphrase):Enter same passphrase again:Your identification has been saved in /root/.ssh/id_rsa.Your public key has been saved in /root/.ssh/id_rsa.pub.The key fingerprint is:SHA256:cvRFrezrrpzUxZiHr7oufeyNJZGRimjVd1QV7TYTF9c root@hadoop-centos-01The key&apos;s randomart image is:+---[RSA 2048]----+| ...+X|| . . o..E|| o ..=...o|| + o +oO oo|| + S o.* +.o|| . o ..= || ...o.o || .o..+* || oBO* . |+----[SHA256]-----+ 12[root@hadoop-centos-01 opt]# cd ; ll -al | grep .sshdrwx------. 2 root root 80 May 12 22:25 .ssh .ssh 目录包含文件： 123456[root@hadoop-centos-01 .ssh]# ll -ltotal 16-rw-------. 1 root root 1613 May 12 22:30 authorized_keys-rw-------. 1 root root 1675 Aug 1 07:37 id_rsa-rw-r--r--. 1 root root 403 Aug 1 07:37 id_rsa.pub-rw-r--r--. 1 root root 919 May 13 06:54 known_hosts authorized_keys: 存放远程免密登录的公钥,主要通过这个文件记录多台机器的公钥 id_rsa : 生成的私钥文件 id_rsa.pub ： 生成的公钥文件 know_hosts : 已知的主机公钥清单 注： ​ 如果希望ssh公钥生效需满足至少下面两个条件： 1) .ssh目录的权限必须是700 2) .ssh/authorized_keys文件权限必须是600 设置免密登录通过ssh-copy-id的方式命令： ssh-copy-id -i ~/.ssh/id_rsa.pub [ip/hosts] 通过scp将内容写到对方的文件中命令：scp -p ~/.ssh/id_rsa.pub root@:/root/.ssh/authorized_keys]]></content>
      <categories>
        <category>Linux</category>
        <category>ssh</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>command</tag>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Typora简单教程]]></title>
    <url>%2FTypora%2Fck9bgz7aj0009qov7o3sep3t5.html</url>
    <content type="text"><![CDATA[序言Typora是一款轻便简洁的Markdown编辑器，支持即时渲染技术，这也是与其他Markdown编辑器最显著的区别。即时渲染使得你写Markdown就想是写Word文档一样流畅自如，不像其他编辑器的有编辑栏和显示栏。 基本操作内容目录 语法 1[toc] 标题 语法 123456# 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 引用 语法 123&gt; 引用内容1&gt; 引用内容2&gt;&gt; 引用内容3 效果 引用内容1 引用内容2 引用内容3 代码单行代码 语法 1`String str1 = &quot;hello&quot;;` 效果 string str1 = &quot;hello world&quot;; 多行代码 语法 1~~~ Language 效果 12int a = 10;int b = 20; 列表无序列表 语法 123* 无序列表1+ 无序列表2- 无序列表3 效果 无序列表1 无序列表2 无序列表3 多行无需列表 语法 123* 多行无序列表1TAB * 多行无序列表2TAB TAB * 多行无序列表3 效果 多行无序列表1 多行无序列表2 多行无序列表3 有序列表 语法 1231. 有序列表12. 有序列表23. 有序列表3 效果 有序列表1 有序列表2 有序列表3 多行有序列表 语法 12345671. 多行有序列表12. 多行有序列表2 1. 多行有序列表2-1 2. 多行有序列表2-23. 多行有序列表3 1. 多行有序列表3-1 2. 多行有序列表3-2 效果 多行有序列表1 多行有序列表2 多行有序列表2-1 多行有序列表2-2 多行有序列表3 多行有序列表3-1 多行有序列表3-2 任务列表 语法 123-[ ] 抽烟-[x] 喝酒-[ ] 烫头 效果 -[ ] 抽烟-[x] 喝酒-[ ] 烫头 表格 语法 12345|姓名|性别|年龄|手机号||:---|:--:|:--:|---:||张三|男|21|18975346876||李四|女|23|17789548964||王五|男|25|15876513546| 效果 姓名 性别 年龄 手机号 张三 男 21 18975346876 李四 女 23 17789548964 王五 男 25 15876513546 链接图片 语法1（本地图片） 1[图片上传失败...(image-61fd19-1520850984854)] 语法2（网络图片） 1![typora.jpg(https://uploadimages.jianshu.io/upload_images/1538862d91e815790b81e4a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) 超链接 语法1（行内式链接） 12[百度][https://www.baidu.com/][百度](https://www.baidu.com/) 效果 [百度][https://www.baidu.com/ ]百度 语法2（参考式链接） 12[CSDN][CSDN网址][CSDN网址]:https://www.csdn.net/ 效果CSDN 语法3（自动链接） 1&lt;https://github.com/&gt; 效果3 https://github.com/ 其他斜体 语法 12*斜体*_斜体_ 效果 斜体 斜体 加粗 语法 12**加粗**__加粗__ 效果 加粗 加粗 下划线 语法 1&lt;u&gt;下划线&lt;/u&gt; 效果 下划线 删除线 语法 1删除线 效果 删除线 分隔线 语法 123***---___ 效果 注脚 语法 12Typora[^1][^1]A markdown editor 效果 Typora[^1] 上下标 语法 1234$3^2=9$$3^&#123;(3-1)&#125;=9$$H_2SO_4$$H_&#123;2SO_4&#125;$ 效果 $3^2=9$ $3^{(3-1)}=9$ $H_2SO_4$ $H_{2SO_4}$ 符号的输入 语法 123456789101112\\ 反斜线\` 反引号\* 星号\_ 底线\&#123; \&#125; 花括号\[ \] 方括号\( \) 括弧\# 井字号\+ 加号\- 减号\. 英文句点\! 惊叹号 效果 \ ` * _ {} [] ( ) # + - . ! 特殊字符 语法 1234567891011121314151617181920&amp;copy; 版权 &amp;reg; 注册商标&amp;trade; 商标&amp;nbsp; 空格&amp;amp; 和号&amp;quot; 引号&amp;apos; 撇号&amp;lt; 小于号&amp;gt; 大于号&amp;ne; 不等号&amp;le; 小于等于&amp;ge; 大于等于&amp;cent; 分&amp;pound; 磅&amp;euro; 欧元&amp;yen; 元&amp;sect; 节&amp;times; 乘号&amp;divide; 除号&amp;plusmn; 正负号 效果 &copy; &reg; &trade; &nbsp; &amp; &quot; &apos; &lt; &gt; &ne; &le; &ge; &cent; &pound; &euro; &yen; &sect; &times; &divide; &plusmn; 附: HTML特殊字符编码对照表[传送门]https://www.jb51.net/onlineread/htmlchar.htm]]></content>
      <categories>
        <category>Typora</category>
      </categories>
      <tags>
        <tag>markdown</tag>
        <tag>Typora</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo error log]]></title>
    <url>%2Fhexo%2Ferror-log%2Fck9bgz7mj003xqov7s3ga7oxq.html</url>
    <content type="text"><![CDATA[搭建 hexo，在执行 hexo deploy 后,出现 error deployer not found:github 的错误 hexo 更新到3.0之后，deploy的type 的github需要改成gitnpm install hexo-deployer-git –save 改了之后执行，然后再部署]]></content>
      <categories>
        <category>hexo</category>
        <category>error log</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown 教程]]></title>
    <url>%2Fmarkdown%2Fck9bgz7ep0017qov79ltcpoex.html</url>
    <content type="text"><![CDATA[概览Markdown 是一种标记语言（轻量级的、可用纯文本编写）;Markdown 诞生于2004年，由约翰·格鲁伯（John Gruber）创建；Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式。Markdown 编写的文档后缀为 .md, .markdown。 宗旨Markdown 的目标是实现「易读易写」。 应用Markdown 能被使用来撰写电子书，如：Gitbook。 当前许多网站都广泛使用 Markdown 来撰写帮助文档或是用于论坛上发表消息。例如：GitHub、简书、reddit、Diaspora、Stack Exchange、OpenStreetMap 、SourceForge等。 编辑器Markdown编辑器目前颇多，可参考以下链接进行选择。 [传送门] https://blog.csdn.net/qq_36759224/article/details/82229243 区块元素段落和换行Markdown段落由一个或多个连续的文本行组成。Markdown换行由两个及已上的空格加回车实现。 标题Markdown 支持两种标题的语法，类Setext 和 Atx形式。 使用 = 和 - 标记一级和二级标题（类Setext）12345我展示的是一级标题=================我展示的是二级标题----------------- 注：任何数量的 = 和 - 都可以有效果。 使用 # 号标记 1-6 级标题（类Atx）123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 区块引用 BlockquotesMarkdown 标记区块引用是在每行的最前面加上 &gt; ，如下： 123456&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,&gt; consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.&gt; Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.&gt; &gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse&gt; id sem consectetuer libero luctus adipiscing. 或在整个段落的第一行最前面加上 &gt; ： 123456&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.&gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisseid sem consectetuer libero luctus adipiscing. 区块引用可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的 &gt; ： 12345 This is the first level of quoting.&gt;&gt; &gt; This is nested blockquote.&gt;&gt; Back to the first level. 引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等： 12345678&gt; ## 这是一个标题。&gt; &gt; 1. 这是第一行列表项。&gt; 2. 这是第二行列表项。&gt; &gt; 给出一些例子代码：&gt; &gt; return shell_exec(&quot;echo $input | $markdown_script&quot;); 列表Markdown支持有序列表和无序列表。 无序列表无序列表使用星号、加号或是减号作为列表标记： 123* 无序列表+ 无序列表- 无序列表 有序列表有序列表则使用数字接着一个英文句点，然后加至少一个空格： 1231. Bird2. McHale3. Parish 注：列表上的数字不会影响输出的 HTML 结果 代码区块 Markdown 实现代码区块只要简单地缩进 4 个空格或是 1 个制表符就可以； 一个代码区块会一直持续到没有缩进的那一行（或是文件结尾）。 在代码区块里面， &amp; 、 &lt; 和 &gt; 会自动转成 HTML 实体。 代码区块中，一般的 Markdown 语法不会被转换，像是星号便只是星号。 分割线在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。 123***---___ 区段元素链接Markdown 支持两种形式的链接语法： 行内式和参考式两种形式。 不管是哪一种，链接文字都是用 [方括号] 来标记。 行内式建立一个行内式的链接，只要在方块括号后面紧接着圆括号并插入网址链接即可，如果你还想要加上链接的title文字，只要在网址后面，用双引号把title文字包起来即可 12This is [an example](http://example.com/ &quot;Title&quot;) inline link.[This link](http://example.net/) has no title attribute. 如果你是要链接到同样主机的资源，你可以使用相对路径： 1See my [About](/about/) page for details. 参考式在链接文字的括号后面再接上另一个方括号，而在第二个方括号里面要填入用以辨识链接的标记： 1This is [an example][id] reference-style link. 你也可以选择性地在两个方括号中间加上一个空格： 1This is [an example] [id] reference-style link. 接着，在文件的任意处，你可以把这个标记的链接内容定义出来： 1[id]: http://example.com/ "Optional Title Here" 隐式链接标记功能让你可以省略指定链接标记，这种情形下，链接标记会视为等同于链接文字，要用隐式链接标记只要在链接文字后面加上一个空的方括号，如果你要让 “Google” 链接到 google.com，你可以简化成： 1[Google][] 然后定义链接内容： 1[Google]: http://google.com/ 注：链接辨别标签可以有字母、数字、空白和标点符号，但是并不区分大小写，链接的定义可以放在文件中的任何一个地方，我比较偏好直接放在链接出现段落的后面，你也可以把它放在文件最后面，就像是注解一样。 强调Markdown 使用星号（*）和底线（_）作为标记强调字词的符号。 1234*single asterisks*_single underscores_**double asterisks**__double underscores__ 注：用什么符号开启标签，就要用什么符号结束，强调可以出现在文字中间，但如果*和_两边都有空白的话，它们将被当成普通的符号。 如果要在文字前后直接插入普通的星号或底线，你可以用反斜线： 1\*this text is surrounded by literal asterisks\* 代码如果要标记一小段行内代码，你可以用反引号把它包起来（`），例如： 1Use the `printf()` function. 如果要在代码区段内插入反引号，你可以用多个反引号来开启和结束代码区段： 1``There is a literal backtick (`) here.`` 代码区段的起始和结束端都可以放入一个空白，起始端后面一个，结束端前面一个，这样你就可以在区段的一开始就插入反引号： 123A single backtick in a code span: `` ` ``A backtick-delimited string in a code span: `` `foo` `` 在代码区段内，&amp; 和方括号都会被自动地转成 HTML 实体，这使得插入 HTML 原始码变得很容易，Markdown 会把下面这段： 图片Markdown 使用一种和链接很相似的语法来标记图片，同样也允许两种样式： 行内式和参考式。 行内式12![Alt text](/path/to/img.jpg)![Alt text](/path/to/img.jpg &quot;Optional title&quot;) 详细叙述如下： 一个惊叹号 ! 接着一个方括号，里面放上图片的替代文字 接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上 选择性的 ‘title’ 文字。 参考式1![Alt text][id] 「id」是图片参考的名称，图片参考的定义方式则和连结参考一样： 1[id]: url/to/image "Optional title attribute" 到目前为止， Markdown 还没有办法指定图片的宽高，如果你需要的话，你可以使用普通的&lt;img&gt; 标签。 其它反斜杠Markdown 可以利用反斜杠来插入一些在语法中有其它意义的符号，例如：如果你想要用星号加在文字旁边的方式来做出强调效果（但不用 标签），你可以在星号的前面加上反斜杠： 1\*literal asterisks\* Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号： 123456789101112\ 反斜线` 反引号* 星号_ 底线&#123;&#125; 花括号[] 方括号() 括弧# 井字号+ 加号- 减号. 英文句点! 惊叹号 自动链接Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用方括号包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如： 1&lt;http://example.com/&gt; Markdown 会转为： 1&lt;a href="http://example.com/"&gt;http://example.com/&lt;/a&gt; 邮址的自动链接也很类似，只是 Markdown 会先做一个编码转换的过程，把文字字符转成 16 进位码的 HTML 实体，这样的格式可以糊弄一些不好的邮址收集机器人，例如： 1&lt;address@example.com&gt; Markdown 会转成： 1234&lt;a href="mailto:address@example.com"&gt;address@example.com&lt;/a&gt; 在浏览器里面，这段字串（其实是 &lt;a href=&quot;mailto:address@example.com&quot;&gt;address@example.com&lt;/a&gt;）会变成一个可以点击的「address@example.com」链接。 感谢http://www.markdown.cn/#acknowledgement]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[杂记]]></title>
    <url>%2Funcategorized%2Fck9bgz7b4000jqov7s0c999fe.html</url>
    <content type="text"><![CDATA[linuxCentos7 安装https://www.jianshu.com/p/2cdc3ea850b7https://blog.csdn.net/u013168176/article/details/81144193 centos7 网卡启动异常处理https://blog.csdn.net/dongfei2033/article/details/81124465 Vmware虚拟机网络配置(固定IP)https://www.jianshu.com/p/6fdbba039d79https://blog.csdn.net/weixin_39609623/article/details/82146778 bigdataHadoop Shell命令http://hadoop.apache.org/docs/r1.0.4/cn/hdfs_shell.html Linux 离线安装pysparkhttps://blog.csdn.net/ghj786110/article/details/82880577 Spark配置参数详解https://www.cnblogs.com/yangcx666/p/8723826.html Spark集群-Standalone 模式https://www.cnblogs.com/zyzdisciple/p/11599596.html pyspark 包介绍https://www.cnblogs.com/wenBlog/p/6323678.html Spark学习笔记–Spark在Windows下的环境搭建https://www.cnblogs.com/xuliangxing/p/7279662.html Spark &amp; PySpark 使用手册https://haofly.net/spark/ Spark简介(Python版)http://dblab.xmu.edu.cn/blog/1710-2/ pythonPython标准库(非常经典的各种模块介绍)https://blog.csdn.net/qq_41804164/article/details/81448207 linux下安装python3.7.3https://blog.csdn.net/jiahao1186/article/details/89454992https://blog.csdn.net/weixin_43969563/article/details/90700839 python3之模块io使用流的核心工具https://www.cnblogs.com/zhangxinqi/p/9135038.html python zipfile 模块https://www.cnblogs.com/ctztake/p/9141259.html 术语对照表https://docs.python.org/zh-cn/3.7/glossary.html#glossary Python之Numpy详细教程http://www.uml.org.cn/python/201907091.asp web知识点大杂烩https://www.w3cplus.com/CSS3https://www.zhangxinxu.com/wordpress/ MDN Web docshttps://developer.mozilla.org/zh-CN/ DockerDocker 官方镜像搜索地址https://hub.docker.com/search/?type=image Docker run 命令https://www.runoob.com/docker/docker-run-command.html Docker安装配置教程https://blog.csdn.net/laughing1997/article/details/84305615 史上最简单的Docker入门教程https://blog.csdn.net/itguangit/article/details/80222387 Docker教程：Docker入门实践（精讲版）http://c.biancheng.net/docker/ 如何给Docker配置官方国内加速镜像https://zhidao.baidu.com/question/1951427014116364148.html docker 异常处理https://www.cnblogs.com/dakewei/p/10831125.htmlhttps://www.cnblogs.com/qq952693358/p/6406189.html docker拉去镜像timeout问题解决https://blog.csdn.net/weixin_40789566/article/details/79986861 详解使用DockerHub官方的mysql镜像生成容器https://www.cnblogs.com/adolfmc/p/7109342.html CentOS7 启动docker.service失败https://segmentfault.com/q/1010000002392472 Dockerfile 最佳实践及示例http://dockone.io/article/9551 Docker 的部署方式http://dockone.io/article/8619 Docker Kubernetes YAML文件常用指令https://www.cnblogs.com/xiangsikai/p/10002060.html HexoHexo博客中插入音乐https://www.jianshu.com/p/6e41e3191963 Hexo 博客静态资源压缩优化https://www.playpi.org/2018112101.html Hexo博客使用gulp压缩静态资源https://segmentfault.com/a/1190000019842178 gulp 快速入门https://www.gulpjs.com.cn/docs/getting-started/quick-start/ ELK搭建###快速搭建ELK日志分析系统https://blog.csdn.net/e_wsq/article/details/81303713https://www.elastic.co/guide/cn/index.html ELK原理与介绍https://www.cnblogs.com/aresxin/p/8035137.html 终于有人把Elasticsearch原理讲透了！http://developer.51cto.com/art/201904/594615.htm 日志管理系统ELK6.2.3https://www.cnblogs.com/wangmo/p/9505883.html ubutun下载地址[中科大源]http://mirrors.ustc.edu.cn/ubuntu-releases/16.04/ [阿里云开源镜像站]http://mirrors.aliyun.com/ubuntu-releases/16.04/ [兰州大学开源镜像站]http://mirror.lzu.edu.cn/ubuntu-releases/16.04/ [北京理工大学开源]http://mirror.bit.edu.cn/ubuntu-releases/16.04/ [浙江大学]http://mirrors.zju.edu.cn/ubuntu-releases/16.04/ Linux ShellShell脚本：Linux Shell脚本学习指南（超详细）http://c.biancheng.net/shell/ 网站红黑联盟https://www.2cto.com/ 骇客http://www.webhek.com/ codecombathttps://koudashijie.com/play 数据结构二叉树前序、中序、后序遍历相互求法https://blog.csdn.net/u011435776/article/details/80946479 软件下载spark安装包http://spark.apache.org/downloads.html minio文档https://docs.min.io/cn/minio-docker-quickstart-guide.html Minio存储桶通知指南https://blog.csdn.net/dingjs520/article/details/79111008 Minio 环境搭建详述https://www.linuxidc.com/Linux/2019-11/161331.htm Docker安装Minio存储服务器详解https://www.jianshu.com/p/52dbc679094a GitHubhttps://github.com/aixiu 协议OSI 七层模型和TCP/IP模型及对应协议（详解）https://blog.csdn.net/qq_41923622/article/details/85805003]]></content>
  </entry>
  <entry>
    <title><![CDATA[git 教程]]></title>
    <url>%2Fgit%2Fck9bgz7wr008jqov78urc04xc.html</url>
    <content type="text"><![CDATA[git 简介git是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。 Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。 Git 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。 Git 与 SVN 区别 Git 是分布式的，SVN 不是：这是 Git 和其它非分布式的版本控制系统，例如 SVN，CVS 等，最核心的区别。 Git 把内容按元数据方式存储，而 SVN 是按文件：所有的资源控制系统都是把文件的元信息隐藏在一个类似 .svn、.cvs 等的文件夹里。 Git 分支和 SVN 的分支不同：分支在 SVN 中一点都不特别，其实它就是版本库中的另外一个目录。 Git 没有一个全局的版本号，而 SVN 有：目前为止这是跟 SVN 相比 Git 缺少的最大的一个特征。 Git 的内容完整性要优于 SVN：Git 的内容存储使用的是 SHA-1 哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏。 Git 安装配置Git 目前支持 Linux/Unix、Solaris、Mac和 Windows 平台上运行。 Git 各平台安装包下载地址为：http://git-scm.com/downloads Linux 平台上安装首先安装依赖库 curl，zlib，openssl，expat，libiconv 等。 Debian/Ubuntu123456$ apt-get install libcurl4-gnutls-dev libexpat1-dev gettext libz-dev libssl-dev$ apt-get install git$ git --versiongit version 1.8.1.2 Centos/RedHat123456$ yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel$ yum -y install git-core$ git --versiongit version 1.7.1 源码安装官网下载源码包来安装，下载地址：https://git-scm.com/download 安装指定系统的依赖包： 12345########## Centos/RedHat ##########$ yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel########## Debian/Ubuntu ##########$ apt-get install libcurl4-gnutls-dev libexpat1-dev gettext libz-dev libssl-dev 解压安装下载的源码包： 1234$ tar -zxf git-1.7.2.2.tar.gz$ cd git-1.7.2.2$ make perfix=/usr/local all$ sudo mkdir prefix=/usr/local install Windows 平台上安装下载安装包：https://gitforwindows.org/ 安装流程与普通软件无异 完成安装之后，在开始菜单里找到”Git”-&gt;”Git Bash”，会弹出 Git 命令窗口，你可以在该窗口进行 Git 操作。 Mac 平台上安装下载安装包：http://sourceforge.net/projects/git-osx-installer/ Git 配置Git 提供了一个叫做 git config 的工具，专门用来配置或读取相应的工作环境变量。 这些环境变量，决定了 Git 在各个环节的具体工作方式和行为。这些变量可以存放在以下三个不同的地方： /etc/gitconfig 文件：系统中对所有用户都普遍适用的配置。若使用 git config 时用 --system 选项，读写的就是这个文件。 ~/.gitconfig 文件：用户目录下的配置文件只适用于该用户。若使用 git config 时用 --global 选项，读写的就是这个文件。 当前项目的 Git 目录中的配置文件（也就是工作目录中的 .git/config 文件）：这里的配置仅仅针对当前项目有效。每一个级别的配置都会覆盖上层的相同配置，所以 .git/config 里的配置会覆盖 /etc/gitconfig 中的同名变量。 在 Windows 系统上，Git 会找寻用户主目录下的 .gitconfig 文件。主目录即 $HOME 变量指定的目录，一般都是 C:\Documents and Settings$USER。 用户信息配置个人的用户名称和电子邮件地址 12$ git config --global user.name &quot;your_name&quot;$ git config --global user.email &quot;your_email&quot; 如果用了 –global 选项，那么更改的配置文件就是位于你用户主目录下的那个，以后你所有的项目都会默认使用这里配置的用户信息。 如果要在某个特定的项目中使用其他名字或者电邮，只要去掉 –global 选项重新配置即可，新的设定保存在当前项目的 .git/config 文件里 文本编辑器设置Git默认使用的文本编辑器, 一般可能会是 Vi 或者 Vim。如果你有其他偏好，比如 Emacs 的话，可以重新设置： 1$ git config --global core.editor emacs 差异分析工具还有一个比较常用的是，在解决合并冲突时使用哪种差异分析工具。比如要改用 vimdiff 的话： 1$ git config --global merge.tool vimdiff Git 可以理解 kdiff3，tkdiff，meld，xxdiff，emerge，vimdiff，gvimdiff，ecmerge，和 opendiff 等合并工具的输出信息。 查看配置信息要检查已有的配置信息，可以使用 git config –list 命令： 123456789101112131415$ git config --listcore.symlinks=falsecore.autocrlf=truecore.fscache=truecolor.diff=autocolor.status=autocolor.branch=autocolor.interactive=truehelp.format=htmlrebase.autosquash=truehttp.sslbackend=opensslhttp.sslcainfo=E:/Git/mingw64/ssl/certs/ca-bundle.crtcredential.helper=manageruser.name=yournameuser.email= emailname 直接查阅某个环境变量的设定，只要把特定的名字跟在后面即可 12$ git config user.nameyourname Git 工作流程 克隆 Git 资源作为工作目录 在克隆的资源上添加或修改文件 如果其他人修改了，也可以更新资源 在提交前查看修改 提交修改 修改完成后，如果发现错误，可以撤回并再次修改提交 Git 工作区、暂存区和版本库工作区 就是你在电脑里能看到的目录，当前编辑的目录。 暂存区 英文叫stage, 或index。一般存放在 “.git目录下” 下的index文件（.git/index）中，所以我们把暂存区有时也叫作索引（index） 版本库 工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。 下面这个图展示了工作区、版本库中的暂存区和版本库之间的关系： 图中左侧为工作区，右侧为版本库。在版本库中标记为 “index” 的区域是暂存区（stage, index），标记为 “master” 的是 master 分支所代表的目录树 图中我们可以看出此时 “HEAD” 实际是指向 master 分支的一个”游标”。所以图示的命令中出现 HEAD 的地方可以用 master 来替换 图中的 objects 标识的区域为 Git 的对象库，实际位于 “.git/objects” 目录下，里面包含了创建的各种对象及内容 当对工作区修改（或新增）的文件执行 “git add” 命令时，暂存区的目录树被更新，同时工作区修改（或新增）的文件内容被写入到对象库中的一个新的对象中，而该对象的ID被记录在暂存区的文件索引中。 当执行提交操作（git commit）时，暂存区的目录树写到版本库（对象库）中，master 分支会做相应的更新。即 master 指向的目录树就是提交时暂存区的目录树。 当执行 “git reset HEAD” 命令时，暂存区的目录树会被重写，被 master 分支指向的目录树所替换，但是工作区不受影响。 当执行 “git rm –cached &lt;file&gt;“ 命令时，会直接从暂存区删除文件，工作区则不做出改变。 当执行 “git checkout .” 或者 “git checkout -- &lt;file&gt;“ 命令时，会用暂存区全部或指定的文件替换工作区的文件。这个操作很危险，会清除工作区中未添加到暂存区的改动。 当执行 “git checkout HEAD .“ 或者 “git checkout HEAD &lt;file&gt;“ 命令时，会用 HEAD 指向的 master 分支中的全部或者部分文件替换暂存区和以及工作区中的文件。这个命令也是极具危险性的，因为不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动。 Git 创建仓库git initGit 使用 git init 命令来初始化一个 Git 仓库，Git 的很多命令都需要在 Git 的仓库中运行，所以 git init 是使用 Git 的第一个命令。 在执行完成 git init 命令后，Git 仓库会生成一个 .git 目录，该目录包含了资源的所有元数据，其他的项目目录保持不变（不像 SVN 会在每个子目录生成 .svn 目录，Git 只在仓库的根目录生成 .git 目录）。 1$ git init [directory] git clone现有 Git 仓库中拷贝项目 123$ git clone &lt;repo&gt; [directory] &lt;repo&gt; Git 仓库 [directory] 本地目录 例： 12$ git clone git://github.com/schacon/grit.git # 默认下载到当前目录$ git clone git://github.com/schacon/grit.git mygrit # 下载到 mygrit 目录 Git 基本操作获取与创建项目命令git init1$ git init [directory] 例： 12345678910$ mkdir test$ cd test/$ git initInitialized empty Git repository in D:/Github/test/.git/$ ll -altotal 8drwxr-xr-x 1 Mr wang 197121 0 8月 27 06:34 ./drwxr-xr-x 1 Mr wang 197121 0 8月 27 06:33 ../drwxr-xr-x 1 Mr wang 197121 0 8月 27 06:34 .git/ git clone使用 git clone 拷贝一个 Git 仓库到本地，让自己能够查看该项目，或者进行修改。 如果你需要与他人合作一个项目，或者想要复制一个项目，看看代码，你就可以克隆那个项目,命令： 1$ git clone &lt;url&gt; [directory] 默认情况下，Git 会按照你提供的 URL 所指示的项目的名称创建你的本地项目目录。 通常就是该 URL 最后一个 / 之后的项目名称。如果你想要一个不一样的名字， 你可以在该命令后加上你想要的名称。 基本快照Git 的工作就是创建和保存你的项目的快照及与之后的快照进行对比。 git add添加文件到缓存 123456789101112131415161718# 新建文件 README exapmle.py$ touch README$ touch example.py$ lsexample.py README# 查看项目的当前状态$ git status -s?? README?? example.py# 添加文件到缓存$ git add README example.py# 再次查看项目的当前状态，新建的两个文件已经加到缓存$ git status -sA READMEA example.py 添加当前项目的所有文件 1$ git add . git status查看在上次提交之后是否有修改 12345678910$ git statusOn branch masterNo commits yetChanges to be committed: (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage) new file: README new file: example.py git diff显示已写入缓存与已修改但尚未写入缓存的改动的区别。git diff 有两个主要的应用场景。 尚未缓存的改动：git diff 查看已缓存的改动： git diff –cached 查看已缓存的与未缓存的所有改动：git diff HEAD 显示摘要而非整个 diff：git diff –stat git commit12$ git commit [-m &quot;commit message&quot;]$ git commit -a # 越过提交信息填写 git reset HEAD执行 git reset HEAD 以取消之前 git add 添加，但不希望包含在下一提交快照中的缓存 1$ git reset HEAD filename git rm要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除，然后提交。可以用以下命令完成此项工作 1$ git rm &lt;file&gt; 如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 -f 1$ git rm -f &lt;file&gt; 如果把文件从暂存区域移除，但仍然希望保留在当前工作目录中，换句话说，仅是从跟踪清单中删除，使用 –cached 选项即可 1$ git rm --cached &lt;file&gt; 不从工作区中删除文件 1$ git rm --cached filename 进入某个目录中，执行下面语句，会删除该目录下的所有文件和子目录 1$ git rm -r * git mv移动或重命名一个文件、目录、软连接 1$ git mv old_file new_file Git 分支管理几乎每一种版本控制系统都以某种形式支持分支。使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作。 有人把 Git 的分支模型称为必杀技特性，而正是因为它，将 Git 从版本控制系统家族里区分出来 创建分支命令1$ git branch &lt;branchname&gt; 切换分支命令1$ git checkout &lt;branchname&gt; 当你切换分支的时候，Git 会用该分支的最后提交的快照替换你的工作目录的内容， 所以多个分支不需要多个目录。 创建并切换分支1$ git checkout -b &lt;branchname&gt; 合并分支命令1$ git merge &lt;branchname&gt; 合并分支内容到当前分支 列出分支1$ git branch 删除分支1$ git branch -d &lt;branchname&gt; 合并冲突Git 查看提交历史查看详细提交历史记录 1$ git log 查看简洁提交历史记录 1$ git log --oneline 1234$ git log --oneline3672b71 (HEAD -&gt; master, test) change the test.txt9b6ac00 add test.txtfd6f625 first commit 查看历史中什么时候出现了分支、合并 1$ git log --graph Git 标签如果你达到一个重要的阶段，并希望永远记住那个特别的提交快照，你可以使用 git tag 给它打上标签。 比如说，我们想为我们的 runoob 项目发布一个”1.0”版本。 我们可以用 git tag -a v1.0 命令给最新一次提交打上（HEAD）”v1.0”的标签。 -a 选项意为”创建一个带注解的标签”。 不用 -a 选项也可以执行的，但它不会记录这标签是啥时候打的，谁打的，也不会让你添加个标签的注解。 推荐一直创建带注解的标签。 1$ git tag -a &lt;version&gt; [commit_id] 查看标签 1$ git tag 指定标签信息命令 1$ git tag -a &lt;tagname&gt; -m &quot;message&quot; PGP签名标签命令 1$ git tag -s &lt;tagname&gt; -m &quot;message&quot; Git 远程仓库(Github)添加远程库1$ git remote add &lt;shortname&gt; &lt;url&gt; Git 服务器搭建 安装Git 12$ yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel perl-devel$ yum install git 接下来我们 创建一个git用户组和用户，用来运行git服务： 12$ groupadd git$ useradd git -g git 创建证书登录 收集所有需要登录的用户的公钥，公钥位于id_rsa.pub文件中，把我们的公钥导入到/home/git/.ssh/authorized_keys文件里，一行一个。如果没有该文件创建它。 12345$ cd /home/git/$ mkdir .ssh$ chmod 755 .ssh$ touch .ssh/authorized_keys$ chmod 644 .ssh/authorized_keys 初始化Git仓库 首先我们选定一个目录作为Git仓库，假定是/home/gitrepo/runoob.git，在/home/gitrepo目录下输入命令： 1234567$ cd /home$ mkdir gitrepo$ chown git:git gitrepo/$ cd gitrepo$ git init --bare runoob.gitInitialized empty Git repository in /home/gitrepo/runoob.git/ 以上命令Git创建一个空仓库，服务器上的Git仓库通常都以.git结尾。然后，把仓库所属用户改为git： 1$ chown -R git:git runoob.git 克隆仓库 1234$ git clone git@192.168.45.4:/home/gitrepo/runoob.gitCloning into &apos;runoob&apos;...warning: You appear to have cloned an empty repository.Checking connectivity... done. 192.168.45.4 为 Git 所在服务器 ip ，你需要将其修改为你自己的 Git 服务 ip。这样我们的 Git 服务器安装就完成。 Reference[本文内容转载自] : https://www.runoob.com/git/git-tutorial.html]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
</search>
