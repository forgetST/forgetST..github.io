<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[python 审查清理文本字符串]]></title>
    <url>%2Fpython%2Ftips%2Fck0xy27fu005vksv726n8bmf5.html</url>
    <content type="text"><![CDATA[问题一些无聊的幼稚黑客在你的网站页面表单中输入文本”pýtĥöñ”，然后你想将这些字符清理掉。 解决方案文本清理问题会涉及到包括文本解析与数据处理等一系列问题。 在非常简单的情形下，你可能会选择使用字符串函数(比如 str.upper() 和 str.lower() )将文本转为标准格式。 使用 str.replace()或者 re.sub() 的简单替换操作能删除或者改变指定的字符序列。 你同样还可以使用2.9小节的 unicodedata.normalize() 函数将unicode文本标准化。 然后，有时候你可能还想在清理操作上更进一步。比如，你可能想消除整个区间上的字符或者去除变音符。 为了这样做，你可以使用经常会被忽视的 str.translate() 方法。 为了演示，假设你现在有下面这个凌乱的字符串： 123&gt;&gt;&gt; s = &apos;pýtĥöñ\fis\tawesome\r\n&apos;&gt;&gt;&gt; s&apos;pýtĥöñ\x0cis\tawesome\r\n&apos; 第一步是清理空白字符。为了这样做，先创建一个小的转换表格然后使用 translate() 方法： 12345678&gt;&gt;&gt; remap = &#123; ord(&apos;\t&apos;) : &apos; &apos;, ord(&apos;\f&apos;) : &apos; &apos;, ord(&apos;\r&apos;) : None # Deleted &#125;&gt;&gt;&gt; a = s.translate(remap)&gt;&gt;&gt; a&apos;pýtĥöñ is awesome\n&apos; 正如你看的那样，空白字符 \t 和 \f 已经被重新映射到一个空格。回车字符r直接被删除。 你可以以这个表格为基础进一步构建更大的表格。比如，让我们删除所有的和音符： 123456789&gt;&gt;&gt; import unicodedata&gt;&gt;&gt; import sys&gt;&gt;&gt; cmb_chrs = dict.fromkeys(c for c in range(sys.maxunicode) if unicodedata.combining(chr(c)))&gt;&gt;&gt; b = unicodedata.normalize(&apos;NFD&apos;, a)&gt;&gt;&gt; b&apos;pýtĥöñ is awesome\n&apos;&gt;&gt;&gt; b.translate(cmb_chrs)&apos;python is awesome\n&apos; 上面例子中，通过使用 dict.fromkeys() 方法构造一个字典，每个Unicode和音符作为键，对应的值全部为 None 。 然后使用 unicodedata.normalize() 将原始输入标准化为分解形式字符。 然后再调用 translate 函数删除所有重音符。 同样的技术也可以被用来删除其他类型的字符(比如控制字符等)。 作为另一个例子，这里构造一个将所有Unicode数字字符映射到对应的ASCII字符上的表格： 12345678910&gt;&gt;&gt; digitmap = &#123; c: ord(&apos;0&apos;) + unicodedata.digit(chr(c)) for c in range(sys.maxunicode) if unicodedata.category(chr(c)) == &apos;Nd&apos; &#125;&gt;&gt;&gt; len(digitmap)460&gt;&gt;&gt; # Arabic digits&gt;&gt;&gt; x = &apos;\u0661\u0662\u0663&apos;&gt;&gt;&gt; x.translate(digitmap)&apos;123&apos; 另一种清理文本的技术涉及到I/O解码与编码函数。这里的思路是先对文本做一些初步的清理， 然后再结合 encode() 或者 decode() 操作来清除或修改它。比如： 12345&gt;&gt;&gt; a&apos;pýtĥöñ is awesome\n&apos;&gt;&gt;&gt; b = unicodedata.normalize(&apos;NFD&apos;, a)&gt;&gt;&gt; b.encode(&apos;ascii&apos;, &apos;ignore&apos;).decode(&apos;ascii&apos;)&apos;python is awesome\n&apos; 这里的标准化操作将原来的文本分解为单独的和音符。接下来的ASCII编码/解码只是简单的一下子丢弃掉那些字符。 当然，这种方法仅仅只在最后的目标就是获取到文本对应ACSII表示的时候生效。 讨论文本字符清理一个最主要的问题应该是运行的性能。一般来讲，代码越简单运行越快。 对于简单的替换操作， str.replace() 方法通常是最快的，甚至在你需要多次调用的时候。 比如，为了清理空白字符，你可以这样做： 12345def clean_spaces(s): s = s.replace(&apos;\r&apos;, &apos;&apos;) s = s.replace(&apos;\t&apos;, &apos; &apos;) s = s.replace(&apos;\f&apos;, &apos; &apos;) return s 如果你去测试的话，你就会发现这种方式会比使用 translate() 或者正则表达式要快很多。 另一方面，如果你需要执行任何复杂字符对字符的重新映射或者删除操作的话， tanslate() 方法会非常的快。 从大的方面来讲，对于你的应用程序来说性能是你不得不去自己研究的东西。 不幸的是，我们不可能给你建议一个特定的技术，使它能够适应所有的情况。 因此实际情况中需要你自己去尝试不同的方法并评估它。 转载自：https://python3-cookbook.readthedocs.io/zh_CN/latest/c02/p12_sanitizing_clean_up_text.html]]></content>
      <categories>
        <category>python</category>
        <category>tips</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python unicodedata module]]></title>
    <url>%2Fpython%2Fmodule%2Fck0xy27fe005nksv71bsfnkdk.html</url>
    <content type="text"><![CDATA[简介处理Unicode字符数据库(UCD)的模块，UCD为所有Unicode字符定义字符属性。 UCD是Unicode字符数据库（Unicode Character DataBase）的缩写。 UCD由一些描述Unicode字符属性和内部关系的纯文本或html文件组成。 UCD中的文本文件大都是适合于程序分析的Unicode相关数据。其中的html文件解释了数据库的组织，数据的格式和含义。 定义函数123&gt;&gt;&gt; import unicodedata&gt;&gt;&gt; dir(unicodedata)[&apos;UCD&apos;, &apos;__doc__&apos;, &apos;__file__&apos;, &apos;__loader__&apos;, &apos;__name__&apos;, &apos;__package__&apos;, &apos;__spec__&apos;, &apos;bidirectional&apos;, &apos;category&apos;, &apos;combining&apos;, &apos;decimal&apos;, &apos;decomposition&apos;, &apos;digit&apos;, &apos;east_asian_width&apos;, &apos;lookup&apos;, &apos;mirrored&apos;, &apos;name&apos;, &apos;normalize&apos;, &apos;numeric&apos;, &apos;ucd_3_2_0&apos;, &apos;ucnhash_CAPI&apos;, &apos;unidata_version&apos;] unicodedata.lookup(name)12345lookup(name, /) Look up character by name. If a character with the given name is found, return the corresponding character. If not found, KeyError is raised. 1234567&gt;&gt;&gt; unicodedata.lookup(&apos;LEFT CURLY BRACKET&apos;)&#123;&gt;&gt;&gt; unicodedata.lookup(&apos;LEFT CURLY&apos;)Traceback (most recent call last): File &quot;&lt;pyshell#35&gt;&quot;, line 1, in &lt;module&gt; unicodedata.lookup(&apos;LEFT CURLY&apos;)KeyError: &quot;undefined character name &apos;LEFT CURLY&apos;&quot; unicodedata.name(chr, default=None)12345name(chr, default=None, /) Returns the name assigned to the character chr as a string. If no name is defined, default is returned, or, if not given, ValueError is raised. 12345678&gt;&gt;&gt; unicodedata.name(&apos;&#125;&apos;)&apos;RIGHT CURLY BRACKET&apos;&gt;&gt;&gt; unicodedata.name(&apos;&#125;&#125;&apos;)Traceback (most recent call last): File &quot;&lt;pyshell#37&gt;&quot;, line 1, in &lt;module&gt; unicodedata.name(&apos;&#125;&#125;&apos;)TypeError: name() argument 1 must be a unicode character, not str unicodedata.decimal(chr, default=None)123456decimal(chr, default=None, /) Converts a Unicode character into its equivalent decimal value. Returns the decimal value assigned to the character chr as integer. If no such value is defined, default is returned, or, if not given, ValueError is raised. 123456789&gt;&gt;&gt; unicodedata.decimal(&apos;8&apos;)8&gt;&gt;&gt; type(unicodedata.decimal(&apos;8&apos;))&lt;class &apos;int&apos;&gt;&gt;&gt;&gt; unicodedata.decimal(&apos;a&apos;)Traceback (most recent call last): File &quot;&lt;pyshell#46&gt;&quot;, line 1, in &lt;module&gt; unicodedata.decimal(&apos;a&apos;)ValueError: not a decimal unicodedata.digit(chr, default=None)123456digit(chr, default=None, /) Converts a Unicode character into its equivalent digit value. Returns the digit value assigned to the character chr as integer. If no such value is defined, default is returned, or, if not given, ValueError is raised. 1234567&gt;&gt;&gt; unicodedata.digit(&apos;8&apos;)8&gt;&gt;&gt; unicodedata.digit(&apos;a&apos;)Traceback (most recent call last): File &quot;&lt;pyshell#50&gt;&quot;, line 1, in &lt;module&gt; unicodedata.digit(&apos;a&apos;)ValueError: not a digit unicodedata.numeric(chr, default=None)123456numeric(chr, default=None, /) Converts a Unicode character into its equivalent numeric value. Returns the numeric value assigned to the character chr as float. If no such value is defined, default is returned, or, if not given, ValueError is raised. 123456789&gt;&gt;&gt; unicodedata.numeric(&apos;5&apos;)5.0&gt;&gt;&gt; unicodedata.numeric(&apos;五&apos;) 5.0&gt;&gt;&gt; unicodedata.numeric(&apos;无&apos;) Traceback (most recent call last): File &quot;&lt;pyshell#52&gt;&quot;, line 1, in &lt;module&gt; unicodedata.numeric(&apos;无&apos;)ValueError: not a numeric character unicodedata.category(chr)12category(chr, /) Returns the general category assigned to the character chr as string. unicodedata.bidirectional(chr)123bidirectional(chr, /) Returns the bidirectional class assigned to the character chr as string. If no such value is defined, an empty string is returned. unicodedata.combining(chr)123combining(chr, /) Returns the canonical combining class assigned to the character chr as integer. Returns 0 if no combining class is defined. unicodedata.decomposition(chr)123decomposition(chr, /) Returns the character decomposition mapping assigned to the character chr as string. An empty string is returned in case no such mapping is defined. unicodedata.east_asian_width(chr) 12east_asian_width(chr, /) Returns the east asian width assigned to the character chr as string. unicodedata.mirrored(chr)1234mirrored(chr, /) Returns the mirrored property assigned to the character chr as integer. Returns 1 if the character has been identified as a &quot;mirrored&quot; character in bidirectional text, 0 otherwise. unicodedata.normalize(form, unistr)normalize(form, unistr, /) Return the normal form &apos;form&apos; for the Unicode string unistr. Valid values for form are &apos;NFC&apos;, &apos;NFKC&apos;, &apos;NFD&apos;, and &apos;NFKD&apos;.unicodedata.unidata_versionunicodedata.ucnhash_CAPIunicodedata.ucd_3_2_01234DATA ucd_3_2_0 = &lt;unicodedata.UCD object&gt; ucnhash_CAPI = &lt;capsule object &quot;unicodedata.ucnhash_CAPI&quot;&gt; unidata_version = &apos;11.0.0&apos; Referencehttps://docs.python.org/zh-cn/3/library/unicodedata.html#module-unicodedata https://blog.csdn.net/xc_zhou/article/details/82079753]]></content>
      <categories>
        <category>python</category>
        <category>module</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>module</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python 将Unicode文本标准化]]></title>
    <url>%2Fpython%2Ftips%2Fck0xy27fn005sksv7kkyztw1m.html</url>
    <content type="text"><![CDATA[问题你正在处理Unicode字符串，需要确保所有字符串在底层有相同的表示。 解决方案在Unicode中，某些字符能够用多个合法的编码表示。为了说明，考虑下面的这个例子： 123456789101112&gt;&gt;&gt; s1 = &apos;Spicy Jalape\u00f1o&apos;&gt;&gt;&gt; s2 = &apos;Spicy Jalapen\u0303o&apos;&gt;&gt;&gt; s1&apos;Spicy Jalapeño&apos;&gt;&gt;&gt; s2&apos;Spicy Jalapeño&apos;&gt;&gt;&gt; s1 == s2False&gt;&gt;&gt; len(s1)14&gt;&gt;&gt; len(s2)15 这里的文本”Spicy Jalapeño”使用了两种形式来表示。 第一种使用整体字符”ñ”(U+00F1)，第二种使用拉丁字母”n”后面跟一个”~”的组合字符(U+0303)。 在需要比较字符串的程序中使用字符的多种表示会产生问题。 为了修正这个问题，你可以使用unicodedata模块先将文本标准化： 1234567891011121314&gt;&gt;&gt; import unicodedata&gt;&gt;&gt; t1 = unicodedata.normalize(&apos;NFC&apos;, s1)&gt;&gt;&gt; t2 = unicodedata.normalize(&apos;NFC&apos;, s2)&gt;&gt;&gt; t1 == t2True&gt;&gt;&gt; print(ascii(t1))&apos;Spicy Jalape\xf1o&apos;&gt;&gt;&gt; t3 = unicodedata.normalize(&apos;NFD&apos;, s1)&gt;&gt;&gt; t4 = unicodedata.normalize(&apos;NFD&apos;, s2)&gt;&gt;&gt; t3 == t4True&gt;&gt;&gt; print(ascii(t3))&apos;Spicy Jalapen\u0303o&apos; normalize() 第一个参数指定字符串标准化的方式。 NFC表示字符应该是整体组成(比如可能的话就使用单一编码)，而NFD表示字符应该分解为多个组合字符表示。 Python同样支持扩展的标准化形式NFKC和NFKD，它们在处理某些字符的时候增加了额外的兼容特性。比如： 12345678910&gt;&gt;&gt; s = &apos;\ufb01&apos; # A single character&gt;&gt;&gt; s&apos;ﬁ&apos;&gt;&gt;&gt; unicodedata.normalize(&apos;NFD&apos;, s)&apos;ﬁ&apos;# Notice how the combined letters are broken apart here&gt;&gt;&gt; unicodedata.normalize(&apos;NFKD&apos;, s)&apos;fi&apos;&gt;&gt;&gt; unicodedata.normalize(&apos;NFKC&apos;, s)&apos;fi&apos; 讨论标准化对于任何需要以一致的方式处理Unicode文本的程序都是非常重要的。 当处理来自用户输入的字符串而你很难去控制编码的时候尤其如此。 在清理和过滤文本的时候字符的标准化也是很重要的。 比如，假设你想清除掉一些文本上面的变音符的时候(可能是为了搜索和匹配)： 123&gt;&gt;&gt; t1 = unicodedata.normalize(&apos;NFD&apos;, s1)&gt;&gt;&gt; &apos;&apos;.join(c for c in t1 if not unicodedata.combining(c))&apos;Spicy Jalapeno&apos; 最后一个例子展示了 unicodedata 模块的另一个重要方面，也就是测试字符类的工具函数。combining() 函数可以测试一个字符是否为和音字符。 在这个模块中还有其他函数用于查找字符类别，测试是否为数字字符等等。 转载自： https://python3-cookbook.readthedocs.io/zh_CN/latest/c02/p09_normalize_unicode_text_to_regexp.html]]></content>
      <categories>
        <category>python</category>
        <category>tips</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python fnmatch module]]></title>
    <url>%2Fpython%2Fmodule%2Fck0xy27g20060ksv7zbnj7phh.html</url>
    <content type="text"><![CDATA[介绍在python中，fnmatch模块是用来做字符串匹配文件名的标准库。 源码: Lib/fnmatch.py fnmatch支持的通配符： 通配符 含义 * 匹配任何数量的字符 ？ 匹配单个字符 [seq] 匹配seq中的字符 [!seq] 匹配除seq以外的任何字符 使用123&gt;&gt;&gt; import fnmatch&gt;&gt;&gt; fnmatch.__all__[&apos;filter&apos;, &apos;fnmatch&apos;, &apos;fnmatchcase&apos;, &apos;translate&apos;] fnmatch这个库相对比较简单，只有4个函数，分别是fnmatch、fnmatchcase、filter和translate，其中最常用的是fnmatch。主要功能如下： fnmatch：判断文件名是否符合特定的模式。 fnmatchcase：判断文件名是否符合特定的模式，区分大小写。 filter：返回输入列表中，符合特定模式的文件名列表。 translate：将通配符模式转换成正则表达式。 示例fnmatch.fnmatch1语法：fnmatch(name, pat) 1234567891011121314&gt;&gt;&gt; file_list = [&apos;A1.jpg&apos;, &apos;a1.txt&apos;, &apos;a2.txt&apos;, &apos;aA.txt&apos;, &apos;b3.jpg&apos;, &apos;b2.jpg&apos;, &apos;b1.jpg&apos;]# 匹配图片&gt;&gt;&gt; [name for name in file_list if fnmatch.fnmatch(name, &apos;*.jpg&apos;)][&apos;A1.jpg&apos;, &apos;b3.jpg&apos;, &apos;b2.jpg&apos;, &apos;b1.jpg&apos;]&gt;&gt;&gt; [name for name in file_list if fnmatch.fnmatch(name, &apos;*.JPG&apos;)][&apos;A1.jpg&apos;, &apos;b3.jpg&apos;, &apos;b2.jpg&apos;, &apos;b1.jpg&apos;]# 上述方式等效于如下：&gt;&gt;&gt; [name for name in file_list if name.endswith(&apos;.jpg&apos;)][&apos;A1.jpg&apos;, &apos;b3.jpg&apos;, &apos;b2.jpg&apos;, &apos;b1.jpg&apos;]注：fnmatch.fnmatch 方式匹配文件名时，不区分大小写，即大小写不敏感。 fnmatch.fnmatchcase1语法：fnmatchcase(name, pat) 12345678910&gt;&gt;&gt; file_list = [&apos;A1.jpg&apos;, &apos;a1.txt&apos;, &apos;a2.txt&apos;, &apos;aA.txt&apos;, &apos;b3.jpg&apos;, &apos;b2.jpg&apos;, &apos;b1.jpg&apos;]&gt;&gt;&gt; [name for name in file_list if fnmatch.fnmatchcase(name, &apos;*.jpg&apos;)][&apos;A1.jpg&apos;, &apos;b3.jpg&apos;, &apos;b2.jpg&apos;, &apos;b1.jpg&apos;]# 大些的 *.JPG 将匹配不到&gt;&gt;&gt; [name for name in file_list if fnmatch.fnmatchcase(name, &apos;*.JPG&apos;)][]注：fnmatch.fnmatchcase 用法与 fnmatch.fnmatch相同，区别是其大小写敏感。 fnmatch.filter1语法：filter(names, pat) 123456&gt;&gt;&gt; file_list = [&apos;A1.jpg&apos;, &apos;a1.txt&apos;, &apos;a2.txt&apos;, &apos;aA.txt&apos;, &apos;b3.jpg&apos;, &apos;b2.jpg&apos;, &apos;b1.jpg&apos;]&gt;&gt;&gt; fnmatch.filter(file_list, &apos;*.jpg&apos;)[&apos;A1.jpg&apos;, &apos;b3.jpg&apos;, &apos;b2.jpg&apos;, &apos;b1.jpg&apos;]&gt;&gt;&gt; fnmatch.filter(file_list, &apos;*.JPG&apos;)[&apos;A1.jpg&apos;, &apos;b3.jpg&apos;, &apos;b2.jpg&apos;, &apos;b1.jpg&apos;] fnmatch.translate1语法：translate(pat) 12&gt;&gt;&gt; fnmatch.translate(&apos;*jpg&apos;)&apos;(?s:.*jpg)\\Z&apos;]]></content>
      <categories>
        <category>python</category>
        <category>module</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>module</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[猴子爬山问题]]></title>
    <url>%2Fmath%2Fck0xy271q002uksv7trp7vsln.html</url>
    <content type="text"><![CDATA[问题一只顽猴儿在一座有 n 级台阶的山上爬山，假设猴子上山一步可跳1级台阶或3级台阶。试求猴子上山有多少种不同爬法。 分析这一问题实际上是一个整数有序可重复拆分问题，通过递归思想求解： f(n) –&gt; n 级台阶的爬山总方法数 考虑在猴子到达最后一个台阶时，其所处位置在 n-1 台阶处或n-3 台阶处，故有 f(n) = f(n-1) + f(n-3) 因 n&gt;0 , 故： n=1 或 n=2 , f(1) = f(2) = 1 n = 3 , f(3) = 2 程序设计python 实现123456789101112131415161718#!/usr/bin/env python3import functools@functools.lru_cache()def recursion_count(n: &quot;int, and n &gt; 0&quot;): if n == 1 or n == 2: return 1 elif n == 3: return 2 elif n &gt; 3: return recursion_count(n-1) + recursion_count(n-3)if __name__ == &quot;__main__&quot;: a = recursion_count(50) print(a) # 122106097 functools.lru_cache 为python中一个缓存装饰器，其作用可以直接将函数或类方法的结果缓存住，后续调用则直接返回缓存的结果。 原型如下： @functools.lru_cache(maxsize=None, typed=False) maxsize –&gt; 最多缓存的次数，如果为 None，则无限制，设置为 2 的幂时，性能最佳 typed=True –&gt; 不同参数类型的调用将分别缓存，例如 f(3) 和 f(3.0)。(注意，在 functools32 中没有此参数) LRU (Least Recently Used，最近最少使用) 算法是一种缓存淘汰策略。其根据数据的历史访问记录来进行淘汰，核心思想是，“如果数据最近被访问过，那么将来被访问的几率也更高”。该算法最初为操作系统中一种内存管理的页面置换算法，主要用于找出内存中较久时间没有使用的内存块，将其移出内存从而为新数据提供空间。]]></content>
      <categories>
        <category>math</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python 通过某个字段将记录分组]]></title>
    <url>%2Fpython%2Ftips%2Fck0xy27no0095ksv76v4h0o53.html</url>
    <content type="text"><![CDATA[问题你有一个字典或者实例的序列，然后你想根据某个特定的字段比如 date 来分组迭代访问。 实现通过 itertools.groupby() 函数实现上述需求 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&gt;&gt;&gt; from itertools import groupby&gt;&gt;&gt; from operator import itemgetter&gt;&gt;&gt; import pprint&gt;&gt;&gt; rows = [ &#123;&apos;address&apos;: &apos;5412 N CLARK&apos;, &apos;date&apos;: &apos;07/01/2012&apos;&#125;, &#123;&apos;address&apos;: &apos;5148 N CLARK&apos;, &apos;date&apos;: &apos;07/04/2012&apos;&#125;, &#123;&apos;address&apos;: &apos;5800 E 58TH&apos;, &apos;date&apos;: &apos;07/02/2012&apos;&#125;, &#123;&apos;address&apos;: &apos;2122 N CLARK&apos;, &apos;date&apos;: &apos;07/03/2012&apos;&#125;, &#123;&apos;address&apos;: &apos;5645 N RAVENSWOOD&apos;, &apos;date&apos;: &apos;07/02/2012&apos;&#125;, &#123;&apos;address&apos;: &apos;1060 W ADDISON&apos;, &apos;date&apos;: &apos;07/02/2012&apos;&#125;, &#123;&apos;address&apos;: &apos;4801 N BROADWAY&apos;, &apos;date&apos;: &apos;07/01/2012&apos;&#125;, &#123;&apos;address&apos;: &apos;1039 W GRANVILLE&apos;, &apos;date&apos;: &apos;07/04/2012&apos;&#125;,]# 先堆 rows 安date进行排序&gt;&gt;&gt; rows.sort(key=itemgetter(&apos;date&apos;))# rows 按需后输出结果&gt;&gt;&gt; pprint.pprint(rows)[&#123;&apos;address&apos;: &apos;5412 N CLARK&apos;, &apos;date&apos;: &apos;07/01/2012&apos;&#125;, &#123;&apos;address&apos;: &apos;4801 N BROADWAY&apos;, &apos;date&apos;: &apos;07/01/2012&apos;&#125;, &#123;&apos;address&apos;: &apos;5800 E 58TH&apos;, &apos;date&apos;: &apos;07/02/2012&apos;&#125;, &#123;&apos;address&apos;: &apos;5645 N RAVENSWOOD&apos;, &apos;date&apos;: &apos;07/02/2012&apos;&#125;, &#123;&apos;address&apos;: &apos;1060 W ADDISON&apos;, &apos;date&apos;: &apos;07/02/2012&apos;&#125;, &#123;&apos;address&apos;: &apos;2122 N CLARK&apos;, &apos;date&apos;: &apos;07/03/2012&apos;&#125;, &#123;&apos;address&apos;: &apos;5148 N CLARK&apos;, &apos;date&apos;: &apos;07/04/2012&apos;&#125;, &#123;&apos;address&apos;: &apos;1039 W GRANVILLE&apos;, &apos;date&apos;: &apos;07/04/2012&apos;&#125;]# 对 rows 进行分组 &gt;&gt;&gt; for date, items in groupby(rows, key=itemgetter(&apos;date&apos;)): print(date) for i in items: print(&apos; &apos;, i) 07/01/2012 &#123;&apos;address&apos;: &apos;5412 N CLARK&apos;, &apos;date&apos;: &apos;07/01/2012&apos;&#125; &#123;&apos;address&apos;: &apos;4801 N BROADWAY&apos;, &apos;date&apos;: &apos;07/01/2012&apos;&#125;07/02/2012 &#123;&apos;address&apos;: &apos;5800 E 58TH&apos;, &apos;date&apos;: &apos;07/02/2012&apos;&#125; &#123;&apos;address&apos;: &apos;5645 N RAVENSWOOD&apos;, &apos;date&apos;: &apos;07/02/2012&apos;&#125; &#123;&apos;address&apos;: &apos;1060 W ADDISON&apos;, &apos;date&apos;: &apos;07/02/2012&apos;&#125;07/03/2012 &#123;&apos;address&apos;: &apos;2122 N CLARK&apos;, &apos;date&apos;: &apos;07/03/2012&apos;&#125;07/04/2012 &#123;&apos;address&apos;: &apos;5148 N CLARK&apos;, &apos;date&apos;: &apos;07/04/2012&apos;&#125; &#123;&apos;address&apos;: &apos;1039 W GRANVILLE&apos;, &apos;date&apos;: &apos;07/04/2012&apos;&#125; groupby() 函数扫描整个序列并且查找连续相同值（或者根据指定 key 函数返回值相同）的元素序列。 在每次迭代的时候，它会返回一个值和一个迭代器对象， 这个迭代器对象可以生成元素值全部等于上面那个值的组中所有对象。 一个非常重要的准备步骤是要根据指定的字段将数据排序。 因为 groupby() 仅仅检查连续的元素，如果事先并没有排序完成的话，分组函数将得不到想要的结果。 Referencehttps://python3-cookbook.readthedocs.io/zh_CN/latest/c01/p15_group_records_based_on_field.html]]></content>
      <categories>
        <category>python</category>
        <category>tips</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python 序列中出现次数最多的元素]]></title>
    <url>%2Fpython%2Ftips%2Fck0xy27my008tksv77j1fgyiq.html</url>
    <content type="text"><![CDATA[问题怎样找出一个序列中出现次数最多的元素呢？ 实现通过 collections.Counter 类来实现上述需求， 示例： 123456789101112131415&gt;&gt;&gt; from collections import Counter&gt;&gt;&gt; words = [ &apos;look&apos;, &apos;into&apos;, &apos;my&apos;, &apos;eyes&apos;, &apos;look&apos;, &apos;into&apos;, &apos;my&apos;, &apos;eyes&apos;, &apos;the&apos;, &apos;eyes&apos;, &apos;the&apos;, &apos;eyes&apos;, &apos;the&apos;, &apos;eyes&apos;, &apos;not&apos;, &apos;around&apos;, &apos;the&apos;, &apos;eyes&apos;, &quot;don&apos;t&quot;, &apos;look&apos;, &apos;around&apos;, &apos;the&apos;, &apos;eyes&apos;, &apos;look&apos;, &apos;into&apos;, &apos;my&apos;, &apos;eyes&apos;, &quot;you&apos;re&quot;, &apos;under&apos;]&gt;&gt;&gt; word_counts = Counter(words)&gt;&gt;&gt; word_countsCounter(&#123;&apos;eyes&apos;: 8, &apos;the&apos;: 5, &apos;look&apos;: 4, &apos;into&apos;: 3, &apos;my&apos;: 3, &apos;around&apos;: 2, &apos;not&apos;: 1, &quot;don&apos;t&quot;: 1, &quot;you&apos;re&quot;: 1, &apos;under&apos;: 1&#125;)# 出现频率最高的3个单词&gt;&gt;&gt; word_counts.most_common(3)[(&apos;eyes&apos;, 8), (&apos;the&apos;, 5), (&apos;look&apos;, 4)] 说明123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&gt;&gt;&gt; from collections import Counter# 统计words中单词出现频率&gt;&gt;&gt; word_counts = Counter(&apos;hello world&apos;)&gt;&gt;&gt; word_countsCounter(&#123;&apos;l&apos;: 3, &apos;o&apos;: 2, &apos;h&apos;: 1, &apos;e&apos;: 1, &apos; &apos;: 1, &apos;w&apos;: 1, &apos;r&apos;: 1, &apos;d&apos;: 1&#125;)# word_counts 示例中的方法&gt;&gt;&gt; dir(word_counts)[&apos;_keep_positive&apos;, &apos;clear&apos;, &apos;copy&apos;, &apos;elements&apos;, &apos;fromkeys&apos;, &apos;get&apos;, &apos;items&apos;, &apos;keys&apos;, &apos;most_common&apos;, &apos;pop&apos;, &apos;popitem&apos;, &apos;setdefault&apos;, &apos;subtract&apos;, &apos;update&apos;, &apos;values&apos;]# word_counts.copy() Return a shallow copy.&gt;&gt;&gt; word_counts.copy()Counter(&#123;&apos;l&apos;: 3, &apos;o&apos;: 2, &apos;h&apos;: 1, &apos;e&apos;: 1, &apos; &apos;: 1, &apos;w&apos;: 1, &apos;r&apos;: 1, &apos;d&apos;: 1&#125;)# word_counts.elements() Iterator over elements repeating each as many times as its count.&gt;&gt;&gt; word_counts.elements()&lt;itertools.chain object at 0x000002516523E5F8&gt;&gt;&gt;&gt; list(word_counts.elements())[&apos;h&apos;, &apos;e&apos;, &apos;l&apos;, &apos;l&apos;, &apos;l&apos;, &apos;o&apos;, &apos;o&apos;, &apos; &apos;, &apos;w&apos;, &apos;r&apos;, &apos;d&apos;]# word_counts.most_common(n=None) List the n most common elements and their counts from the most common to the least. If n is None, then list all element counts&gt;&gt;&gt; word_counts.most_common(n=2)[(&apos;l&apos;, 3), (&apos;o&apos;, 2)]# word_counts.subtract(*args, **kwds) Like dict.update() but subtracts counts instead of replacing them. Counts can be reduced below zero. Both the inputs and outputs are allowed to contain zero and negative counts.&gt;&gt;&gt; word_counts = Counter(&apos;hello world&apos;)&gt;&gt;&gt; word_counts.subtract(&apos;ll ooo&apos;)&gt;&gt;&gt; word_countsCounter(&#123;&apos;h&apos;: 1, &apos;e&apos;: 1, &apos;l&apos;: 1, &apos;w&apos;: 1, &apos;r&apos;: 1, &apos;d&apos;: 1, &apos;o&apos;: -1, &apos; &apos;: -1&#125;)# word_counts.update(*args, **kwds) Like dict.update() but add counts instead of replacing them.&gt;&gt;&gt; word_counts.update(&apos;ll ooo&apos;)&gt;&gt;&gt; word_countsCounter(&#123;&apos;l&apos;: 3, &apos;o&apos;: 2, &apos;h&apos;: 1, &apos;e&apos;: 1, &apos;w&apos;: 1, &apos;r&apos;: 1, &apos;d&apos;: 1, &apos; &apos;: 0&#125;)# word_counts.clear() Remove all items from D.# word_counts.get(key, default=None) Return the value for key if key is in the dictionary, else default.# word_counts.items() a set-like object providing a view on word_counts&apos;s items# word_counts.keys() a set-like object providing a view on word_counts&apos;s keys# word_counts.pop(k[,d]) v, remove specified key and return the corresponding value. If key is not found, d is returned if given, otherwise KeyError is raised# word_counts.popitem() (k, v), remove and return some (key, value) pair as a 2-tuple; but raise KeyError if word_counts is empty.# word_counts.etdefault(key, default=None) Insert key with a value of default if key is not in the dictionary. Return the value for key if key is in the dictionary, else default.# word_counts.values() an object providing a view on D&apos;s values]]></content>
      <categories>
        <category>python</category>
        <category>tips</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python 合并多个字典或映射]]></title>
    <url>%2Fpython%2Ftips%2Fck0xy27ml008nksv7ks3sfi3c.html</url>
    <content type="text"><![CDATA[问题现在有多个字典或者映射，你想将它们从逻辑上合并为一个单一的映射后执行某些操作， 比如查找值或者检查某些键是否存在。 实现通过 collections 模块中的 ChainMap 类来实现。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&gt;&gt;&gt; from collections import ChainMap&gt;&gt;&gt; a = &#123;&apos;x&apos;: 1, &apos;z&apos;: 3 &#125;&gt;&gt;&gt; b = &#123;&apos;y&apos;: 2, &apos;z&apos;: 4 &#125;&gt;&gt;&gt; merge = ChainMap(a, b) # merge 具有 dict 的一般特性， 可以用操作字典的方式操作它。&gt;&gt;&gt; maps = merge.maps[&#123;&apos;x&apos;: 1, &apos;z&apos;: 3&#125;, &#123;&apos;y&apos;: 2, &apos;z&apos;: 4&#125;]# 操作方法# 下述方法中 D is merge&gt;&gt;&gt; [x for x in dir(merge) if &apos;__&apos; not in x][&apos;_abc_impl&apos;, &apos;clear&apos;, &apos;copy&apos;, &apos;fromkeys&apos;, &apos;get&apos;, &apos;items&apos;, &apos;keys&apos;, &apos;maps&apos;, &apos;new_child&apos;, &apos;parents&apos;, &apos;pop&apos;, &apos;popitem&apos;, &apos;setdefault&apos;, &apos;update&apos;, &apos;values&apos;]# merge.clear() Clear maps[0], leaving maps[1:] intact.&gt;&gt;&gt; merge.clear()&gt;&gt;&gt; a&#123;&#125;&gt;&gt;&gt; b&#123;&apos;y&apos;: 2, &apos;z&apos;: 4&#125;&gt;&gt;&gt; mergeChainMap(&#123;&#125;, &#123;&apos;y&apos;: 2, &apos;z&apos;: 4&#125;)# merge.copy(self) New ChainMap or subclass with a new copy of maps[0] and refs to maps[1:]# merge.get(key, default=None) D.get(k[,d]) -&gt; D[k] if k in D, else d. d defaults to None.# merge.new_child(m=None) New ChainMap with a new map followed by all previous maps. If no map is provided, an empty dict is used.# merge.pop(key, *args) Remove *key* from maps[0] and return its value. Raise KeyError if *key* not in maps[0].# merge.popitem() Remove and return an item pair from maps[0]. Raise KeyError is maps[0] is empty.# merge.fromkeys(iterable, *args) from abc.ABCMeta Create a ChainMap with a single dict created from the iterable.# merge.parents New ChainMap from maps[1:].# merge.setdefault(key, default=None) D.setdefault(k[,d]) -&gt; D.get(k,d), also set D[k]=d if k not in D and add in maps[0]# merge.update(*args, **kwds) D.update([E, ]**F) -&gt; None. Update D from mapping/iterable E and F. If E present and has a .keys() method, does: for k in E: D[k] = E[k] If E present and lacks .keys() method, does: for (k, v) in E: D[k] = v In either case, this is followed by: for k, v in F.items(): D[k] = v# merge.items() D.items() -&gt; a set-like object providing a view on D&apos;s items# merge.keys() D.keys() -&gt; a set-like object providing a view on D&apos;s keys# merge.values() D.values() -&gt; an object providing a view on D&apos;s values 说明 一个 ChainMap 接受多个字典并将它们在逻辑上变为一个字典。这些字典并不是真的合并在一起了， ChainMap 类只是在内部创建了一个容纳这些字典的列表并重新定义了一些常见的字典操作来遍历这个列表。 如果出现重复键，那么第一次出现的映射值会被返回。 对于字典的更新或删除操作总是影响的是列表中第一个字典。 与 update() 方法将两个字典合并不同的是，ChainMap 使用原来的字典，它自己不创建新的字典。故原字典改变，ChainMap 创建的类字典也会跟着改变。]]></content>
      <categories>
        <category>python</category>
        <category>tips</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python 映射名称到序列元素]]></title>
    <url>%2Fpython%2Ftips%2Fck0xy27n5008wksv7wzt6khi9.html</url>
    <content type="text"><![CDATA[问题你有一段通过下标访问列表或者元组中元素的代码，但是这样有时候会使得你的代码难以阅读， 于是你想通过名称来访问元素。 实现通过 collections.namedtuple() 函数实现上述问题。 这个函数实际上是一个返回 Python 中标准元组类型子类的一个工厂方法。 你需要传递一个类型名和你需要的字段给它，然后它就会返回一个类，你可以初始化这个类，为你定义的字段传递值等。 代码示例： 123456789101112&gt;&gt;&gt; from collections import namedtuple&gt;&gt;&gt; Subscriber = namedtuple(&apos;Subscriber&apos;, [&apos;addr&apos;, &apos;joined&apos;])&gt;&gt;&gt; sub = Subscriber(&apos;jonesy@example.com&apos;, &apos;2012-10-19&apos;)&gt;&gt;&gt; subSubscriber(addr=&apos;jonesy@example.com&apos;, joined=&apos;2012-10-19&apos;)&gt;&gt;&gt; sub.addr&apos;jonesy@example.com&apos;&gt;&gt;&gt; sub.joined&apos;2012-10-19&apos;注：尽管 namedtuple 的实例看起来像一个普通的类实例，但是它跟元组类型是可交换的，支持所有的普通元组操作，比如索引和解压。 说明123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&gt;&gt;&gt; from collections import namedtuple&gt;&gt;&gt; Subscriber = namedtuple(&apos;Subscriber&apos;, [&apos;addr&apos;, &apos;joined&apos;])&gt;&gt;&gt; sub = Subscriber(&apos;jonesy@example.com&apos;, &apos;2012-10-19&apos;)&gt;&gt;&gt; subSubscriber(addr=&apos;jonesy@example.com&apos;, joined=&apos;2012-10-19&apos;)# 实例方法&gt;&gt;&gt; [x for x in dir(sub) if &quot;__&quot; not in x][&apos;_asdict&apos;, &apos;_fields&apos;, &apos;_fields_defaults&apos;, &apos;_make&apos;, &apos;_replace&apos;, &apos;addr&apos;, &apos;count&apos;, &apos;index&apos;, &apos;joined&apos;]# sub._asdict() Return a new OrderedDict which maps field names to their values.&gt;&gt;&gt; sub._asdict()OrderedDict([(&apos;addr&apos;, &apos;jonesy@example.com&apos;), (&apos;joined&apos;, &apos;2012-10-19&apos;)])# sub._fields Return a fileds&gt;&gt;&gt; sub._fields(&apos;addr&apos;, &apos;joined&apos;)# _replace(_self, **kwds) Return a new Subscriber object replacing specified fields with new values&gt;&gt;&gt; sub._replace(joined=&apos;2018-10-10&apos;)Subscriber(addr=&apos;jonesy@example.com&apos;, joined=&apos;2018-10-10&apos;)# _make(iterable) from builtins.type Make a new Subscriber object from a sequence or iterable&gt;&gt;&gt; sub._make((&apos;xiai@qq.com&apos;, &apos;2018-10-11&apos;))Subscriber(addr=&apos;xiai@qq.com&apos;, joined=&apos;2018-10-11&apos;)# addr Alias for field number 0&gt;&gt;&gt; sub.addr&apos;jonesy@example.com&apos;# joined Alias for field number 1&gt;&gt;&gt; sub.joined&apos;2012-10-19&apos;# count(self, value, /) Return number of occurrences of value.# index(self, value, start=0, stop=9223372036854775807, /) Return first index of value. Raises ValueError if the value is not present.]]></content>
      <categories>
        <category>python</category>
        <category>tips</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python import 原理]]></title>
    <url>%2Fpython%2Fck0xy275n0047ksv7c0le65vm.html</url>
    <content type="text"><![CDATA[本文测试环境为python3。这里先简单介绍下与 import 导入相关的概念。 前期铺垫python module （python 模块） module 定义 是一个以 .py、.pyo、.pyc、.pyd、.so、.dll等结尾的文件； 文件内包含了Python定义的变量、函数、类和及其它可执行语句。 module 来源 Python内置的模块（标准库） 第三方模块 自定义模块 module 使用 当做脚本直接运行 12345678910111213141516171819# test_script.py#!/usr/bin/python3def func(): print(&quot;Hi, I am function&quot;)class TestClass(object): def func(self): print(&quot;Hi, I am class&quot;)if __name__ == &quot;__main__&quot;: func() TestClass().func()[root@hadoop-centos-01 python_exm]# python test_script.pyHi, I am functionHi, I am class 导入其它模块 以上述test.py模块为例 123456&gt;&gt;&gt; import test_script&gt;&gt;&gt; test_script.func()Hi, I am function&gt;&gt;&gt; test_script.TestClass().func()Hi, I am class 123456&gt;&gt;&gt; from test_script import func, TestClass&gt;&gt;&gt; func()Hi, I am function&gt;&gt;&gt; TestClass().func()Hi, I am class 注：若发生导包错误，如下： 1234&gt;&gt;&gt; import test_scriptTraceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;ModuleNotFoundError: No module named &apos;test_script&apos; 需添加当前脚本的路径到 sys.path中，如下： 123456789&gt;&gt;&gt; import sys&gt;&gt;&gt; sys.path.append(&apos;/opt/test/python_exm&apos;)# 重新导入，无错误产生&gt;&gt;&gt; import test_script&gt;&gt;&gt; dir(test_script)[&apos;TestClass&apos;, &apos;__builtins__&apos;, &apos;__cached__&apos;, &apos;__doc__&apos;, &apos;__file__&apos;, &apos;__loader__&apos;, &apos;__name__&apos;, &apos;__package__&apos;, &apos;__spec__&apos;, &apos;func&apos;]注：sys.path是python的搜索模块的路径集，其为一个list python package （python 包） package 定义 是一个包含了 __init__.py 文件的文件夹; __init __.py 文件用于组织包（package），方便管理各个模块之间的引用、控制着包的导入行为; __init __.py 文件可以为空，但必须存在； __init __.py 文件在包被导入时会自动运行 所有的包都是模块，但并非所有模块都是包。 或者换句话说，包只是一种特殊的模块。任何具有 __path__ 属性的模块都会被当作是包。 示例： 12345678910test_package/├── __init__.py├── pack1│ ├── __init__.py│ ├── mod1.py│ └── mod2.py└── pack2 ├── __init__.py ├── mod1.py └── mod2.py package 导入 123import test_package注：通过此种方式导入包，其实际是运行了 __init__.py 文件， 故将需要导入的模块导入到 __init__.py 文件即可 1from test_package import pack1, pack2 命名空间 定义 名称到对象的映射。 命名空间是一个字典的实现，键为变量名，值是变量对应的值。 各个命名空间是独立没有关系的，一个命名空间中不能有重名，但是不同的命名空间可以重名而没有任何影响。 分类 局部命名空间（Local Namespace），函数运行时创建，记录了函数中定义的所有变量，包括函数的入参、内部定义的局部变量。 全局命名空间（Global Namespace），每个模块加载时创建，记录了模块中定义的变量，包括模块中定义的函数、类、其他导入的模块、模块级的变量与常量。 内建命名空间（Built-in Namespace ），任何模块均可以访问，放着内置的函数和异常。 生命周期 Local Namespace 在函数被调用时创建，结束时销毁。 Global Namespace 在模块被加载时创建，通常一直保留直到python解释器退出。 Built-inNamespace 在python解释器启动时创建，一直保留直到解释器退出。 创建顺序 内建命名空间 -&gt; 全局命名空间 -&gt; 局部命名空间 销毁顺序 局部命名空间 -&gt; 全局命名空间 -&gt; 内建命名空间 变量查找顺序 局部命名空间 -&gt; 全局命名空间 -&gt; 内建命名空间 若在这些命名空间找不到相关变量，Python会放弃查找并且引发一个NameError异常 访问 局部命名空间可以通过 locals() 访问 locals()返回一个键/值的dict，键为变量名字（str形式），值为该变量的实际值 全局命名空间可以用 globals() 访问 注： 123456781. 模块的命名空间不仅包括模块的常量和变量，还包括模块中定义的函数和类。此外还包括，任何被导入模块中的东西。2. 内置命名同样放置在一个模块中，被称作builtins3. from module import function 和import module不同 使用import module,模块被导入，但是它仍保持自己的命名空间，所以需要模块名来访问函数或者属性（例如module.function）； 使用from module import function ，实际上是直接从另一个模块中导入相关属性或函数，因此可以直接访问而不需要知道它们的来源。使用globals函数可以实现。4. locals是只读的(不能改变)，globals不是（可以改变） locals没有返回局部命名空间，它返回的是一个拷贝。所以对它进行改变，对局部命名空间中的变量值没有影响 globals返回全部实际命名空间，而非拷贝。所以globals返回的dict任何改动都会影响到全局变量 作用域 定义 访问变量时所查找的区域，python中作用域规则可以简单的归纳为LEGB原则： 1234L：local，局部作用域，即函数中定义的变量；E：enclosing，外部嵌套函数作用域，即包含此函数的上级函数的局部作用域，但不是全局的；G：global，全局作用域，就是模块级别定义的变量；B：built-in，内建作用域，系统固定模块里面的变量，比如：int，bytearray等 查找顺序 局部作用域 -&gt;外部嵌套函数作用域 -&gt; 全局作用域 -&gt; 内建作用域，即 L -&gt; E -&gt; G -&gt; B global 关键字 global 关键字用来在函数或其他局部作用域中使用全局变量。如果不修改全局变量，根据变量查找规则，也可以不使用global关键字。 123456789101112131415#!/usr/bin/env python3gloabl_var = 1def func1(): print(gloal_var) # 若不修改全局变量，可直接使用 def func2(): global gloabl_var gloabl_var += 1 print(gloabl_var)if __name__ == &quot;__main__&quot;: func1() # 1 func2() # 2 global 关键字用来在函数或其他局部作用域中声明全局变量。 1234567891011#!/usr/bin/env python3 def func(): global gloabl_var # 声明的全局变量可在全局命名空间内使用 gloabl_var = 1 print(gloabl_var) print(gloabl_var) # 1if __name__ == &quot;__main__&quot;： func() nonlocal关键字 nonlocal 关键字用来在函数或其他作用域中使用外层(非全局)变量。 123456789101112#!/usr/bin/env python3def func(): count = 0 def counter(): nonlocal count count += 1 return count return counter if __name__ == &quot;__main__&quot;: func()() # 1 注：Python 中只有模块（module），类（class）以及函数（def、lambda）才会引入新的作用域，其它的代码块（如 if ~ elif ~ else、try ~ except、for ~ else 、while ~ else等）是不会引入新的作用域的，故在这些语句内定义的变量，外部也可以访问。 import 导入Python import 搜索路径1. 在当前目录下搜索该模块 2. python安装目录，UNIX下，默认路径一般为/usr/local/lib/python/ 3. 在 Python 安装路径的 lib 库中搜索 4. python3.x 中.pth 文件内容注：import 搜索路径是按照 sys.path中的路径列表来搜索的。 12345&gt;&gt;&gt; import sys&gt;&gt;&gt; sys.path[&apos;&apos;, &apos;/usr/local/python2/lib/python27.zip&apos;, &apos;/usr/local/python2/lib/python2.7&apos;, &apos;/usr/local/python2/lib/python2.7/plat-linux2&apos;, &apos;/usr/local/python2/lib/python2.7/lib-tk&apos;, &apos;/usr/local/python2/lib/python2.7/lib-old&apos;, &apos;/usr/local/python2/lib/python2.7/lib-dynload&apos;, &apos;/usr/local/python2/lib/python2.7/site-packages&apos;, &apos;/usr/local/python2/lib/python2.7/site-packages/setuptools-41.0.1-py2.7.egg&apos;, &apos;/usr/local/python2/lib/python2.7/site-packages/pip-19.1.1-py2.7.egg&apos;]# sys.path 是一个list, 第一项为一个空字符串，代表当前目录，可通过 os.getcwd() 查看当前所在目录。 Python import 导入步骤​ python 所有加载的模块信息都存放在 sys.modules结构中，当 import 一个模块时，会按如下步骤来进行： 如果是 import A，检查 sys.modules中是否已经有 A，如果有则不加载，如果没有则为 A 创建 module 对象，并加载 A 到 sys.modules 中 如果是 from A import B，先为 A 创建 module 对象，再解析A，从中寻找B并填充到 A 的 __dict__中 Python import 导入方式Python 相对导入与绝对导入是相对于包内导入而言的。所谓包内导入是指包内的模块导入包内部的模块。 绝对导入 12345import A.B 或 from A import B注：module A的路径应在 sys.path 列表中，否则会引发 ModuleNotFoundError 异常 相对导入 123456from . import B 或 from ..A import B注：.代表当前模块，..代表上层模块，...代表上上层模块，依次类推。 相对导入时不能超过包的顶层，即不能导入包以外的模块或包 注： Python2.x 缺省为相对路径导入，Python3.x 缺省为绝对路径导入。 相对导入可以避免硬编码带来的维护问题，例如我们改了某一顶层包的名，那么其子包所有的导入就都不能用了。 绝对导入可以避免导入子包覆盖掉标准库模块（由于名字相同，发生冲突）。如果在 Python2.x 中要默认使用绝对导入，可以在文件开头加入如下语句： 1from__future__ import absolute_import Python 导包异常处理 示例： 1234567891011121314151617181920212223242526272829303132333435363738test_package/├── __init__.py├── pack1│ ├── __init__.py│ ├── mod1.py│ └── mod2.py└── pack2 ├── __init__.py ├── mod1.py └── mod2.py# 在根目录下的 __init__.py 文件写入下列语句 import test_package.pack1 import test_package.pack2 在使用 import test_package 导入包时，可自行导入 pack1 和 pack2 两个包， &gt;&gt;&gt; import test_package &gt;&gt;&gt; dir(test_package) [&apos;__builtins__&apos;, &apos;__cached__&apos;, &apos;__doc__&apos;, &apos;__file__&apos;, &apos;__loader__&apos;, &apos;__name__&apos;, &apos;__package__&apos;, &apos;__path__&apos;, &apos;__spec__&apos;, &apos;pack1&apos;, &apos;pack2&apos;, &apos;test_package&apos;]# 在pack1 __init__.py 文件写入下列语句 import test_package.pack1.mod1 import test_package.pack1.mod2 在使用 from test_package import pack1 导入包时，可自行导入 pack1 包下的 mod1 和 mod2 模块 &gt;&gt;&gt; from test_package import pack1 &gt;&gt;&gt; dir(pack1) [&apos;__builtins__&apos;, &apos;__cached__&apos;, &apos;__doc__&apos;, &apos;__file__&apos;, &apos;__loader__&apos;, &apos;__name__&apos;, &apos;__package__&apos;, &apos;__path__&apos;, &apos;__spec__&apos;, &apos;mod1&apos;, &apos;mod2&apos;, &apos;test_package&apos;]# 在pack2 __init__.py 文件写入下列语句 from test_package.pack1.mod1 import pack1_func_1 from test_package.pack1.mod2 import pack1_func_2 在使用 from test_package import pack2 导入包时，可自行导入 pack2 包下的 mod1 和 mod2 模块中的pack1_func_1 和 pack1_func_2 函数 &gt;&gt;&gt; from test_package import pack1 &gt;&gt;&gt; dir(pack1) [&apos;__builtins__&apos;, &apos;__cached__&apos;, &apos;__doc__&apos;, &apos;__file__&apos;, &apos;__loader__&apos;, &apos;__name__&apos;, &apos;__package__&apos;, &apos;__path__&apos;, &apos;__spec__&apos;, &apos;mod1&apos;, &apos;mod2&apos;, &apos;pack1_func_1&apos;, &apos;pack1_func_2&apos;] 错误处理 ModuleNotFoundError: No module named ‘test_package’ 1234&gt;&gt;&gt; import test_packageTraceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;ModuleNotFoundError: No module named &apos;test_package&apos; ModuleNotFoundError 异常是由于找不到 test_package 包的路径造成的，解决方法： 在 sys.path中添加 test_package包所在的路径 12345try: import test_packageexcep ModuleNotFoundError: import sys sys.path.append(&apos;path&apos;) # path 为test_package所在的路径 将 test_package包所在的路径添加到PYTHONPATH环境变量中 12345cd ~;vim .bashrcexport PYTHONPATH=&apos;path&apos; # path为test_package所在的路径# 保存退出，并重新激活 source .bashrc ValueError: attempted relative import beyond top-level package 123456# 在pack2下的mod1.py通过 from ..pack1 import mod1 的方式导入pack1下的mod1， 并执行pack2下的mod1.py[root@hadoop-centos-01 pack2]# python3 mod1.pyTraceback (most recent call last): File &quot;mod1.py&quot;, line 3, in &lt;module&gt; from ..pack1 import mod1ValueError: attempted relative import beyond top-level package 处理方法参考： https://blog.csdn.net/sky453589103/article/details/78863050 Reference命名空间： ​ https://www.cnblogs.com/windlaughing/archive/2013/05/26/3100362.html ​ https://www.cnblogs.com/zhangxinhe/p/6963462.html 相对导入和绝对导入： ​ https://www.jb51.net/article/102252.htm ​ https://blog.csdn.net/weixin_38256474/article/details/81228492 ​ https://blog.csdn.net/gaifuxi9518/article/details/81038818]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python 删除序列相同元素并保持顺序]]></title>
    <url>%2Fpython%2Ftips%2Fck0xy27m2008hksv7m8nkabqv.html</url>
    <content type="text"><![CDATA[问题怎样在一个序列上面保持元素顺序的同时消除重复的值？ 实现 如果序列上的值都是 hashable 类型，那么可以很简单的利用集合或者生成器来解决这个问题。比如： 12345678910def dedupe(items): seen = set() for item in items: if item not in seen: yield item seen.add(item)&gt;&gt;&gt; a = [1, 5, 2, 1, 9, 1, 5, 10]&gt;&gt;&gt; list(dedupe(a))[1, 5, 2, 9, 10] 如果序列上的值是不可 hashable 类型 123456789101112131415def dedupe(items, key=None): seen = set() for item in items: val = item if key is None else key(item) if val not in seen: yield item seen.add(val) &gt;&gt;&gt; a = [ &#123;&apos;x&apos;:1, &apos;y&apos;:2&#125;, &#123;&apos;x&apos;:1, &apos;y&apos;:3&#125;, &#123;&apos;x&apos;:1, &apos;y&apos;:2&#125;, &#123;&apos;x&apos;:2, &apos;y&apos;:4&#125;]&gt;&gt;&gt; list(dedupe(a, key=lambda d: (d[&apos;x&apos;],d[&apos;y&apos;])))[&#123;&apos;x&apos;: 1, &apos;y&apos;: 2&#125;, &#123;&apos;x&apos;: 1, &apos;y&apos;: 3&#125;, &#123;&apos;x&apos;: 2, &apos;y&apos;: 4&#125;]&gt;&gt;&gt; list(dedupe(a, key=lambda d: d[&apos;x&apos;]))[&#123;&apos;x&apos;: 1, &apos;y&apos;: 2&#125;, &#123;&apos;x&apos;: 2, &apos;y&apos;: 4&#125;]注：key参数指定了一个函数，将序列元素转换成 hashable 类型]]></content>
      <categories>
        <category>python</category>
        <category>tips</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python zip 与 dict]]></title>
    <url>%2Fpython%2Ftips%2Fck0xy27lj008aksv7jafolceu.html</url>
    <content type="text"><![CDATA[zip 实现字典求最大值、最小值、排序等 123456789101112131415161718192021222324252627282930&gt;&gt;&gt; prices = &#123; &apos;ACME&apos;: 45.23, &apos;AAPL&apos;: 612.78, &apos;IBM&apos;: 205.55, &apos;HPQ&apos;: 37.20, &apos;FB&apos;: 10.75&#125;# dict value min, return v, k&gt;&gt;&gt; min(zip(prices.values(), prices.keys()))(10.75, &apos;FB&apos;)# dict value min max, return v, k&gt;&gt;&gt; min(zip(prices.values(), prices.keys()))(10.75, &apos;FB&apos;)# sorted by dict value&gt;&gt;&gt; sorted(zip(prices.values(), prices.keys()))[(10.75, &apos;FB&apos;), (37.2, &apos;HPQ&apos;), (45.23, &apos;ACME&apos;), (205.55, &apos;IBM&apos;), (612.78, &apos;AAPL&apos;)]注：zip() 函数创建的是一个迭代器，只能访问一次。# 在计算操作中使用到了 (值，键) 对。# 当多个实体拥有相同的值的时候，键会决定返回结果。 # 比如，在执行 min() 和 max() 操作的时候，如果恰巧最小或最大值有重复的，那么拥有最小或最大键的实体会返回&gt;&gt;&gt; prices = &#123; &apos;AAA&apos; : 45.23, &apos;ZZZ&apos;: 45.23 &#125;&gt;&gt;&gt; min(zip(prices.values(), prices.keys()))(45.23, &apos;AAA&apos;)&gt;&gt;&gt; max(zip(prices.values(), prices.keys()))(45.23, &apos;ZZZ&apos;)]]></content>
      <categories>
        <category>python</category>
        <category>tips</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python 字典中的键映射多个值]]></title>
    <url>%2Fpython%2Ftips%2Fck0xy27mb008kksv7od2x4ky6.html</url>
    <content type="text"><![CDATA[问题实现一个键对应多个值的字典 实现一个字典就是一个键对应一个单值的映射。如果想要一个键映射多个值，那么就需要将这多个值放到另外的容器中， 比如列表或者集合里面。根据不同的需求选择不同的容器。 collections 模块中的 defaultdict 可以很方便的实现上述需求。 123456789101112131415&gt;&gt;&gt; from collections import defaultdict # defualt list&gt;&gt;&gt; d[&apos;a&apos;].append(&apos;1&apos;)&gt;&gt;&gt; ddefaultdict(&lt;class &apos;list&apos;&gt;, &#123;&apos;a&apos;: [&apos;1&apos;]&#125;)&gt;&gt;&gt; d[&apos;a&apos;].append(&apos;2&apos;)&gt;&gt;&gt; ddefaultdict(&lt;class &apos;list&apos;&gt;, &#123;&apos;a&apos;: [&apos;1&apos;, &apos;2&apos;]&#125;)# defualt tuple&gt;&gt;&gt; d = defaultdict(tuple)&gt;&gt;&gt; d[1] += (1, 2)&gt;&gt;&gt; ddefaultdict(&lt;class &apos;tuple&apos;&gt;, &#123;1: (1, 2)&#125;) 1234567&gt;&gt;&gt; d = &#123;&#125;&gt;&gt;&gt; d.setdefault(&apos;a&apos;, []).append(1)&gt;&gt;&gt; d&#123;&apos;a&apos;: [1]&#125;&gt;&gt;&gt; d.setdefault(&apos;a&apos;, []).append(2)&gt;&gt;&gt; d&#123;&apos;a&apos;: [1, 2]&#125;]]></content>
      <categories>
        <category>python</category>
        <category>tips</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python heapq module]]></title>
    <url>%2Fpython%2Fmodule%2Fck0xy27ep005cksv7iqm9qzqk.html</url>
    <content type="text"><![CDATA[简介Python提供的关于堆的操作模块。 源码：Lib/heapq.py Python 提供的是基于小顶堆的操作，因此 Python 可以对 list 中的元素进行小顶堆排列，这样程序每次获取堆中元素时，总会取得堆中最小的元素。 有关堆的介绍：传送门 用法 heapq 模块包含的方法 123&gt;&gt;&gt; import heapq&gt;&gt;&gt; heapq.__all__[&apos;heappush&apos;, &apos;heappop&apos;, &apos;heapify&apos;, &apos;heapreplace&apos;, &apos;merge&apos;, &apos;nlargest&apos;, &apos;nsmallest&apos;, &apos;heappushpop&apos;] 用法 123456heap = [] # creates an empty heapheappush(heap, item) # pushes a new item on the heapitem = heappop(heap) # pops the smallest item from the heapitem = heap[0] # smallest item on the heap without popping itheapify(x) # transforms list into a heap, in-place, in linear timeitem = heapreplace(heap, item) # pops and returns smallest item, and adds new item; the heap size is unchanged 示例 创建一个堆 1234567891011121314&gt;&gt;&gt; import heapq# 创建一个堆# 方法一: 创建一个空的列表，然后向里面添加元素&gt;&gt;&gt; heap = []&gt;&gt;&gt; heapq.heappush(heap, 5)&gt;&gt;&gt; heap[5]# 方法二：将非空列表堆化&gt;&gt;&gt; heap = [7, 1, 2, 8, 6, 9, 10]&gt;&gt;&gt; heapq.heapify(heap)&gt;&gt;&gt; heap[0]1 方法使用 heapq.heapify(x)将list x 转换成堆。 1234&gt;&gt;&gt; import heapq&gt;&gt;&gt; heap = [7, 1, 2, 8, 6, 9, 10]&gt;&gt;&gt; heapq.heapify(heap) heapq.heappush(heap, item)将item的值加入 heap 中，保持堆的不变性。 123&gt;&gt;&gt; heapq.heappush(heap, -5)&gt;&gt;&gt; heap[-5, 1, 2, 6, 7, 9, 10, 8] heapq.heappop(heap)弹出并返回 heap 的最小的元素，保持堆的不变性。 如果堆为空，抛出 IndexError 。 使用 heap[0] ，可以只访问最小的元素而不弹出它。 1234&gt;&gt;&gt; heapq.heappop(heap)-5&gt;&gt;&gt; heap[1, 5, 2, 6, 7, 9, 10, 8] heapq.heappushpop(heap, item)将 item 放入堆中，然后弹出并返回 heap 的最小元素。 该组合操作比先调用 heappush() 再调用 heappop() 运行起来更有效率。 1234&gt;&gt;&gt; heapq.heappushpop(heap, 3) 1&gt;&gt;&gt; heap[2, 5, 3, 6, 7, 9, 10, 8] heapq.heapreplace(heap, item)弹出并从堆中返回最小的项，然后将 item 放入堆中。如果堆是空的，则引发 IndexError。该组合操作先调用 heappop() 在调用 heappush() 更有效。 注：返回的值可能大于添加的项。如果不希望这样，可以用 heapq.heappushpop()。 1234&gt;&gt;&gt; heapq.heapreplace(heap, -2) 2&gt;&gt;&gt; heap[-2, 5, 3, 6, 7, 9, 10, 8] heapq.merge(*iterables, key=None, reverse=False)将多个有序的输入（从小到大排序）合并到一个有序的输出中。返回已排序值的迭代器。 key：比较函数，该参数用于从每个输入元素中提取一个比较键。默认值是None(直接比较元素)。reverse：布尔值。如果设置为True，要实现逆序排列，所有的iterables都必须从大到小排序 1234567891011# 从小到大排序&gt;&gt;&gt; a = [1, 3, 5] &gt;&gt;&gt; b = [2, 4, 6] &gt;&gt;&gt; list(heapq.merge(a, b)) [1, 2, 3, 4, 5, 6]# 从大到下排序&gt;&gt;&gt; a = [5, 3, 1] &gt;&gt;&gt; b = [6, 4, 2]&gt;&gt;&gt; list(heapq.merge(a, b, reverse=True))[6, 5, 4, 3, 2, 1] heapq.nlargest(n, iterable, key=None)从iterable定义的数据集中返回一个包含n个最大元素的列表。 key: 比较函数，该参数用于从iterable中的每个元素中提取一个比较键 等价于: sordered (iterable, key=key, reverse=True)[:n] 12345678&gt;&gt;&gt; import heapq&gt;&gt;&gt; heap = [7, 1, 2, 8, 6, 9, 10] &gt;&gt;&gt; heapq.nlargest(2, heap)[10, 9]&gt;&gt;&gt; heapq.nsmallest(2, heap) [1, 2] heapq.nsmallest(n, iterable, key=None)从iterable定义的数据集中返回一个包含n个最小元素的列表。 key: 比较函数，该参数用于从iterable中的每个元素中提取一个比较键 等价于: sordered (iterable, key=key)[:n] 12345&gt;&gt;&gt; import heapq&gt;&gt;&gt; heap = [7, 1, 2, 8, 6, 9, 10]&gt;&gt;&gt; heapq.nsmallest(2, heap)[1, 2]]]></content>
      <categories>
        <category>python</category>
        <category>module</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>module</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python 实现一个优先级队列]]></title>
    <url>%2Fpython%2Ftips%2Fck0xy27lr008cksv7wii7unwa.html</url>
    <content type="text"><![CDATA[实现一个优先级队列 问题 怎样实现一个按优先级排序的队列？ 并且在这个队列上面每次 pop 操作总是返回优先级最高的那个元素 实现 123456789101112131415161718import heapqclass PriorityQueue(object): def __init__(self): self._queue = [] self._index = 0 def push(self, itme, priority): heapq.heappush(self._queue, (-priority, self._index, item)) self._index += 1 def pop(self): heapq.heappop(self._queue)[-1] 注： 由于 push 和 pop 操作时间复杂度为 O(log N)，其中 N 是堆的大小，因此就算是 N 很大的时候它们运行速度也依旧很快； 优先级为负数的目的是使得元素按照优先级从高到低排序。 这个跟普通的按优先级从低到高排序的堆排序恰巧相反。 index 变量的作用是保证同等优先级元素的正确排序。 注：heapq 为python处理堆数据结构的一个模块，用法参考： [python heapq module] https://forgetst.github.io/2019/09/01/python-module-heapq/ Reference&emsp;&emsp;https://python3-cookbook.readthedocs.io/zh_CN/latest/index.html]]></content>
      <categories>
        <category>python</category>
        <category>tips</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python 实现一个顺序字典]]></title>
    <url>%2Fpython%2Ftips%2Fck0xy27mt008qksv7p2e1wolh.html</url>
    <content type="text"><![CDATA[问题你想创建一个字典，并且在迭代或序列化这个字典的时候能够控制元素的顺序。 实现通过 collections 模块中的 OrderedDict 类，可生成一个保持元素被插入时的顺序的字典，示例如下： 12345678910111213141516&gt;&gt;&gt; from collections import OrderedDict&gt;&gt;&gt; d = OrderedDict()&gt;&gt;&gt; d[&apos;foo&apos;] = 1&gt;&gt;&gt; d[&apos;bar&apos;] = 2&gt;&gt;&gt; d[&apos;spam&apos;] = 3&gt;&gt;&gt; d[&apos;grok&apos;] = 4# Outputs &gt;&gt;&gt; for k, v in d.items(): print(&apos;%s --&gt; %s&apos; % (k, v))foo --&gt; 1bar --&gt; 2spam --&gt; 3grok --&gt; 4 当你想要构建一个将来需要序列化或编码成其他格式的映射的时候， OrderedDict 是非常有用的。 比如，你想精确控制以 JSON 编码后字段的顺序，你可以先使用 OrderedDict 来构建这样的数据： 1234&gt;&gt;&gt; import json&gt;&gt;&gt; json.dumps(d)&apos;&#123;&quot;foo&quot;: 1, &quot;bar&quot;: 2, &quot;spam&quot;: 3, &quot;grok&quot;: 4&#125;&apos; 讨论OrderedDict 内部维护着一个根据键插入顺序排序的双向链表。每次当一个新的元素插入进来的时候， 它会被放到链表的尾部。对于一个已经存在的键的重复赋值不会改变键的顺序。 需要注意的是，一个 OrderedDict 的大小是一个普通字典的两倍，因为它内部维护着另外一个链表。 所以如果你要构建一个需要大量 OrderedDict 实例的数据结构的时候（比如读取 100,000 行 CSV 数据到一个 OrderedDict 列表中去）， 那么你就得仔细权衡一下是否使用 OrderedDict 带来的好处要大过额外内存消耗的影响。 Referencehttps://python3-cookbook.readthedocs.io/zh_CN/latest/c01/p07_keep_dict_in_order.html]]></content>
      <categories>
        <category>python</category>
        <category>tips</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The Python 魔法方法]]></title>
    <url>%2Fpython%2Fck0xy275s0049ksv75y4yf8cy.html</url>
    <content type="text"><![CDATA[魔法方法，也叫做特殊方法，是指名称前面和后面都加上了双下划线的方法。 对python而言，下划线对解释器有特殊的意义，而且是内建标识符所使用的符号，故应慎用下划线开始的变量名。 python中，变量以单下划线和双下划线开始，有不同的含义： “单下划线” 开始的成员变量叫做保护变量，意思是只有类对象和子类对象自己能访问到这些变量； “双下划线” 开始的是私有成员，意思是只有类对象自己能访问，连子类对象也不能访问到这个数据。 基本属性1234567891011121314&gt;&gt;&gt; class TestClass(object): &apos;&apos;&apos;This is test class&apos;&apos;&apos; # 类属性&gt;&gt;&gt; TestClass.__doc__ # 查看类型帮助信息， &apos;This is test class&apos;&gt;&gt;&gt; TestClass.__name__ # 查看类型名称， &apos;TestClass&apos;&gt;&gt;&gt; TestClass.__module__ # 查看类型所在模块， &apos;__main__&apos;&gt;&gt;&gt; TestClass.__bases__ # 查看类型所继承的基类， (&lt;type &apos;object&apos;&gt;,) &gt;&gt;&gt; TestClass.__dict__ # 查看类型字典，存储所有类型成员信息。 # 实例属性&gt;&gt;&gt; TestClass().__class__ # 类型 &lt;class &apos;__main__.Class1&apos;&gt; &gt;&gt;&gt; TestClass().__module__ # 实例类型所在模块 &apos;__main__&apos; &gt;&gt;&gt; TestClass().__dict__ # 对象字典，存储所有实例成员信息。 &#123;&apos;i&apos;: 1234&#125; 基本方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119__new__(cls[, ...]) new 是在一个对象实例化的时候所调用的第一个方法 它的第一个参数是这个类，其他的参数是用来直接传递给 init 方法 new 决定是否要使用该 init 方法，因为 new 可以调用其他类的构造方法或者直接返回别的实例对象来作为本类的实例，如果 new 没有返回实例对象，则 init 不会被调用 new 主要是用于继承一个不可变的类型比如一个 tuple 或者 string__init__(self[, ...]) 构造器，当一个实例被创建的时候调用的初始化方法__del__(self) 析构器，当一个实例被销毁的时候调用的方法__call__(self[, args...]) 允许一个类的实例像函数一样被调用：x(a, b) 调用 x.__call__(a, b)__len__(self) 定义当被 len() 调用时的行为__repr__(self) 定义当被 repr() 调用时的行为__str__(self) 定义当被 str() 调用时的行为 类似于Java中toString方法__bytes__(self) 定义当被 bytes() 调用时的行为__hash__(self) 定义当被 hash() 调用时的行为__bool__(self) 定义当被 bool() 调用时的行为，应该返回 True 或 False__format__(self, format_spec) 定义当被 format() 调用时的行为有关属性__getattr__(self, name) 定义当用户试图获取一个不存在的属性时的行为__getattribute__(self, name) 定义当该类的属性被访问时的行为__setattr__(self, name, value) 定义当一个属性被设置时的行为__delattr__(self, name) 定义当一个属性被删除时的行为__dir__(self) 定义当 dir() 被调用时的行为__get__(self, instance, owner) 定义当描述符的值被取得时的行为__set__(self, instance, value) 定义当描述符的值被改变时的行为__delete__(self, instance) 定义当描述符的值被删除时的行为比较操作符__lt__(self, other) 定义小于号的行为：x &lt; y 调用 x.__lt__(y)__le__(self, other) 定义小于等于号的行为：x &lt;= y 调用 x.__le__(y)__eq__(self, other) 定义等于号的行为：x == y 调用 x.__eq__(y)__ne__(self, other) 定义不等号的行为：x != y 调用 x.__ne__(y)__gt__(self, other) 定义大于号的行为：x &gt; y 调用 x.__gt__(y)__ge__(self, other) 定义大于等于号的行为：x &gt;= y 调用 x.__ge__(y)算数运算符__add__(self, other) 定义加法的行为：+__sub__(self, other) 定义减法的行为：-__mul__(self, other) 定义乘法的行为：*__truediv__(self, other) 定义真除法的行为：/__floordiv__(self, other) 定义整数除法的行为：//__mod__(self, other) 定义取模算法的行为：%__divmod__(self, other) 定义当被 divmod() 调用时的行为__pow__(self, other[, modulo]) 定义当被 power() 调用或 ** 运算时的行为__lshift__(self, other) 定义按位左移位的行为：&lt;&lt;__rshift__(self, other) 定义按位右移位的行为：&gt;&gt;__and__(self, other) 定义按位与操作的行为：&amp;__xor__(self, other) 定义按位异或操作的行为：^__or__(self, other) 定义按位或操作的行为：|反运算__radd__(self, other) （与上方相同，当左操作数不支持相应的操作时被调用）__rsub__(self, other) （与上方相同，当左操作数不支持相应的操作时被调用）__rmul__(self, other) （与上方相同，当左操作数不支持相应的操作时被调用）__rtruediv__(self, other) （与上方相同，当左操作数不支持相应的操作时被调用）__rfloordiv__(self, other) （与上方相同，当左操作数不支持相应的操作时被调用）__rmod__(self, other) （与上方相同，当左操作数不支持相应的操作时被调用）__rdivmod__(self, other) （与上方相同，当左操作数不支持相应的操作时被调用）__rpow__(self, other) （与上方相同，当左操作数不支持相应的操作时被调用）__rlshift__(self, other) （与上方相同，当左操作数不支持相应的操作时被调用）__rrshift__(self, other) （与上方相同，当左操作数不支持相应的操作时被调用）__rxor__(self, other) （与上方相同，当左操作数不支持相应的操作时被调用）__ror__(self, other) （与上方相同，当左操作数不支持相应的操作时被调用）增量赋值运算__iadd__(self, other) 定义赋值加法的行为：+=__isub__(self, other) 定义赋值减法的行为：-=__imul__(self, other) 定义赋值乘法的行为：*=__itruediv__(self, other) 定义赋值真除法的行为：/=__ifloordiv__(self, other) 定义赋值整数除法的行为：//=__imod__(self, other) 定义赋值取模算法的行为：%=__ipow__(self, other[, modulo]) 定义赋值幂运算的行为：**=__ilshift__(self, other) 定义赋值按位左移位的行为：&lt;&lt;=__irshift__(self, other) 定义赋值按位右移位的行为：&gt;&gt;=__iand__(self, other) 定义赋值按位与操作的行为：&amp;=__ixor__(self, other) 定义赋值按位异或操作的行为：^=__ior__(self, other) 定义赋值按位或操作的行为：|=一元操作符__neg__(self) 定义正号的行为：+x__pos__(self) 定义负号的行为：-x__abs__(self) 定义当被 abs() 调用时的行为__invert__(self) 定义按位求反的行为：~x类型转换__complex__(self) 定义当被 complex() 调用时的行为（需要返回恰当的值）__int__(self) 定义当被 int() 调用时的行为（需要返回恰当的值）__float__(self) 定义当被 float() 调用时的行为（需要返回恰当的值）__round__(self[, n]) 定义当被 round() 调用时的行为（需要返回恰当的值）__index__(self) 当对象是被应用在切片表达式中时，实现整形强制转换 如果你定义了一个可能在切片时用到的定制的数值型,你应该定义 index 如果 index 被定义，则 int 也需要被定义，且返回相同的值 上下文管理（with 语句）__enter__(self) 1. 定义当使用 with 语句时的初始化行为 2. __enter__ 的返回值被 with 语句的目标或者 as 后的名字绑定__exit__(self, exc_type, exc_value, traceback) 1. 定义当一个代码块被执行或者终止后上下文管理器应该做什么 2. 一般被用来处理异常，清除工作或者做一些代码块执行完毕之后的日常工作 容器类型__len__(self) 定义当被 len() 调用时的行为（返回容器中元素的个数）__getitem__(self, key) 定义获取容器中指定元素的行为，相当于 self[key]__setitem__(self, key, value) 定义设置容器中指定元素的行为，相当于 self[key] = value__delitem__(self, key) 定义删除容器中指定元素的行为，相当于 del self[key]__iter__(self) 定义当迭代容器中的元素的行为__reversed__(self) 定义当被 reversed() 调用时的行为__contains__(self, item) 定义当使用成员测试运算符（in 或 not in）时的行为 转载自： https://www.jb51.net/article/156169.htm]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[斐波那契数列]]></title>
    <url>%2Fmath%2Fck0xy272g002zksv7tj80owae.html</url>
    <content type="text"><![CDATA[简介斐波那契数列（Fibonacci sequence），又称黄金分割数列、因数学家列昂纳多·斐波那契（Leonardoda Fibonacci）以兔子繁殖为例子而引入，故又称为“兔子数列”。 其指的是这样一个数列：1、1、2、3、5、8、13、21、34、……如果设F(n）为该数列的第n项（n∈N*），那么这句话可以写成如下形式：:F(n)=F(n-1)+F(n-2) 在现代物理、准晶体结构、化学等领域，斐波纳契数列都有直接的应用。 详细介绍参考：传送门 python 实现打印第 n 个斐波那契数 123456789101112131415#!/usr/bin/python3# return n-th numberdef fibonacci(n): assert isinstance(n, int), &apos;n should be integer&apos; assert n &gt; 0, &apos;n should be greater than 0&apos; a, b = 1, 1 for x in range(2, n): a, b = b, a + b else: return bif __name__ == &quot;__main__&quot;: print(fibonacci(10)) # 55 打印 n 个斐波那契数 1234567891011121314151617#!/usr/bin/python3# return count of ndef fibonacci(n): assert isinstance(n, int), &apos;n should be integer&apos; assert n &gt; 0, &apos;n should be greater than 0&apos; a, b = 0, 1 fib_lst = [] for x in range(n): fib_lst.append(b) a, b = b, a + b else: return fib_lstif __name__ == &quot;__main__&quot;: print(fibonacci(10)) # [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]]]></content>
      <categories>
        <category>math</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python operator module]]></title>
    <url>%2Fpython%2Fmodule%2Fck0xy27k6007qksv7jp1h88xl.html</url>
    <content type="text"><![CDATA[简介operator模块提供了一套与Python的内置运算符对应的高效率函数。 许多函数名与特殊方法名相同，只是没有双下划线。为了向后兼容性，也保留了许多包含双下划线的函数。为了表述清楚，建议使用没有双下划线的函数。 函数包含的种类有：对象的比较运算、逻辑运算、数学运算以及序列运算。 源代码: Lib/operator.py 1234&gt;&gt;&gt; import operator&gt;&gt;&gt; dir(operator) [&apos;__abs__&apos;, &apos;__add__&apos;, &apos;__all__&apos;, &apos;__and__&apos;, &apos;__builtins__&apos;, &apos;__cached__&apos;, &apos;__concat__&apos;, &apos;__contains__&apos;, &apos;__delitem__&apos;, &apos;__doc__&apos;, &apos;__eq__&apos;, &apos;__file__&apos;, &apos;__floordiv__&apos;, &apos;__ge__&apos;, &apos;__getitem__&apos;, &apos;__gt__&apos;, &apos;__iadd__&apos;, &apos;__iand__&apos;, &apos;__iconcat__&apos;, &apos;__ifloordiv__&apos;, &apos;__ilshift__&apos;, &apos;__imatmul__&apos;, &apos;__imod__&apos;, &apos;__imul__&apos;, &apos;__index__&apos;, &apos;__inv__&apos;, &apos;__invert__&apos;, &apos;__ior__&apos;, &apos;__ipow__&apos;, &apos;__irshift__&apos;, &apos;__isub__&apos;, &apos;__itruediv__&apos;, &apos;__ixor__&apos;, &apos;__le__&apos;, &apos;__loader__&apos;, &apos;__lshift__&apos;, &apos;__lt__&apos;, &apos;__matmul__&apos;, &apos;__mod__&apos;, &apos;__mul__&apos;, &apos;__name__&apos;, &apos;__ne__&apos;, &apos;__neg__&apos;, &apos;__not__&apos;, &apos;__or__&apos;, &apos;__package__&apos;, &apos;__pos__&apos;, &apos;__pow__&apos;, &apos;__rshift__&apos;, &apos;__setitem__&apos;, &apos;__spec__&apos;, &apos;__sub__&apos;, &apos;__truediv__&apos;, &apos;__xor__&apos;, &apos;_abs&apos;, &apos;abs&apos;, &apos;add&apos;, &apos;and_&apos;, &apos;attrgetter&apos;, &apos;concat&apos;, &apos;contains&apos;, &apos;countOf&apos;, &apos;delitem&apos;, &apos;eq&apos;, &apos;floordiv&apos;, &apos;ge&apos;, &apos;getitem&apos;, &apos;gt&apos;, &apos;iadd&apos;, &apos;iand&apos;, &apos;iconcat&apos;, &apos;ifloordiv&apos;, &apos;ilshift&apos;, &apos;imatmul&apos;, &apos;imod&apos;, &apos;imul&apos;, &apos;index&apos;, &apos;indexOf&apos;, &apos;inv&apos;, &apos;invert&apos;, &apos;ior&apos;, &apos;ipow&apos;, &apos;irshift&apos;, &apos;is_&apos;, &apos;is_not&apos;, &apos;isub&apos;, &apos;itemgetter&apos;, &apos;itruediv&apos;, &apos;ixor&apos;, &apos;le&apos;, &apos;length_hint&apos;, &apos;lshift&apos;, &apos;lt&apos;, &apos;matmul&apos;, &apos;methodcaller&apos;, &apos;mod&apos;, &apos;mul&apos;, &apos;ne&apos;, &apos;neg&apos;, &apos;not_&apos;, &apos;or_&apos;, &apos;pos&apos;, &apos;pow&apos;, &apos;rshift&apos;, &apos;setitem&apos;, &apos;sub&apos;, &apos;truediv&apos;, &apos;truth&apos;, &apos;xor&apos;] 对象比较函数对象比较函数适用于所有的对象，函数名根据它们对应的比较运算符命名。 12345678910111213operator.lt(a, b) # a &lt; boperator.le(a, b) # a &lt;= boperator.eq(a, b) # a == boperator.ne(a, b) # a != boperator.ge(a, b) # a &gt;= boperator.gt(a, b) # a &gt; boperator.__lt__(a, b) # a &lt; boperator.__le__(a, b) # a &lt;= boperator.__eq__(a, b) # a == boperator.__ne__(a, b) # a != boperator.__ge__(a, b) # a &gt;= boperator.__gt__(a, b) # a &gt; b 逻辑运算123456789101112operator.not_(obj)operator.__not__(obj) Return the outcome of not obj. operator.truth(obj) Return True if obj is true, and False otherwise. This is equivalent to using the bool constructor.operator.is_(a, b) Return a is b. Tests object identity.operator.is_not(a, b) Return a is not b. Tests object identity. 赋值运算12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455operator.iadd(a, b)operator.__iadd__(a, b) a = iadd(a, b) is equivalent to a += b.operator.iand(a, b)operator.__iand__(a, b) a = iand(a, b) is equivalent to a &amp;= b.operator.iconcat(a, b)operator.__iconcat__(a, b) a = iconcat(a, b) is equivalent to a += b for a and b sequences.operator.ifloordiv(a, b)operator.__ifloordiv__(a, b) a = ifloordiv(a, b) is equivalent to a //= b.operator.ilshift(a, b)operator.__ilshift__(a, b) a = ilshift(a, b) is equivalent to a &lt;&lt;= b.operator.imod(a, b)operator.__imod__(a, b) a = imod(a, b) is equivalent to a %= b.operator.imul(a, b)operator.__imul__(a, b) a = imul(a, b) is equivalent to a *= b.operator.imatmul(a, b)operator.__imatmul__(a, b) a = imatmul(a, b) is equivalent to a @= b.operator.ior(a, b)operator.__ior__(a, b) a = ior(a, b) is equivalent to a |= b.operator.ipow(a, b)operator.__ipow__(a, b) a = ipow(a, b) is equivalent to a **= b.operator.irshift(a, b)operator.__irshift__(a, b) a = irshift(a, b) is equivalent to a &gt;&gt;= b.operator.isub(a, b)operator.__isub__(a, b) a = isub(a, b) is equivalent to a -= b.operator.itruediv(a, b)operator.__itruediv__(a, b) a = itruediv(a, b) is equivalent to a /= b.operator.ixor(a, b)operator.__ixor__(a, b) a = ixor(a, b) is equivalent to a ^= b. 数学运算12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273operator.abs(obj)operator.__abs__(obj) Return the absolute value of obj.operator.add(a, b)operator.__add__(a, b) Return a + b, for a and b numbers.operator.and_(a, b)operator.__and__(a, b) Return the bitwise and of a and b.operator.floordiv(a, b)operator.__floordiv__(a, b) Return a // b.operator.index(a)operator.__index__(a) Return a converted to an integer. Equivalent to a.__index__().operator.inv(obj)operator.invert(obj)operator.__inv__(obj)operator.__invert__(obj) Return the bitwise inverse of the number obj. This is equivalent to ~obj.operator.lshift(a, b)operator.__lshift__(a, b) Return a shifted left by b.operator.mod(a, b)operator.__mod__(a, b) Return a % b.operator.mul(a, b)operator.__mul__(a, b) Return a * b, for a and b numbers.operator.matmul(a, b)operator.__matmul__(a, b) Return a @ b.operator.neg(obj)operator.__neg__(obj) Return obj negated (-obj).operator.or_(a, b)operator.__or__(a, b) Return the bitwise or of a and b.operator.pos(obj)operator.__pos__(obj)Return obj positive (+obj).operator.pow(a, b)operator.__pow__(a, b) Return a ** b, for a and b numbers.operator.rshift(a, b)operator.__rshift__(a, b) Return a shifted right by b.operator.sub(a, b)operator.__sub__(a, b) Return a - b.operator.truediv(a, b)operator.__truediv__(a, b) Return a / b where 2/3 is .66 rather than 0. This is also known as &quot;true&quot; division.operator.xor(a, b)operator.__xor__(a, b) Return the bitwise exclusive or of a and b. 序列运算12345678910111213141516171819202122232425262728operator.concat(a, b)operator.__concat__(a, b) Return a + b for a and b sequences.operator.contains(a, b)operator.__contains__(a, b) Return the outcome of the test b in a. Note the reversed operands.operator.countOf(a, b) Return the number of occurrences of b in a.operator.delitem(a, b)operator.__delitem__(a, b) Remove the value of a at index b.operator.getitem(a, b)operator.__getitem__(a, b) Return the value of a at index b.operator.indexOf(a, b) Return the index of the first of occurrence of b in a.operator.setitem(a, b, c)operator.__setitem__(a, b, c) Set the value of a at index b to c.operator.length_hint(obj, default=0) Return an estimated length for the object o. First try to return its actual length, then an estimate using object.__length_hint__(), and finally return the default value. 实用函数operator.attrgetter1234567operator.attrgetter(attr)operator.attrgetter(*attrs)Return a callable object that fetches attr from its operand. If more than one attribute is requested, returns a tuple of attributes. The attribute names can also contain dots. For example: After f = attrgetter(&apos;name&apos;), the call f(b) returns b.name. After f = attrgetter(&apos;name&apos;, &apos;date&apos;), the call f(b) returns (b.name, b.date). After f = attrgetter(&apos;name.first&apos;, &apos;name.last&apos;), the call f(b) returns (b.name.first, b.name.last). Equivalent to: 12345678910111213141516def attrgetter(*items): if any(not isinstance(item, str) for item in items): raise TypeError(&apos;attribute name must be a string&apos;) if len(items) == 1: attr = items[0] def g(obj): return resolve_attr(obj, attr) else: def g(obj): return tuple(resolve_attr(obj, attr) for attr in items) return gdef resolve_attr(obj, attr): for name in attr.split(&quot;.&quot;): obj = getattr(obj, name) return obj operator.itemgetter123456operator.itemgetter(item)operator.itemgetter(*items)Return a callable object that fetches item from its operand using the operand’s __getitem__() method. If multiple items are specified, returns a tuple of lookup values. For example: After f = itemgetter(2), the call f(r) returns r[2]. After g = itemgetter(2, 5, 3), the call g(r) returns (r[2], r[5], r[3]). Equivalent to: 123456789def itemgetter(*items): if len(items) == 1: item = items[0] def g(obj): return obj[item] else: def g(obj): return tuple(obj[item] for item in items) return g The items can be any type accepted by the operand’s __getitem__() method. Dictionaries accept any hashable value. Lists, tuples, and strings accept an index or a slice: 12345678910&gt;&gt;&gt; itemgetter(1)(&apos;ABCDEFG&apos;)&apos;B&apos;&gt;&gt;&gt; itemgetter(1,3,5)(&apos;ABCDEFG&apos;)(&apos;B&apos;, &apos;D&apos;, &apos;F&apos;)&gt;&gt;&gt; itemgetter(slice(2,None))(&apos;ABCDEFG&apos;)&apos;CDEFG&apos;&gt;&gt;&gt; soldier = dict(rank=&apos;captain&apos;, name=&apos;dotterbart&apos;)&gt;&gt;&gt; itemgetter(&apos;rank&apos;)(soldier)&apos;captain&apos; Example of using itemgetter() to retrieve specific fields from a tuple record: 123456&gt;&gt;&gt; inventory = [(&apos;apple&apos;, 3), (&apos;banana&apos;, 2), (&apos;pear&apos;, 5), (&apos;orange&apos;, 1)]&gt;&gt;&gt; getcount = itemgetter(1)&gt;&gt;&gt; list(map(getcount, inventory))[3, 2, 5, 1]&gt;&gt;&gt; sorted(inventory, key=getcount)[(&apos;orange&apos;, 1), (&apos;banana&apos;, 2), (&apos;apple&apos;, 3), (&apos;pear&apos;, 5)] operator.methodcaller12345operator.methodcaller(name[, args...])Return a callable object that calls the method name on its operand. If additional arguments and/or keyword arguments are given, they will be given to the method as well. For example: After f = methodcaller(&apos;name&apos;), the call f(b) returns b.name(). After f = methodcaller(&apos;name&apos;, &apos;foo&apos;, bar=1), the call f(b) returns b.name(&apos;foo&apos;, bar=1). Equivalent to: 1234def methodcaller(name, *args, **kwargs): def caller(obj): return getattr(obj, name)(*args, **kwargs) return caller Mapping Operators to FunctionsThis table shows how abstract operations correspond to operator symbols in the Python syntax and the functions in the operator module. Operation Syntax Function Addition a + b add(a, b) Concatenation seq1 + seq2 concat(seq1, seq2) Containment Test obj in seq contains(seq, obj) Division a / b truediv(a, b) Division a // b floordiv(a, b) Bitwise And a &amp; b and_(a, b) Bitwise Exclusive Or a ^ b xor(a, b) Bitwise Inversion ~ a invert(a) Bitwise Or `a b` Exponentiation a ** b pow(a, b) Identity a is b is_(a, b) Identity a is not b is_not(a, b) Indexed Assignment obj[k] = v setitem(obj, k, v) Indexed Deletion del obj[k] delitem(obj, k) Indexing obj[k] getitem(obj, k) Left Shift a &lt;&lt; b lshift(a, b) Modulo a % b mod(a, b) Multiplication a * b mul(a, b) Matrix Multiplication a @ b matmul(a, b) Negation (Arithmetic) - a neg(a) Negation (Logical) not a not_(a) Positive + a pos(a) Right Shift a &gt;&gt; b rshift(a, b) Slice Assignment seq[i:j] = values setitem(seq, slice(i, j), values) Slice Deletion del seq[i:j] delitem(seq, slice(i, j)) Slicing seq[i:j] getitem(seq, slice(i, j)) String Formatting s % obj mod(s, obj) Subtraction a - b sub(a, b) Truth Test obj truth(obj) Ordering a &lt; b lt(a, b) Ordering a &lt;= b le(a, b) Equality a == b eq(a, b) Difference a != b ne(a, b) Ordering a &gt;= b ge(a, b) Ordering a &gt; b gt(a, b)]]></content>
      <categories>
        <category>python</category>
        <category>module</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>module</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 统计文件及目录个数]]></title>
    <url>%2FLinux%2Fcommand%2Fck0xy26z3001nksv78qm278u7.html</url>
    <content type="text"><![CDATA[可通过命令 wc 、cat等实现。 示例目录 123456789101112131415161718192021222324252627282930313233343536373839404142[root@hadoop-centos-01 test]# tree.├── hadoop├── python_exm│ ├── a.txt│ └── example.py├── spark│ └── python│ └── test.py├── text.txt├── text.txt.hard├── text.txt.soft -&gt; text.txt└── ts.txt4 directories, 7 files[root@hadoop-centos-01 test]# ls -lR.:total 12drwxr-xr-x. 2 root root 6 Aug 25 21:32 hadoopdrwxr-xr-x. 2 root root 37 Aug 25 21:22 python_exmdrwxr-xr-x. 3 root root 20 Aug 26 08:08 spark-rw-r--r--. 2 root root 22 Aug 15 07:12 text.txt-rw-r--r--. 2 root root 22 Aug 15 07:12 text.txt.hardlrwxrwxrwx. 1 root root 8 Aug 14 06:51 text.txt.soft -&gt; text.txt-rw-r--r--. 1 root root 79 Aug 20 06:48 ts.txt./hadoop:total 0./python_exm:total 8-rw-r--r--. 1 root root 1 Aug 25 21:22 a.txt-rw-r--r--. 1 root root 70 Aug 23 07:59 example.py./spark:total 0drwxr-xr-x. 2 root root 21 Aug 26 08:09 python./spark/python:total 0-rw-r--r--. 1 root root 0 Aug 26 08:09 test.py 统计当前文件夹下文件及目录的总个数 12[root@hadoop-centos-01 test]# ls | wc -l7 统计目录个数 统计当前文件夹下目录的个数 12[root@hadoop-centos-01 test]# ls -l | grep &quot;^d&quot; | wc -l3 统计当前文件夹及其子文件夹下目录的个数 12[root@hadoop-centos-01 test]# ls -lR | grep &quot;^d&quot; | wc -l4 统计文件个数统计当前文件夹下文件的个数 12[root@hadoop-centos-01 test]# ls -l | grep &quot;^-&quot; | wc -l3 统计当前文件夹及其子目录下文件的个数 12[root@hadoop-centos-01 test]# ls -lR | grep &quot;^-&quot; | wc -l6 统计文件行数统计当前目录下所有文件行数 方法一： 123456789101112[root@hadoop-centos-01 test]# wc -l *wc: hadoop: Is a directory 0 hadoopwc: python_exm: Is a directory 0 python_exmwc: spark: Is a directory 0 spark 2 text.txt 2 text.txt.hard 2 text.txt.soft 5 ts.txt 11 total 方法二： 123456[root@hadoop-centos-01 test]# wc -l text.txt text.txt.hard text.txt.soft ts.txt 2 text.txt 2 text.txt.hard 2 text.txt.soft 5 ts.txt 11 total 方法三： 12[root@hadoop-centos-01 test]# cat -n text.txt text.txt.hard text.txt.soft ts.txt | tail -1 11]]></content>
      <categories>
        <category>Linux</category>
        <category>command</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>command</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux wc command]]></title>
    <url>%2FLinux%2Fcommand%2Fwc%2Fck0xy27e30055ksv7v9hd2p3w.html</url>
    <content type="text"><![CDATA[作用wc 命令用于计算字数。 利用 wc 指令我们可以计算文件的Byte数、字数、或是列数，若不指定文件名称、或是所给予的文件名为”-“，则wc指令会从标准输入设备读取数据。 用法语法1wc [-clw][--help][--version][文件...] 参数1234567-c, --bytes 统计字节数-m, --chars 统计字符数,这个标志不能与 -c 标志一起使用-l, --lines 统计列数-L, --max-line-length 打印最长行的长度-w, --words 统计字数–help 打印帮助文档–version 显示版本信息 用法示例 查看文件的字节数、字数、行数 12345678910# commandwc filename# example[root@hadoop-centos-01 python_exm]# lsexample.py[root@hadoop-centos-01 python_exm]# wc example.py 4 10 70 example.py注: 打印结果依次为：行数 单词数 字节数 文件名 只打印统计数字不打印文件名 1234[root@hadoop-centos-01 python_exm]# wc -l example.py4 example.py[root@hadoop-centos-01 python_exm]# cat example.py | wc -l4 统计当前目录下的文件数 1234567891011121314[root@hadoop-centos-01 test]# tree -L 1.├── hadoop├── python_exm├── spark├── text.txt├── text.txt.hard├── text.txt.soft -&gt; text.txt└── ts.txt3 directories, 4 files[root@hadoop-centos-01 test]# ls | wc -l7 帮助文档123456789101112131415161718Usage: wc [OPTION]... [FILE]... or: wc [OPTION]... --files0-from=FPrint newline, word, and byte counts for each FILE, and a total line ifmore than one FILE is specified. With no FILE, or when FILE is -,read standard input. A word is a non-zero-length sequence of charactersdelimited by white space.The options below may be used to select which counts are printed, always inthe following order: newline, word, character, byte, maximum line length. -c, --bytes print the byte counts -m, --chars print the character counts -l, --lines print the newline counts --files0-from=F read input from the files specified by NUL-terminated names in file F; If F is - then read names from standard input -L, --max-line-length print the length of the longest line -w, --words print the word counts --help display this help and exit --version output version information and exit]]></content>
      <categories>
        <category>Linux</category>
        <category>command</category>
        <category>wc</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>command</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 设置静态IP]]></title>
    <url>%2FLinux%2Fck0xy26zy0021ksv7okbhf36n.html</url>
    <content type="text"><![CDATA[第一步：激活网卡通过ip add或者ifconfig 查看网卡名称。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# 通过ip addr 查看[root@hadoop-centos-01 ~]# ip addr1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:ff:56:49 brd ff:ff:ff:ff:ff:ff inet 192.168.244.11/24 brd 192.168.244.255 scope global ens33 valid_lft forever preferred_lft forever inet6 fe80::20c:29ff:feff:5649/64 scope link valid_lft forever preferred_lft forever3: virbr0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN group default qlen 1000 link/ether 52:54:00:72:bb:ed brd ff:ff:ff:ff:ff:ff inet 192.168.122.1/24 brd 192.168.122.255 scope global virbr0 valid_lft forever preferred_lft forever4: virbr0-nic: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc pfifo_fast master virbr0 state DOWN group default qlen 1000 link/ether 52:54:00:72:bb:ed brd ff:ff:ff:ff:ff:ff# 通过 ifconfig 查看[root@hadoop-centos-01 ~]# ifconfigens33: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 192.168.244.11 netmask 255.255.255.0 broadcast 192.168.244.255 inet6 fe80::20c:29ff:feff:5649 prefixlen 64 scopeid 0x20&lt;link&gt; ether 00:0c:29:ff:56:49 txqueuelen 1000 (Ethernet) RX packets 9568 bytes 614967 (600.5 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 1112 bytes 140379 (137.0 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt; mtu 65536 inet 127.0.0.1 netmask 255.0.0.0 inet6 ::1 prefixlen 128 scopeid 0x10&lt;host&gt; loop txqueuelen 1000 (Local Loopback) RX packets 72 bytes 8088 (7.8 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 72 bytes 8088 (7.8 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0virbr0: flags=4099&lt;UP,BROADCAST,MULTICAST&gt; mtu 1500 inet 192.168.122.1 netmask 255.255.255.0 broadcast 192.168.122.255 ether 52:54:00:72:bb:ed txqueuelen 1000 (Ethernet) RX packets 0 bytes 0 (0.0 B) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 0 bytes 0 (0.0 B) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 Linux中的网卡名以eth开头，vmware虚拟机中一般为ens，从0开始依次编号。网卡激活命令 ifconfig eth0up 1[root@hadoop-centos-01 ~]# ifconfig ens33 up # ens33 为当前的虚拟网卡 第二步：设置网卡进入系统时启动想要每次开机就可以自动获取IP地址上网，就要设置网络服务在系统启动时也启动。Linux有一点与windows不同的是很多服务默认是停止的，而且你在某次使用该服务时启动这个服务，但是没设置它为默认启动，则下次进入系统这个服务依然是停止的。下面是设置网络服务在系统启动时也启动的方法。 使用chkconfig命令让网络服务在系统启动级别是2345时默认启动。 1[root@hadoop-centos-01 ~]# chkconfig --level 2345 network on 第三步：修改网卡文件ifcfg-eth*网络配置文件位于 /etc/sysconfig/network-scripts 目录下，文件为 ifcfg-ens*，*为文件其它字符，因为不同的虚拟机该文件名字可能不同。 ifcfg-eth33文件配置解析： TYPE=Ethernet # 配置文件接口类型，有Ethernet、IPsec等类型，网络接口类型为Ethernet DEVICE=eth33 # 网络接口名称 BOOTPROTO=none # 系统启动地址协议，none不使用启动地址协议 ONBOOT=yes # 系统启动时是否激活 IPADDR=192.168.16.12 NETMASK=255.255.255.0 GATEWAY=192.168.16.1 BROADCAST=192.168.16.255 HWADDR=00:0C:29:13:5D:74 PEERDNS=yes DNS1=10.0.1.41 USERCTL=no NM_CONTROLLED=no IPV6INIT=yes IPV6ADDR=FD55:fe80::28c2:e745:835f:c8d0/64 附. 配置参数说明 注：这些参数值不区分大小写，不区分单引号和双引号，甚至可以不用引号。 TYPE：配置文件接口类型。在/etc/sysconfig/network-scripts/目录有多种网络配置文件，有Ethernet、IPsec等类型，网络接口类型为Ethernet。 DEVICE：网络接口名称 BOOTPROTO：系统启动地址协议 none：不使用启动地址协议 bootp：BOOTP协议 dhcp：DHCP动态地址协议 static：静态地址协议 ONBOOT：系统启动时是否激活 yes：系统启动时激活该网络接口 no：系统启动时不激活该网络接口 IPADDR：IP地址 NETMASK：子网掩码 GATEWAY：网关地址 BROADCAST：广播地址 HWADDR/MACADDR：MAC地址。只需设置其中一个，同时设置时不能相互冲突。 PEERDNS：是否指定DNS。如果使用DHCP协议，默认为yes。 yes：如果DNS设置，修改/etc/resolv.conf中的DNS no：不修改/etc/resolv.conf中的DNS DNS{1, 2}：DNS地址。当PEERDNS为yes时会被写入/etc/resolv.conf中。 NM_CONTROLLED：是否由Network Manager控制该网络接口。修改保存后立即生效，无需重启。被其坑过几次，建议一般设为no。 yes：由NetworkManager控制 no：不由NetworkManager控制 USERCTL：用户权限控制 yes：非root用户允许控制该网络接口 no：非root用户不运行控制该网络接口 IPV6INIT：是否执行IPv6 yes：支持IPv6 no：不支持IPv6 IPV6ADDR：IPv6地址/前缀长度第四步：配置生效为了使网络配置永久有效，第二部中修改了/etc/sysconfig/network-scripts/下的网络接口配置文件。但是，这些文件修改后，并不能立即生效。可通过以下两种方式使修改文件的网络配置生效： 1） 重启网络服务（推荐） service network restart 2） 重启计算机 reboot Referencehttps://www.cnblogs.com/aventador/p/3375434.html]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式简述]]></title>
    <url>%2Fregex%2Fck0xy26sk000xksv7dgf0vm90.html</url>
    <content type="text"><![CDATA[何谓正则表达式正则表达式 英文为 Regular Expression，是使用字符和特殊符号组成的能够描述某一类字符串的表达式。可以用来检查一个字符串是否含有某种子串、将匹配的子串替换或者从某个字符串中取出符合某个条件的子串等。 正则表达式看似繁琐（有规律可寻），然功能强大。熟知，简化工作，提升效率。 语法正则表达式是由普通字符（例如字符 a 到 z）以及特殊字符（称为”元字符”）组成的文字模式，该模式可以是单个的字符、字符集合、字符范围、字符间的选择或者所有这些组件的任意组合。 普通字符普通字符包括没有显式指定为元字符的所有可打印和不可打印字符。这包括所有大写和小写字母、所有数字、所有标点符号和一些其他符号。 非打印字符非打印字符也可以是正则表达式的组成部分。下表列出了表示非打印字符的转义序列： 字符 描述 \cx 匹配由x指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。 \f 匹配一个换页符。等价于 \x0c 和 \cL。 \n 匹配一个换行符。等价于 \x0a 和 \cJ。 \r 匹配一个回车符。等价于 \x0d 和 \cM。 \s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。注意 Unicode 正则表达式会匹配全角空格符。 \S 匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。 \t 匹配一个制表符。等价于 \x09 和 \cI。 \v 匹配一个垂直制表符。等价于 \x0b 和 \cK。 元字符下表包含了元字符的完整列表以及它们在正则表达式上下文中的行为： 字符 描述 \ 将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，’n’ 匹配字符 “n”。’\n’ 匹配一个换行符。序列 ‘\‘ 匹配 “&quot; 而 “(“ 则匹配 “(“。 ^ 匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 ‘\n’ 或 ‘\r’ 之后的位置。 $ 匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 ‘\n’ 或 ‘\r’ 之前的位置。 * 匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,}。 + 匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。 ? 匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 或 “does” 。? 等价于 {0,1}。 {n} n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。 {n,} n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。 {n,m} m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。 ? 当该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 “oooo”，’o+?’ 将匹配单个 “o”，而 ‘o+’ 将匹配所有 ‘o’。 . 匹配除换行符（\n、\r）之外的任何单个字符。要匹配包括 ‘\n’ 在内的任何字符，请使用像”(.|\n)“的模式。 (pattern) 匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用 SubMatches 集合，在JScript 中则使用 $0…$9 属性。要匹配圆括号字符，请使用 ‘(‘ 或 ‘)‘。 (?:pattern) 匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 “或” 字符 (|) 来组合一个模式的各个部分是很有用。例如， ‘industr(?:y|ies) 就是一个比 ‘industry|industries’ 更简略的表达式。 (?=pattern) 正向肯定预查（look ahead positive assert），在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，”Windows(?=95|98|NT|2000)”能匹配”Windows2000”中的”Windows”，但不能匹配”Windows3.1”中的”Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 (?!pattern) 正向否定预查(negative assert)，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如”Windows(?!95|98|NT|2000)”能匹配”Windows3.1”中的”Windows”，但不能匹配”Windows2000”中的”Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 (?&lt;=pattern) 反向(look behind)肯定预查，与正向肯定预查类似，只是方向相反。例如，”`(?&lt;=95 (?&lt;!pattern) 反向否定预查，与正向否定预查类似，只是方向相反。例如”`(?&lt;!95 x|y 匹配 x 或 y。例如，’z|food’ 能匹配 “z” 或 “food”。’(z|f)ood’ 则匹配 “zood” 或 “food”。 [xyz] 字符集合。匹配所包含的任意一个字符。例如， ‘[abc]’ 可以匹配 “plain” 中的 ‘a’。 [^xyz] 负值字符集合。匹配未包含的任意字符。例如， ‘[^abc]’ 可以匹配 “plain” 中的’p’、’l’、’i’、’n’。 [a-z] 字符范围。匹配指定范围内的任意字符。例如，’[a-z]’ 可以匹配 ‘a’ 到 ‘z’ 范围内的任意小写字母字符。 [^a-z] 负值字符范围。匹配任何不在指定范围内的任意字符。例如，’[^a-z]’ 可以匹配任何不在 ‘a’ 到 ‘z’ 范围内的任意字符。 \b 匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。 \B 匹配非单词边界。’er\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。 \cx 匹配由 x 指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。 \d 匹配一个数字字符。等价于 [0-9]。 \D 匹配一个非数字字符。等价于 [^0-9]。 \f 匹配一个换页符。等价于 \x0c 和 \cL。 \n 匹配一个换行符。等价于 \x0a 和 \cJ。 \r 匹配一个回车符。等价于 \x0d 和 \cM。 \s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。 \S 匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。 \t 匹配一个制表符。等价于 \x09 和 \cI。 \v 匹配一个垂直制表符。等价于 \x0b 和 \cK。 \w 匹配字母、数字、下划线。等价于’[A-Za-z0-9_]’。 \W 匹配非字母、数字、下划线。等价于 ‘[^A-Za-z0-9_]’。 \xn 匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，’\x41’ 匹配 “A”。’\x041’ 则等价于 ‘\x04’ &amp; “1”。正则表达式中可以使用 ASCII 编码。 \num 匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。例如，’(.)\1’ 匹配两个连续的相同字符。 \n 标识一个八进制转义值或一个向后引用。如果 \n 之前至少 n 个获取的子表达式，则 n 为向后引用。否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值。 \nm 标识一个八进制转义值或一个向后引用。如果 \nm 之前至少有 nm 个获得子表达式，则 nm 为向后引用。如果 \nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的向后引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 \nm 将匹配八进制转义值 nm。 \nml 如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。 \un 匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。例如， \u00A9 匹配版权符号 (?)。 注：元字符自身的匹配需要进行转译，例如\. or \* 运算符优先级正则表达式从左到右进行计算，并遵循优先级顺序，这与算术表达式非常类似。 相同优先级的从左到右进行运算，不同优先级的运算先高后低。下表从最高到最低说明了各种正则表达式运算符的优先级顺序： 运算符 描述 \ 转义符 (), (?:), (?=), [] 圆括号和方括号 *, +, ?, {n}, {n,}, {n,m} 限定符 ^, $, \任何元字符、任何字符 定位点和序列（即：位置和顺序） | 替换，”或”操作 字符具有高于替换运算符的优先级，使得”m|food”匹配”m”或”food”。若要匹配”mood”或”food”，请使用括号创建子表达式，从而产生”(m|f)ood”。 上述摘自菜鸟教程：https://www.runoob.com/regexp/regexp-tutorial.html 推存一个学习链接：http://deerchao.net/tutorials/regex/regex.htm]]></content>
      <categories>
        <category>regex</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>regex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[执行chmod -R 777 命令误操作根目录补救的方法]]></title>
    <url>%2FLinux%2Fck0xy26zl001vksv73aoifiq0.html</url>
    <content type="text"><![CDATA[使用 chmod -R 777 ./* 命令在更改某个目录下文件的权限时，由于操作失误，误用为 chmod -R 777 /*，在零点几秒的反应过后，果断 ctrl + c，奈何电脑反应更快，一切为时已晚（切记不要关闭该终端）。若何？ 查看当前根目录权限，如下： 123456789101112131415161718192021[root@hadoop-centos-03` /]# lltotal 24lrwxrwxrwx. 1 root root 7 Apr 28 07:32 bin -&gt; usr/bindrwxrwxrwx. 5 root root 4096 Apr 28 07:58 bootdrwxrwxrwx. 20 root root 3320 Aug 14 21:58 devdrwxrwxrwx. 138 root root 8192 May 12 21:05 etcdrwxrwxrwx. 3 root root 20 Apr 28 08:18 homelrwxrwxrwx. 1 root root 7 Apr 28 07:32 lib -&gt; usr/liblrwxrwxrwx. 1 root root 9 Apr 28 07:32 lib64 -&gt; usr/lib64drwxrwxrwx. 2 root root 6 Apr 11 2018 mediadrwxrwxrwx. 2 root root 6 Apr 11 2018 mntdrwxrwxrwx. 6 root root 77 Aug 14 22:10 optdrwxrwxrwx. 189 root root 0 Aug 14 21:57 procdrwxrwxrwx. 19 root root 4096 Aug 14 22:09 rootdrwxr-xr-x. 39 root root 1220 Aug 14 21:58 runlrwxrwxrwx. 1 root root 8 Apr 28 07:32 sbin -&gt; usr/sbindrwxr-xr-x. 2 root root 6 Apr 11 2018 srvdr-xr-xr-x. 13 root root 0 Aug 14 21:58 sysdrwxrwxrwt. 22 root root 4096 Aug 14 22:12 tmpdrwxr-xr-x. 13 root root 155 Apr 28 07:32 usrdrwxr-xr-x. 20 root root 282 Apr 28 08:00 var 由于 /etc 目录已经被更改，显示如下： 12345678910111213141516171819202122[root@hadoop-centos-03` etc]# ll | headtotal 1384drwxrwxrwx. 3 root root 101 Apr 28 07:36 abrt-rwxrwxrwx. 1 root root 16 Apr 28 07:57 adjtime-rwxrwxrwx. 1 root root 1518 Jun 7 2013 aliases-rwxrwxrwx. 1 root root 12288 Apr 28 08:00 aliases.dbdrwxrwxrwx. 3 root root 65 Apr 28 07:45 alsadrwxrwxrwx. 2 root root 4096 May 6 07:03 alternatives-rwxrwxrwx. 1 root root 541 Apr 11 2018 anacrontab-rwxrwxrwx. 1 root root 55 Oct 30 2018 asound.conf-rwxrwxrwx. 1 root root 1 Oct 31 2018 at.deny[root@hadoop-centos-03` etc]# ll | tail-rwxrwxrwx. 1 root root 4479 Oct 31 2018 wgetrcdrwxrwxrwx. 2 root root 33 Apr 28 07:36 wpa_supplicant-rwxrwxrwx. 1 root root 0 Jun 10 2014 wvdial.confdrwxrwxrwx. 6 root root 103 Apr 28 07:35 X11drwxrwxrwx. 6 root root 116 Apr 28 07:39 xdgdrwxrwxrwx. 2 root root 6 Apr 11 2018 xinetd.ddrwxrwxrwx. 2 root root 21 Apr 28 07:33 xmldrwxrwxrwx. 6 root root 100 Apr 28 07:35 yum-rwxrwxrwx. 1 root root 970 Nov 5 2018 yum.confdrwxrwxrwx. 2 root root 187 Nov 5 2018 yum.repos.d 故已无法通过ssh连接该节点，提示如下： 123456Session stopped - Press &lt;return&gt; to exit tab - Press R to restart session - Press S to save terminal output to fileServer unexpectedly closed network connection ssh 登录相关的文件信息在/etc/ssh目录下，相关文件可能还有passwd、group、shadow等，查找另外一台正常机器该目录的权限及相关文件的权限，根据其修改当前出错机器/etc/ssh目录下的文件及相关文件的权限，我试着将/etc/ssh目录下的文件更改为600，即执行chmod 600 /etc/ssh，发现通过ssh可以连接，示例如下： 12345678# 未修改前[root@hadoop-centos-01 ~]# ssh hadoop-centos-03ssh_exchange_identification: read: Connection reset by peer# 修改后[root@hadoop-centos-01 etc]# ssh hadoop-centos-03root@hadoop-centos-03&apos;s password:Last login: Wed Aug 14 22:48:39 2019 from 192.168.244.6 最头疼的问题（登陆问题）已经解决，只要能进去，剩下的就要慢慢折腾喽。 导出系统文件权限 如果你是在集群中出现上述情况，可以找一个相似的机器，如果你是单机模式，那就找一个比较干净（没有安装过多的额外应用）的机器，导出系统各目录层级的文件权限。 导出命令： 1getfacl -R /* &gt; /home/chmod.bak # 存储路径及文件名可以自定义 修改出错机器系统文件权限 命令： 1setfacl --restore=/home/chmod.bak 上述命令执行完后： 123456789101112131415161718192021[root@hadoop-centos-03` /]# lltotal 24lrwxrwxrwx. 1 root root 7 Apr 28 07:32 bin -&gt; usr/bindr-xr-xr-x. 5 root root 4096 Apr 28 07:58 bootdrwxr-xr-x. 20 root root 3320 Aug 14 21:58 devdrwxr-xr-x. 138 root root 8192 May 12 21:05 etcdrwxr-xr-x. 3 root root 20 Apr 28 08:18 homelrwxrwxrwx. 1 root root 7 Apr 28 07:32 lib -&gt; usr/liblrwxrwxrwx. 1 root root 9 Apr 28 07:32 lib64 -&gt; usr/lib64drwxr-xr-x. 2 root root 6 Apr 11 2018 mediadrwxr-xr-x. 2 root root 6 Apr 11 2018 mntdrwxr-xr-x. 6 root root 77 Aug 14 22:10 optdr-xr-xr-x. 234 root root 0 Aug 14 21:57 procdr-xr-x---. 19 root root 4096 Aug 14 22:48 rootdrwxr-xr-x. 40 root root 1240 Aug 14 23:06 runlrwxrwxrwx. 1 root root 8 Apr 28 07:32 sbin -&gt; usr/sbindrwxr-xr-x. 2 root root 6 Apr 11 2018 srvdr-xr-xr-x. 13 root root 0 Aug 14 21:58 sysdrwxrwxrwt. 26 root root 4096 Aug 14 23:06 tmpdrwxr-xr-x. 13 root root 155 Apr 28 07:32 usrdrwxr-xr-x. 20 root root 282 Apr 28 08:00 var 到目前为止，一切看似已恢复正常，如果重启方便，建议重启。 总结 操作失误后，切记不要关闭该终端，或许还可以回到从前； 更改/etc/ 目录下的 passwd、group、shadow、ssh等文件可恢复ssh远程登陆； 导出系统文件对应的权限可通过getfacl -R /* &gt; /home/chmod.bak命令实现； 更新系统文件的权限可通过setfacl --restore=/home/chmod.bak命令实现。 参考 传送门]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软连接与硬连接]]></title>
    <url>%2FLinux%2Fck0xy27050024ksv7z5mtkan3.html</url>
    <content type="text"><![CDATA[链接是一种文件共享的方式，是 POSIX 中的概念，主流文件系统都支持链接文件。 链接无非是把文件名和计算机文件系统使用的节点号链接起来。因此我们可以用多个文件名与同一个文件进行链接，这些文件名可以在同一目录或不同目录。 对链接进行编辑，实际上是对原始文件进行编辑。 硬链接硬链接只能引用同一文件系统中的文件。它引用的是文件在文件系统中的物理索引(也称为 inode)。当您移动或删除原始文件时，硬链接不会被破坏，因为它所引用的是文件的物理数据而不是文件在文件结构中的位置。硬链接的文件不需要用户有访问原始文件的权限，也不会显示原始文件的位置，这样有助于文件的安全。如果您删除的文件有相应的硬链接，那么这个文件依然会保留，直到所有对它的引用都被删除。 使用 1ln [源文件] [目标文件] 示例 1234567891011# 创建一个测试文件 test.txt[root@hadoop-centos-01 test]# echo &quot;Make deserts bloom&quot; &gt; text.txt[root@hadoop-centos-01 test]# lstext.txt# 以 text.txt 为源创建一个硬连接 text.txt.hard[root@hadoop-centos-01 test]# ln text.txt text.txt.hard[root@hadoop-centos-01 test]# ls -litotal 851936935 -rw-r--r--. 2 root root 19 Aug 14 06:43 text.txt51936935 -rw-r--r--. 2 root root 19 Aug 14 06:43 text.txt.hard 注意事项 修改源文件或者目标文件, 对应另外一个文件也会发生相应修改； 删除源文件或者目标文件, 对另外一个文件没有影响； 硬链接文件不占用存储空间； 不能对目录文件进行创建硬链接操作； 硬链接文件不能跨文件系统。 软链接软链接也称之为符号连接（Symbolic Link）。 软链接文件有类似于Windows的快捷方式。它实际上是一个特殊的文件。其包含了另一文件的位置信息。 使用： 1ln -s [源文件或目录] [目标文件或目录] 示例： 123456[root@hadoop-centos-01 test]# ln -s text.txt text.txt.soft[root@hadoop-centos-01 test]# ll -itotal 851936935 -rw-r--r--. 2 root root 19 Aug 14 06:43 text.txt51936935 -rw-r--r--. 2 root root 19 Aug 14 06:43 text.txt.hard # test.txt 的硬链接51936939 lrwxrwxrwx. 1 root root 8 Aug 14 06:51 text.txt.soft -&gt; text.txt # test.txt 的软链接 硬链接与软链接的区别在Linux的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号inode 。 软连接，其实就是新建立一个文件，这个文件就是专门用来指向别的文件的，类似于windows 下的快捷方式。删了这个软连接文件，不影响其指向的实体文件，但如果删除其指向的实体文件，则该软链接不可用。 硬连接，不会建立inode的，他只是在文件原来的inode link count域再增加1而已，也因此硬链接是不可以跨越文件系统的。相反都是软连接会重新建立一个inode，当然inode的结构跟其他的不一样，他只是一个指明源文件的字符串信息。一旦删除源文件，那么软连接将变得毫无意义。而硬链接删除的时候，系统调用会检查inode link count的数值，如果他大于等于1，那么inode不会被回收。因此文件的内容不会被删除。 创建硬链接实际上是为原文件在储存器中的资源再新建一个入口，所以硬链接和原文件指向的其实是储存器中的同一处资源（可以理解为硬链接和原文件就是同一个文件）。可以通过ls -i来查看一下，这两个文件的inode号是同一个，说明它们是同一个文件；而软链接建立的是一个指向，即链接文件内的内容是指向原文件的指针，它们是两个文件。 软链接可以跨文件系统，硬链接不可以；软链接可以对一个不存在的文件名(filename)进行链接（当然此时如果你vi这个软链接文件，linux会自动新建一个文件名为filename的文件）,硬链接不可以（其文件必须存在，inode必须存在）； 软链接可以对目录进行连接，硬链接不可以。两种链接都可以通过命令 ln 来创建。ln 默认创建的是硬链接。使用 -s 开关可以创建软链接。 参考： https://baike.baidu.com/item/%E7%A1%AC%E9%93%BE%E6%8E%A5]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux jps]]></title>
    <url>%2FLinux%2Fcommand%2Fjps%2Fck0xy27ck004kksv7lmcytfzg.html</url>
    <content type="text"><![CDATA[jps(Java Virtual Machine Process Status Tool) 说明：java提供的一个显示当前所有java进程pid的命令，适合在linux/unix平台上简单察看当前java进程的一些简单情况。它的作用是显示当前系统的java进程情况及进程id。我们可以通过它来查看我们到底启动了几个java进程（因为每一个java程序都会独占一个java虚拟机实例）并可通过opt来查看这些进程的详细启动参数。 使用方法：在当前命令行下打jps(jps存放在JAVA_HOME/bin/jps，使用时为了方便需将JAVA_HOME/bin/加入到Path) 。 12[root@hadoop-centos-01 bin]# jps13594 Jps 常用参数： 123456789101112131415-q 只显示pid，不显示class名称,jar文件名和传递给main方法的参数 [root@hadoop-centos-01 bin]# jps -q 13669-m 输出传递给main方法的参数，在嵌入式jvm上可能是null [root@hadoop-centos-01 bin]# jps -m 13716 Jps -m-l 输出应用程序main class的完整package名或者应用程序的jar文件完整路径名 [root@hadoop-centos-01 bin]# jps -l 13762 sun.tools.jps.Jps-v 输出传递给JVM的参数 [root@hadoop-centos-01 bin]# jps -v 13812 Jps -Denv.class.path=/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.212.b04-0.el7_6.x86_64/lib:/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.212.b04-0.el7_6.x86_64/jre/lib: -Dapplication.home=/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.212.b04-0.el7_6.x86_64 -Xms8m]]></content>
      <categories>
        <category>Linux</category>
        <category>command</category>
        <category>jps</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>command</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 查看系统版本]]></title>
    <url>%2FLinux%2Fcommand%2Fifconfig%2Fck0xy26yx001lksv7hbdn7awl.html</url>
    <content type="text"><![CDATA[linux系统版本信息（Oracle Linux、Centos Linux、Redhat Linux、Debian、Ubuntu）； 1、 查看Linux内核版本命令（两种方法）： 方法一 命令：cat /proc/version 12[root@hadoop-centos-01 ~]# cat /proc/versionLinux version 3.10.0-957.el7.x86_64 (mockbuild@kbuilder.bsys.centos.org) (gcc version 4.8.5 20150623 (Red Hat 4.8.5-36) (GCC) ) #1 SMP Thu Nov 8 23:39:32 UTC 2018 方法二 命令：uname -a 12[root@hadoop-centos-01 ~]# uname -aLinux hadoop-centos-01 3.10.0-957.el7.x86_64 #1 SMP Thu Nov 8 23:39:32 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux 2、 查看Linux系统版本的命令（3种方法）： 方法一 命令：cat /etc/redhat-release 1234[root@hadoop-centos-01 ~]# cat /etc/redhat-releaseCentOS Linux release 7.6.1810 (Core) 注：只适合Redhat系的Linux 方法二 命令：cat /etc/issue 123[root@hadoop-centos-01 ~]# cat /etc/issue\SKernel \r on an \m 注：此命令也适用于所有的Linux发行版。 方法三 命令：lsb_release -a 结果：无 注：适用于所有的Linux发行版，包括RedHat、SUSE、Debian…等发行版 附： lsb_release 显示发行版本信息 LSB是Linux Standard Base的缩写， lsb_release命令 用来显示LSB和特定版本的相关信息。如果使用该命令时不带参数，则默认加上-v参数。 -v 显示版本信息。 -i 显示发行版的id。 -d 显示该发行版的描述信息。 -r 显示当前系统是发行版的具体版本号。 -c 发行版代号。 -a 显示上面的所有信息。 -h 显示帮助信息。 如果当前发行版是LSB兼容的，那么/etc/lsb_release文件中会包含LSB_VERSION域。这个域的值可以是用冒号隔开的一系列支持的模块。这些模块名是当前版本支持的LSB的模块名。如果当前版本不是LSB兼容的，就不要包含这个域。 可选的域包括DISTRIB_ID, DISTRIB_RELEASE, DISTRIB_CODENAME,DISTRIB_DESCRIPTION，它们可以覆盖/etc/distrib-release文件中的内容。 注：这里的distrib要替换为当前的发行版的名字。如果存在/etc/lsb-release.d目录，会在该目录中查找文件名并作为附加的模块版本加在LSB_VERSION前面。文件/etc/distrib-release中包含了一些描述信息，用来说明应该分析哪些文件名。 一般的格式是Distributor release x.x (Codename) 注意：Debian系统中缺乏相应的描述信息（见/etc/debian-version），为了支持Debian系统，大部分信息都被加在了lsb-release文件中。 redhat和fedora系统中，还支持一个参数： -s, --short 输出简短的描述信息。 reference https://ipcmen.com/lsb_release]]></content>
      <categories>
        <category>Linux</category>
        <category>command</category>
        <category>ifconfig</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>command</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo 添加DaoVoice实现在线联系]]></title>
    <url>%2Fhexo%2Fck0xy270l002bksv7scddjyjf.html</url>
    <content type="text"><![CDATA[注册登录DaoVoice注册地址: http://www.daovoice.io/]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux ping command]]></title>
    <url>%2FLinux%2Fcommand%2Fping%2Fck0xy27de004wksv7cixe3ysi.html</url>
    <content type="text"><![CDATA[作用：网络命令，用来测试与目标主机的连通性。 场景：ping一下某机器，看是不是开着，如不能打开网页时会说“你先ping网关地址192.168.1.1试试” 原理：通过发送ICMP ECHO_REQUEST数据包到网络主机（send ICMP ECHO_REQUEST to network hosts），并显示响应情况，这样我们就可以根据它输出的信息来确定目标主机是否可访问（但这不是绝对的）。有些服务器为了防止通过ping探测到，通过防火墙设置了禁止ping或者在内核参数中禁止ping，这样就不能通过ping确定该主机是否还处于开启状态。 用法： 命令格式：ping [参数] [主机名或IP地址] 命令功能： 确定网络和各外部主机的状态； 跟踪和隔离硬件和软件问题； 测试、评估和管理网络。 实现原理： 如果主机正在运行并连在网上，它就对回送信号进行响应。每个回送信号请求包含一个网际协议（IP）和 ICMP 头，后面紧跟一个 tim 结构，以及来填写这个信息包的足够的字节。缺省情况是连续发送回送信号请求直到接收到中断信号（Ctrl-C）。 ping 命令每秒发送一个数据报并且为每个接收到的响应打印一行输出。ping 命令计算信号往返时间和(信息)包丢失情况的统计信息，并且在完成之后显示一个简要总结。ping 命令在程序超时或当接收到 SIGINT 信号时结束。Host 参数或者是一个有效的主机名或者是因特网地址。 命令参数： -d：使用Socket的SO_DEBUG功能；-c&lt;完成次数&gt;：设置完成要求回应的次数；-f：极限检测；-i&lt;间隔秒数&gt;：指定收发信息的间隔时间；-I&lt;网络界面&gt;：使用指定的网络界面送出数据包；-l&lt;前置载入&gt;：设置在送出要求信息之前，先行发出的数据包；-n：只输出数值；-p&lt;范本样式&gt;：设置填满数据包的范本样式；-q：不显示指令执行过程，开头和结尾的相关信息除外；-r：忽略普通的Routing Table，直接将数据包送到远端主机上；-R：记录路由过程；-s&lt;数据包大小&gt;：设置数据包的大小；-t&lt;存活数值&gt;：设置存活数值TTL的大小；-v：详细显示指令的执行过程。 示例 1234567[root@hadoop-centos-01 ~]# ping www.baidu.comPING www.a.shifen.com (182.61.200.7) 56(84) bytes of data.64 bytes from 182.61.200.7 (182.61.200.7): icmp_seq=1 ttl=128 time=1169 ms64 bytes from 182.61.200.7 (182.61.200.7): icmp_seq=2 ttl=128 time=1178 ms64 bytes from 182.61.200.7 (182.61.200.7): icmp_seq=3 ttl=128 time=1138 ms64 bytes from 182.61.200.7 (182.61.200.7): icmp_seq=4 ttl=128 time=1095 ms64 bytes from 182.61.200.7 (182.61.200.7): icmp_seq=5 ttl=128 time=1496 ms]]></content>
      <categories>
        <category>Linux</category>
        <category>command</category>
        <category>ping</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>command</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux grep command]]></title>
    <url>%2FLinux%2Fcommand%2Fgrep%2Fck0xy27jr007lksv7rwxm9wid.html</url>
    <content type="text"><![CDATA[作用grep（global search regular expression(RE) and print out the line，全面搜索正则表达式并把行打印出来）是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。 语法及选项12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970[root@hadoop-centos-01 ~]# grep --helpUsage: grep [OPTION]... PATTERN [FILE]...Search for PATTERN in each FILE or standard input.PATTERN is, by default, a basic regular expression (BRE).Example: grep -i &apos;hello world&apos; menu.h main.cRegexp selection and interpretation: -E, --extended-regexp PATTERN is an extended regular expression (ERE) -F, --fixed-strings PATTERN is a set of newline-separated fixed strings -G, --basic-regexp PATTERN is a basic regular expression (BRE) -P, --perl-regexp PATTERN is a Perl regular expression -e, --regexp=PATTERN use PATTERN for matching -f, --file=FILE obtain PATTERN from FILE -i, --ignore-case ignore case distinctions -w, --word-regexp force PATTERN to match only whole words -x, --line-regexp force PATTERN to match only whole lines -z, --null-data a data line ends in 0 byte, not newlineMiscellaneous: -s, --no-messages suppress error messages -v, --invert-match select non-matching lines -V, --version display version information and exit --help display this help text and exitOutput control: -m, --max-count=NUM stop after NUM matches -b, --byte-offset print the byte offset with output lines -n, --line-number print line number with output lines --line-buffered flush output on every line -H, --with-filename print the file name for each match -h, --no-filename suppress the file name prefix on output --label=LABEL use LABEL as the standard input file name prefix -o, --only-matching show only the part of a line matching PATTERN -q, --quiet, --silent suppress all normal output --binary-files=TYPE assume that binary files are TYPE; TYPE is &apos;binary&apos;, &apos;text&apos;, or &apos;without-match&apos; -a, --text equivalent to --binary-files=text -I equivalent to --binary-files=without-match -d, --directories=ACTION how to handle directories; ACTION is &apos;read&apos;, &apos;recurse&apos;, or &apos;skip&apos; -D, --devices=ACTION how to handle devices, FIFOs and sockets; ACTION is &apos;read&apos; or &apos;skip&apos; -r, --recursive like --directories=recurse -R, --dereference-recursive likewise, but follow all symlinks --include=FILE_PATTERN search only files that match FILE_PATTERN --exclude=FILE_PATTERN skip files and directories matching FILE_PATTERN --exclude-from=FILE skip files matching any file pattern from FILE --exclude-dir=PATTERN directories that match PATTERN will be skipped. -L, --files-without-match print only names of FILEs containing no match -l, --files-with-matches print only names of FILEs containing matches -c, --count print only a count of matching lines per FILE -T, --initial-tab make tabs line up (if needed) -Z, --null print 0 byte after FILE nameContext control: -B, --before-context=NUM print NUM lines of leading context -A, --after-context=NUM print NUM lines of trailing context -C, --context=NUM print NUM lines of output context -NUM same as --context=NUM --group-separator=SEP use SEP as a group separator --no-group-separator use empty string as a group separator --color[=WHEN], --colour[=WHEN] use markers to highlight the matching strings; WHEN is &apos;always&apos;, &apos;never&apos;, or &apos;auto&apos; -U, --binary do not strip CR characters at EOL (MSDOS/Windows) -u, --unix-byte-offsets report offsets as if CRs were not there (MSDOS/Windows) -a 不要忽略二进制数据。-A&lt;显示列数&gt; 除了显示符合范本样式的那一行之外，并显示该行之后的内容。-b 在显示符合范本样式的那一行之外，并显示该行之前的内容。-c 计算符合范本样式的列数。-C&lt;显示列数&gt;或-&lt;显示列数&gt; 除了显示符合范本样式的那一列之外，并显示该列之前后的内容。-d&lt;进行动作&gt; 当指定要查找的是目录而非文件时，必须使用这项参数，否则grep命令将回报信息并停止动作。-e&lt;范本样式&gt; 指定字符串作为查找文件内容的范本样式。-E 将范本样式为延伸的普通表示法来使用，意味着使用能使用扩展正则表达式。-f&lt;范本文件&gt; 指定范本文件，其内容有一个或多个范本样式，让grep查找符合范本条件的文件内容，格式为每一列的范本样式。-F 将范本样式视为固定字符串的列表。-G 将范本样式视为普通的表示法来使用。-h 在显示符合范本样式的那一列之前，不标示该列所属的文件名称。-H 在显示符合范本样式的那一列之前，标示该列的文件名称。-i 忽略字符大小写的差别。-l 列出文件内容符合指定的范本样式的文件名称。-L 列出文件内容不符合指定的范本样式的文件名称。-n 在显示符合范本样式的那一列之前，标示出该列的编号。-q 不显示任何信息。-R/-r 此参数的效果和指定“-d recurse”参数相同。-s 不显示错误信息。-v 反转查找。-w 只显示全字符合的列。-x 只显示全列符合的列。-y 此参数效果跟“-i”相同。-o 只输出文件中匹配到的部分。 常见用法搜索文件中包含 match_pattern 的文本行语法 1234grep match_pattern file_name1 fie_name2 ...grep &quot;match_pattern&quot; file_name1 fie_name2 ...注：match_pattern中若有空格等，请将其用双引号（&quot;&quot;）括起来，匹配文件可以是多个，中间用空格分开 示例 123[root@hadoop-centos-01 ~]# grep &quot;bin/bash&quot; /etc/passwdroot:x:0:0:root:/root:/bin/bashhadoop:x:1000:1000:hadoop:/home/hadoop:/bin/bash 输出除匹配之外的所有行 -v 选项 12345678[root@hadoop-centos-01 test]# grep -v &quot;bin/bash&quot; /etc/passwdbin:x:1:1:bin:/bin:/sbin/nologindaemon:x:2:2:daemon:/sbin:/sbin/nologinadm:x:3:4:adm:/var/adm:/sbin/nologinlp:x:4:7:lp:/var/spool/lpd:/sbin/nologinsync:x:5:0:sync:/sbin:/bin/syncshutdown:x:6:0:shutdown:/sbin:/sbin/shutdown... 标记匹配颜色 –color=auto 选项 1grep &quot;match_pattern&quot; file_name --color=auto 使用正则表达式 -E 选项 123grep -E &quot;[1-9]+&quot;或egrep &quot;[1-9]+&quot; 1234567[root@hadoop-centos-01 test]# echo this is a test line. | grep -o -E &quot;[a-z]+\.&quot;line.[root@hadoop-centos-01 test]# echo this is a test line. | egrep -o &quot;[a-z]+\.&quot;line.注: -o 选项只输出文件中匹配到的部分 统计文件或者文本中包含匹配字符串的总行数 -c 选项 1grep -c &quot;text&quot; file_name 12[root@hadoop-centos-01 test]# grep -c &apos;bin/bash&apos; /etc/passwd2 输出包含匹配字符串的行数 -n 选项： 123456grep &quot;text&quot; -n file_name或cat file_name | grep &quot;text&quot; -n#多个文件grep &quot;text&quot; -n file_1 file_2 123[root@hadoop-centos-01 test]# grep -n &apos;bin/bash&apos; /etc/passwd1:root:x:0:0:root:/root:/bin/bash43:hadoop:x:1000:1000:hadoop:/home/hadoop:/bin/bash 打印样式匹配所位于的字符或字节偏移 123456[root@hadoop-centos-01 test]# echo gun is not unix | grep -b -o &quot;not&quot;7:not注：一行中字符串的字符是从该行的第一个字符开始计算，起始值为0。选项 -b -o 一般总是配合使用。 -b 在显示符合范本样式的那一行之外，并显示该行之前的内容。 -o 只输出文件中匹配到的部分。 搜索多个文件并查找匹配文本在哪些文件中 1grep -l &quot;text&quot; file1 file2 file3... grep递归搜索文件在多级目录中对文本进行递归搜索 1grep &quot;text&quot; . -r -n # .表示当前目录。 1234[root@hadoop-centos-01 test]# grep love . -r -n./ts.txt:1:He likes his lover./ts.txt:2:He loves his lover./ts.txt:4:She loves her liker 忽略匹配样式中的字符大小写 12[root@hadoop-centos-01 test]# echo &quot;hello world&quot; | grep -i &quot;HELLO&quot;hello world 选项 -e 进行多个匹配样式 1234567[root@hadoop-centos-01 test]# echo this is a text line | grep -e &quot;is&quot; -e &quot;line&quot; -oisisline[root@hadoop-centos-01 test]# echo this is a text line | grep -e &quot;is&quot; -e &quot;line&quot; -n1:this is a text line 在grep搜索结果中包括或者排除指定文件 12345678#只在目录中所有的.php和.html文件中递归搜索字符&quot;main()&quot;grep &quot;main()&quot; . -r --include *.&#123;php,html&#125;#在搜索结果中排除所有README文件grep &quot;main()&quot; . -r --exclude &quot;README&quot;#在搜索结果中排除filelist文件列表里的文件grep &quot;main()&quot; . -r --exclude-from filelist Reference https://man.linuxde.net/grep]]></content>
      <categories>
        <category>Linux</category>
        <category>command</category>
        <category>grep</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>command</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo 添加页面萌宠]]></title>
    <url>%2Fhexo%2Fck0xy2711002jksv75yi4vzml.html</url>
    <content type="text"><![CDATA[安装Live2D插件在hexo根目录下执行以下命令 1234567891011121314151617181920212223242526npm install --save hexo-helper-live2dnpm install xxx # xxx 为下载的model# model 列表live2d-widget-model-chitoselive2d-widget-model-epsilon2_1live2d-widget-model-gflive2d-widget-model-haru/01 (use npm install --save live2d-widget-model-haru)live2d-widget-model-haru/02 (use npm install --save live2d-widget-model-haru)live2d-widget-model-harutolive2d-widget-model-hibikilive2d-widget-model-hijikilive2d-widget-model-izumilive2d-widget-model-koharulive2d-widget-model-mikulive2d-widget-model-ni-jlive2d-widget-model-nicolive2d-widget-model-nietzschelive2d-widget-model-nipsilonlive2d-widget-model-nitolive2d-widget-model-shizukulive2d-widget-model-tororolive2d-widget-model-tsumikilive2d-widget-model-unitychanlive2d-widget-model-wankolive2d-widget-model-z16 Config向Hexo的 _config.yml 文件或主题的 _config.yml 文件中添加配置. 123456789101112131415161718live2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ tagMode: false log: false model: use: live2d-widget-model-wanko display: position: right width: 150 height: 300 mobile: show: true react: opacity: 0.7 12345678910111213141516171819# Live2D## https://github.com/EYHN/hexo-helper-live2dlive2d: enable: true # enable: false scriptFrom: local # 默认 pluginRootPath: live2dw/ # 插件在站点上的根目录(相对路径) pluginJsPath: lib/ # 脚本文件相对与插件根目录路径 pluginModelPath: assets/ # 模型文件相对与插件根目录路径 # scriptFrom: jsdelivr # jsdelivr CDN # scriptFrom: unpkg # unpkg CDN # scriptFrom: https://cdn.jsdelivr.net/npm/live2d-widget@3.x/lib/L2Dwidget.min.js # 你的自定义 url tagMode: false # 标签模式, 是否仅替换 live2d tag标签而非插入到所有页面中 debug: false # 调试, 是否在控制台输出日志 model: use: live2d-widget-model-wanko # npm-module package name # use: wanko # 博客根目录/live2d_models/ 下的目录名 # use: ./wives/wanko # 相对于博客根目录的路径 # use: https://cdn.jsdelivr.net/npm/live2d-widget-model-wanko@1.0.5/assets/wanko.model.json # 你的自定义 url 重新生成并部署12$ hexo clean$ hexo g -d 详细教程 中文版：https://github.com/EYHN/hexo-helper-live2d/blob/master/README.zh-CN.md 英文版：https://github.com/EYHN/hexo-helper-live2d/blob/master/README.md 看板娘图片： https://blog.csdn.net/wang_123_zy/article/details/87181892#_1 https://huaji8.top/post/live2d-plugin-2.0/]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo 添加页面点击特效]]></title>
    <url>%2Fhexo%2Fck0xy2717002mksv736nutmps.html</url>
    <content type="text"><![CDATA[本文主要介绍点击页面出现心形图标。 红心 鼠标的点击红心特效如下： 在/themes/next/source/js/src下新建文件 clicklove.js，接着把下面的代码拷贝粘贴到 clicklove.js 文件中： 1!function(e,t,a)&#123;function n()&#123;c(&quot;.heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: &apos;&apos;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;&quot;),o(),r()&#125;function r()&#123;for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText=&quot;left:&quot;+d[e].x+&quot;px;top:&quot;+d[e].y+&quot;px;opacity:&quot;+d[e].alpha+&quot;;transform:scale(&quot;+d[e].scale+&quot;,&quot;+d[e].scale+&quot;) rotate(45deg);background:&quot;+d[e].color+&quot;;z-index:99999&quot;);requestAnimationFrame(r)&#125;function o()&#123;var t=&quot;function&quot;==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a=t.createElement(&quot;div&quot;);a.className=&quot;heart&quot;,d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a=t.createElement(&quot;style&quot;);a.type=&quot;text/css&quot;;try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName(&quot;head&quot;)[0].appendChild(a)&#125;function s()&#123;return&quot;rgb(&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;)&quot;&#125;var d=[];e.requestAnimationFrame=function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document); 在\themes\next\layout_layout.swig文件末尾添加： 12&lt;!-- 页面点击小红心 --&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/clicklove.js&quot;&gt;&lt;/script&gt; fireworks 鼠标的点击红心特效如下： 在themes/next/source/js/src里面建一个叫fireworks.js的文件，添加如下代码： 1&quot;use strict&quot;;function updateCoords(e)&#123;pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top&#125;function setParticuleDirection(e)&#123;var t=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return&#123;x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)&#125;&#125;function createParticule(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function()&#123;ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()&#125;,a&#125;function createCircle(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color=&quot;#F00&quot;,a.radius=0.1,a.alpha=0.5,a.lineWidth=6,a.draw=function()&#123;ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1&#125;,a&#125;function renderParticule(e)&#123;for(var t=0;t&lt;e.animatables.length;t++)&#123;e.animatables[t].target.draw()&#125;&#125;function animateParticules(e,t)&#123;for(var a=createCircle(e,t),n=[],i=0;i&lt;numberOfParticules;i++)&#123;n.push(createParticule(e,t))&#125;anime.timeline().add(&#123;targets:n,x:function(e)&#123;return e.endPos.x&#125;,y:function(e)&#123;return e.endPos.y&#125;,radius:0.1,duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule&#125;).add(&#123;targets:a,radius:anime.random(80,160),lineWidth:0,alpha:&#123;value:0,easing:&quot;linear&quot;,duration:anime.random(600,800)&#125;,duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule,offset:0&#125;)&#125;function debounce(e,t)&#123;var a;return function()&#123;var n=this,i=arguments;clearTimeout(a),a=setTimeout(function()&#123;e.apply(n,i)&#125;,t)&#125;&#125;var canvasEl=document.querySelector(&quot;.fireworks&quot;);if(canvasEl)&#123;var ctx=canvasEl.getContext(&quot;2d&quot;),numberOfParticules=30,pointerX=0,pointerY=0,tap=&quot;mousedown&quot;,colors=[&quot;#FF1461&quot;,&quot;#18FF92&quot;,&quot;#5A87FF&quot;,&quot;#FBF38C&quot;],setCanvasSize=debounce(function()&#123;canvasEl.width=2*window.innerWidth,canvasEl.height=2*window.innerHeight,canvasEl.style.width=window.innerWidth+&quot;px&quot;,canvasEl.style.height=window.innerHeight+&quot;px&quot;,canvasEl.getContext(&quot;2d&quot;).scale(2,2)&#125;,500),render=anime(&#123;duration:1/0,update:function()&#123;ctx.clearRect(0,0,canvasEl.width,canvasEl.height)&#125;&#125;);document.addEventListener(tap,function(e)&#123;&quot;sidebar&quot;!==e.target.id&amp;&amp;&quot;toggle-sidebar&quot;!==e.target.id&amp;&amp;&quot;A&quot;!==e.target.nodeName&amp;&amp;&quot;IMG&quot;!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))&#125;,!1),setCanvasSize(),window.addEventListener(&quot;resize&quot;,setCanvasSize,!1)&#125;&quot;use strict&quot;;function updateCoords(e)&#123;pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top&#125;function setParticuleDirection(e)&#123;var t=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return&#123;x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)&#125;&#125;function createParticule(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function()&#123;ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()&#125;,a&#125;function createCircle(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color=&quot;#F00&quot;,a.radius=0.1,a.alpha=0.5,a.lineWidth=6,a.draw=function()&#123;ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1&#125;,a&#125;function renderParticule(e)&#123;for(var t=0;t&lt;e.animatables.length;t++)&#123;e.animatables[t].target.draw()&#125;&#125;function animateParticules(e,t)&#123;for(var a=createCircle(e,t),n=[],i=0;i&lt;numberOfParticules;i++)&#123;n.push(createParticule(e,t))&#125;anime.timeline().add(&#123;targets:n,x:function(e)&#123;return e.endPos.x&#125;,y:function(e)&#123;return e.endPos.y&#125;,radius:0.1,duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule&#125;).add(&#123;targets:a,radius:anime.random(80,160),lineWidth:0,alpha:&#123;value:0,easing:&quot;linear&quot;,duration:anime.random(600,800)&#125;,duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule,offset:0&#125;)&#125;function debounce(e,t)&#123;var a;return function()&#123;var n=this,i=arguments;clearTimeout(a),a=setTimeout(function()&#123;e.apply(n,i)&#125;,t)&#125;&#125;var canvasEl=document.querySelector(&quot;.fireworks&quot;);if(canvasEl)&#123;var ctx=canvasEl.getContext(&quot;2d&quot;),numberOfParticules=30,pointerX=0,pointerY=0,tap=&quot;mousedown&quot;,colors=[&quot;#FF1461&quot;,&quot;#18FF92&quot;,&quot;#5A87FF&quot;,&quot;#FBF38C&quot;],setCanvasSize=debounce(function()&#123;canvasEl.width=2*window.innerWidth,canvasEl.height=2*window.innerHeight,canvasEl.style.width=window.innerWidth+&quot;px&quot;,canvasEl.style.height=window.innerHeight+&quot;px&quot;,canvasEl.getContext(&quot;2d&quot;).scale(2,2)&#125;,500),render=anime(&#123;duration:1/0,update:function()&#123;ctx.clearRect(0,0,canvasEl.width,canvasEl.height)&#125;&#125;);document.addEventListener(tap,function(e)&#123;&quot;sidebar&quot;!==e.target.id&amp;&amp;&quot;toggle-sidebar&quot;!==e.target.id&amp;&amp;&quot;A&quot;!==e.target.nodeName&amp;&amp;&quot;IMG&quot;!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))&#125;,!1),setCanvasSize(),window.addEventListener(&quot;resize&quot;,setCanvasSize,!1)&#125;; 打开themes/next/layout/_layout.swig,在L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/01/assets/haru01.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.7}});上面写下如下代码： 12345 &#123;% if theme.fireworks %&#125; &lt;canvas class=&quot;fireworks&quot; style=&quot;position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;&quot; &gt;&lt;/canvas&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;//cdn.bootcss.com/animejs/2.2.0/anime.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/fireworks.js&quot;&gt;&lt;/script&gt; &#123;% endif %&#125; 打开主题配置文件，在里面最后写下： 12# Fireworksfireworks: true]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo 增加浏览次数与访客数量统计功能]]></title>
    <url>%2Fhexo%2Fconfig%2Fck0xy271k002rksv7to2yfpph.html</url>
    <content type="text"><![CDATA[以NexT主题（其他主题类似）为例 安装busuanzi.js脚本 在 /theme/next/layout/_partial/footer.swig文件开头添加下面的代码： 1&lt;script async src=&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; 显示统计标签 编辑 /themes/next/_config.yml（主题配置文件）文件：在 footer（通过查找定位）下面添加如下内容，注意缩进： 1234footer: # 用于控制浏览次数和访问数量显示与否 counter: enable: true 在 /theme/next/layout/_partial/footer.swig文件结尾添加下面的代码： 12345&#123;% if theme.footer.counter &amp;&amp; theme.footer.counter.enable %&#125; &lt;span id=&quot;busuanzi_container_site_pv&quot;&gt;总访问量&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次&lt;/span&gt; &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt; &lt;span id=&quot;busuanzi_container_site_uv&quot;&gt;总访客数&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;人&lt;/span&gt;&#123;% endif %&#125; 附录 不蒜子是一款用来记录访客和访问量的插件，其可直接将访问次数显示在您在网页上（也可不显示）；对于已经上线一段时间的网站，“不蒜子”允许您初始化首次数据。不蒜子有两种算法可选： 算法a：pv的方式，单个用户连续点击n篇文章，记录n次访问量。 123&lt;span id=&quot;busuanzi_container_site_pv&quot;&gt; 本站总访问量&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次&lt;/span&gt; 算法b：uv的方式，单个用户连续点击n篇文章，只记录1次访客数。 &lt;span id=&quot;busuanzi_container_site_uv&quot;&gt; 本站访客数&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;人次 &lt;/span&gt;]]></content>
      <categories>
        <category>hexo</category>
        <category>config</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git 不同仓库间进行项目迁移]]></title>
    <url>%2Fgit%2Fck0xy270d0028ksv7hex3u4lv.html</url>
    <content type="text"><![CDATA[需求 将仓库A的某个branch的代码独立成为一个新的仓库B。并且提交的代码为当前分支最新的，且保留整个提交历史。这种需求对于git来说小菜一碟，可通过git remote命令来实现。 实现 拉取仓库A当前分支(例如 master 分支)，保持其为最新的 123456789git pull origin master # 拉取远程master分支的代码注：origin 代表远程仓库，其指向当前仓库的git地址, git remote 可进行查看，如下：$ git remoteorigin$ git remote -vorigin https://github.com/forgetST/blog.git (fetch)origin https://github.com/forgetST/blog.git (push) 创建仓库B(例如 test)，若不存在 在仓库A（blog）中增加仓库B的远程地址，即git地址 123456789101112131415# 当前只关联了一个远程仓库A$ git remote -vorigin https://github.com/forgetST/blog.git (fetch)origin https://github.com/forgetST/blog.git (push)# 关联远程仓库B(test)# test只是别名，可以随意起，但不能与已有远程名同名，至于原因，大家都想自己是独一无二的吗^-^$ git remote add test https://github.com/forgetST/test.git# 仓库test已关联成功$ git remote -vorigin https://github.com/forgetST/blog.git (fetch)origin https://github.com/forgetST/blog.git (push)test https://github.com/forgetST/test.git (fetch)test https://github.com/forgetST/test.git (push) 仓库A（blog）代码推送到仓库A（test） 12$ git push test master # 一般会失败，错误见附录$ git push -f test master # 强制推送，有风险，慎用 附录 git remote add 用法： 12345678910usage: git remote add [&lt;options&gt;] &lt;name&gt; &lt;url&gt; -f, --fetch fetch the remote branches --tags import all tags and associated objects when fetching or do not fetch any tag at all (--no-tags) -t, --track &lt;branch&gt; branch(es) to track -m, --master &lt;branch&gt; master branch --mirror[=(push|fetch)] set up remote as a mirror to push to or fetch from *git push origin_name origin_branch出错 * 1234567891011$ git push test masterTo https://github.com/forgetST/test.git ! [rejected] master -&gt; master (fetch first)error: failed to push some refs to &apos;https://github.com/forgetST/test.git&apos;hint: Updates were rejected because the remote contains work that you dohint: not have locally. This is usually caused by another repository pushinghint: to the same ref. You may want to first integrate the remote changeshint: (e.g., &apos;git pull ...&apos;) before pushing again.hint: See the &apos;Note about fast-forwards&apos; in &apos;git push --help&apos; for details.注：当前分支有改动，可新建新的分支进行推送，新建分支不能与推送的仓库已有分支重名。或者强制推送，加选项 -f，视情况而用（慎用）。]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux pkill command]]></title>
    <url>%2FLinux%2Fcommand%2Fpkill%2Fck0xy27do0050ksv78himr3vn.html</url>
    <content type="text"><![CDATA[作用pkill 用做管理进程时，pkill 命令和 killall 命令的用法相同，都是通过进程名杀死一类进程pkill 另一重要的功能就是按照终端用户来剔出用户登录 用法 语法格式 1pkill [options] pattern 参数选项 123456789101112131415161718192021222324-&lt;sig&gt;, --signal &lt;sig&gt; signal to send (either number or name)-e, --echo display what is killed-c, --count count of matching processes-f, --full use full process name to match-g, --pgroup &lt;PGID,...&gt; match listed process group IDs-G, --group &lt;GID,...&gt; match real group IDs-n, --newest select most recently started-o, --oldest select least recently started-P, --parent &lt;PPID,...&gt; match only child processes of the given parent-s, --session &lt;SID,...&gt; match session IDs-t, --terminal &lt;tty,...&gt; match by controlling terminal-u, --euid &lt;ID,...&gt; match by effective IDs-U, --uid &lt;ID,...&gt; match by real IDs-x, --exact match exactly with the command name-F, --pidfile &lt;file&gt; read PIDs from file-L, --logpidfile fail if PID file is not locked--ns &lt;PID&gt; match the processes that belong to the same namespace as &lt;pid&gt;--nslist &lt;ns,...&gt; list which namespaces will be considered for the --ns option. Available namespaces: ipc, mnt, net, pid, user, uts -h, --help display this help and exit-V, --version output version information and exi 用法示例 用做进程管理，根据进程名杀死一类进程 语法格式 1pkill [信号] 进程名 命令常用的信号及其含义 信号编号 信号名 含义 0 EXIT 程序退出时收到该信息。 1 HUP 挂掉电话线或终端连接的挂起信号，这个信号也会造成某些进程在没有终止的情况下重新初始化。 2 INT 表示结束进程，但并不是强制性的，常用的 “Ctrl+C” 组合键发出就是一个 kill -2 的信号。 3 QUIT 退出。 9 KILL 杀死进程，即强制结束进程。 11 SEGV 段错误。 15 TERM 正常结束进程，是 kill 命令的默认信号。 用法示例 12345678910111213# 查看python进程[root@hadoop-centos-01 ~]# pstree -p | grep python | |-sshd(33793)---bash(33803)---python(34176)[root@hadoop-centos-01 ~]#[root@hadoop-centos-01 ~]# ps -ef | grep pythonroot 34176 33803 0 22:30 pts/2 00:00:00 pythonroot 34188 33542 0 22:31 pts/1 00:00:00 grep --color=auto python# 执行pkill后再去查看，python进程已被杀死[root@hadoop-centos-01 ~]# pkill -kill python[root@hadoop-centos-01 ~]# pstree -p | grep python[root@hadoop-centos-01 ~]# ps -ef | grep pythonroot 34241 33542 0 22:33 pts/1 00:00:00 grep --color=auto python 踢出登陆用户 语法格式 1pkill [-t 终端号] 进程名 用法示例 12345678910111213141516[root@hadoop-centos-01 ~]# w # 查看当前登陆的用户 22:47:54 up 1 day, 16:20, 4 users, load average: 0.00, 0.01, 0.05USER TTY FROM LOGIN@ IDLE JCPU PCPU WHATroot pts/0 192.168.244.6 08:03 14:43m 0.13s 0.13s -bashroot pts/1 192.168.244.6 21:56 2.00s 0.41s 0.01s wroot pts/2 192.168.244.6 22:03 18.00s 0.10s 0.10s -bashroot pts/3 192.168.244.6 06:35 14:43m 0.17s 0.17s -bash[root@hadoop-centos-01 ~]#[root@hadoop-centos-01 ~]# pkill -kill -t pts/2[root@hadoop-centos-01 ~]# w # 再次查看，pts/2已被杀掉 22:51:26 up 1 day, 16:24, 3 users, load average: 0.01, 0.02, 0.05USER TTY FROM LOGIN@ IDLE JCPU PCPU WHATroot pts/0 192.168.244.6 08:03 14:46m 0.13s 0.13s -bashroot pts/1 192.168.244.6 21:56 6.00s 0.43s 0.02s wroot pts/3 192.168.244.6 06:35 14:47m 0.17s 0.17s -bash]]></content>
      <categories>
        <category>Linux</category>
        <category>command</category>
        <category>pkill</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>command</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux ps command]]></title>
    <url>%2FLinux%2Fcommand%2Fps%2Fck0xy27dv0053ksv72e2vsesx.html</url>
    <content type="text"><![CDATA[作用ps 命令是Process Status的缩写，用于进程的监测和控制。 ps 命令是最基本进程查看命令，使用该命令可以确定有哪些进程正在运行和运行的状态、进程是否结束、进程有没有僵尸、哪些进程占用了过多的资源等。 ps 命令显示的是瞬间进程的状态，并不是动态连续的；如果想对进程进行实时监控可用top命令。 用法命令格式1ps [options] [--help] 命令参数1234567891011121314[root@hadoop-centos-01 ~]# ps --help simpleUsage: ps [options]Basic options: -A, -e all processes -a all with tty, except session leaders a all with tty, including other users -d all except session leaders -N, --deselect negate selection r only running processes T all processes on this terminal x processes without controlling tty 123456789101112131415161718192021[root@hadoop-centos-01 ~]# ps --help listUsage: ps [options]Selection by list: -C &lt;command&gt; command name -G, --Group &lt;GID&gt; real group id or name -g, --group &lt;group&gt; session or effective group name -p, p, --pid &lt;PID&gt; process id --ppid &lt;PID&gt; parent process id -q, q, --quick-pid &lt;PID&gt; process id (quick mode) -s, --sid &lt;session&gt; session id -t, t, --tty &lt;tty&gt; terminal -u, U, --user &lt;UID&gt; effective user id or name -U, --User &lt;UID&gt; real user id or name The selection options take as their argument either: a comma-separated list e.g. &apos;-u root,nobody&apos; or a blank-separated list e.g. &apos;-p 123 4567&apos; 12345678910111213141516171819202122232425262728293031[root@hadoop-centos-01 ~]# ps --help outputUsage: ps [options]Output formats: -F extra full -f full-format, including command lines f, --forest ascii art process tree -H show process hierarchy -j jobs format j BSD job control format -l long format l BSD long format -M, Z add security data (for SELinux) -O &lt;format&gt; preloaded with default columns O &lt;format&gt; as -O, with BSD personality -o, o, --format &lt;format&gt; user-defined format s signal format u user-oriented format v virtual memory format X register format -y do not show flags, show rss vs. addr (used with -l) --context display security context (for SELinux) --headers repeat header lines, one per page --no-headers do not print header at all --cols, --columns, --width &lt;num&gt; set screen width --rows, --lines &lt;num&gt; set screen height 12345678910[root@hadoop-centos-01 ~]# ps --help threadsUsage: ps [options]Show threads: H as if they were processes -L possibly with LWP and NLWP columns -m, m after processes -T possibly with SPID column 12345678910111213141516171819[root@hadoop-centos-01 ~]# ps --help miscUsage: ps [options]Miscellaneous options: -c show scheduling class with -l option c show true command name e show the environment after command k, --sort specify sort order as: [+|-]key[,[+|-]key[,...]] L show format specifiers n display numeric uid and wchan S, --cumulative include some dead child process data -y do not show flags, show rss (only with -l) -V, V, --version display version information and exit -w, w unlimited output width --help &lt;simple|list|output|threads|misc|all&gt; display help and exit 用法示例123456789101112131415161718192021222324252627282930313233343536To see every process on the system using standard syntax: ps -e ps -ef ps -eF ps -elyTo see every process on the system using BSD syntax: ps ax ps axuTo print a process tree: ps -ejH ps axjfTo get info about threads: ps -eLf ps axmsTo get security info: ps -eo euser,ruser,suser,fuser,f,comm,label ps axZ ps -eMTo see every process running as root (real &amp; effective ID) in user format: ps -U root -u root uTo see every process with a user-defined format: ps -eo pid,tid,class,rtprio,ni,pri,psr,pcpu,stat,wchan:14,comm ps axo stat,euid,ruid,tty,tpgid,sess,pgrp,ppid,pid,pcpu,comm ps -Ao pid,tt,user,fname,tmout,f,wchanPrint only the process IDs of syslogd: ps -C syslogd -o pid=Print only the name of PID 42: ps -q 42 -o comm= 附录Linux上进程有5种状态 运行 – 正在运行或在运行队列中等待 中断 – 休眠中, 受阻, 在等待某个条件的形成或接受到信号 不可中断 – 收到信号不唤醒和不可运行, 进程必须等待直到有中断发生 僵死 – 进程已终止, 但进程描述符存在, 直到父进程调用wait4()系统调用后释放 停止 – 进程收到SIGSTOP, SIGSTP, SIGTIN, SIGTOU信号后停止运行运行 ps工具标识进程的5种状态码 R 运行 runnable (on run queue) S 中断 sleeping D 不可中断 uninterruptible sleep (usually IO) Z 僵死 a defunct (”zombie”) process T 停止 traced or stopped ps命令输出信息含义 表头 含义 USER 该进程是由哪个用户产生的。 PID 进程的 ID。 %CPU 该进程占用 CPU 资源的百分比，占用的百分比越高，进程越耗费资源。 %MEM 该进程占用物理内存的百分比，占用的百分比越高，进程越耗费资源。 VSZ 该进程占用虚拟内存的大小，单位为 KB。 RSS 该进程占用实际物理内存的大小，单位为 KB。 TTY 该进程是在哪个终端运行的。其中，tty1 ~ tty7 代表本地控制台终端（可以通过 Alt+F1 ~ F7 快捷键切换不同的终端），tty1~tty6 是本地的字符界面终端，tty7 是图形终端。pts/0 ~ 255 代表虚拟终端，一般是远程连接的终端，第一个远程连接占用 pts/0，第二个远程连接占用 pts/1，依次増长。 STAT 进程状态。常见的状态有以下几种：-D：不可被唤醒的睡眠状态，通常用于 I/O 情况。-R：该进程正在运行。-S：该进程处于睡眠状态，可被唤醒。-T：停止状态，可能是在后台暂停或进程处于除错状态。-W：内存交互状态（从 2.6 内核开始无效）。-X：死掉的进程（应该不会出现）。-Z：僵尸进程。进程已经中止，但是部分程序还在内存当中。-&lt;：高优先级（以下状态在 BSD 格式中出现）。-N：低优先级。-L：被锁入内存。-s：包含子进程。-l：多线程（小写 L）。-+：位于后台。 START 该进程的启动时间。 TIME 该进程占用 CPU 的运算时间，注意不是系统时间。 COMMAND 产生此进程的命令名。]]></content>
      <categories>
        <category>Linux</category>
        <category>command</category>
        <category>ps</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>command</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python __future__ module]]></title>
    <url>%2Fpython%2Fmodule%2Fck0xy27f0005gksv7xbxj2mu2.html</url>
    <content type="text"><![CDATA[简介将下一个新版本的特性导入到当前版本并进行测试（新版的改动不兼容老版本，就是这么任性）。 py2.7-源代码: Lib/__future__.py py3.7-源代码：Lib/__future__.py 属性python2.7123&gt;&gt;&gt; import __future__ as ft&gt;&gt;&gt; dir(ft)[&apos;CO_FUTURE_ABSOLUTE_IMPORT&apos;, &apos;CO_FUTURE_DIVISION&apos;, &apos;CO_FUTURE_PRINT_FUNCTION&apos;, &apos;CO_FUTURE_UNICODE_LITERALS&apos;, &apos;CO_FUTURE_WITH_STATEMENT&apos;, &apos;CO_GENERATOR_ALLOWED&apos;, &apos;CO_NESTED&apos;, &apos;_Feature&apos;, &apos;__all__&apos;, &apos;__builtins__&apos;, &apos;__doc__&apos;, &apos;__file__&apos;, &apos;__name__&apos;, &apos;__package__&apos;, &apos;absolute_import&apos;, &apos;all_feature_names&apos;, &apos;division&apos;, &apos;generators&apos;, &apos;nested_scopes&apos;, &apos;print_function&apos;, &apos;unicode_literals&apos;, &apos;with_statement&apos;] python3.7123&gt;&gt;&gt; import __future__ as ft&gt;&gt;&gt; dir(ft) [&apos;CO_FUTURE_ABSOLUTE_IMPORT&apos;, &apos;CO_FUTURE_ANNOTATIONS&apos;, &apos;CO_FUTURE_BARRY_AS_BDFL&apos;, &apos;CO_FUTURE_DIVISION&apos;, &apos;CO_FUTURE_GENERATOR_STOP&apos;, &apos;CO_FUTURE_PRINT_FUNCTION&apos;, &apos;CO_FUTURE_UNICODE_LITERALS&apos;, &apos;CO_FUTURE_WITH_STATEMENT&apos;, &apos;CO_GENERATOR_ALLOWED&apos;, &apos;CO_NESTED&apos;, &apos;_Feature&apos;, &apos;__all__&apos;, &apos;__builtins__&apos;, &apos;__cached__&apos;, &apos;__doc__&apos;, &apos;__file__&apos;, &apos;__loader__&apos;, &apos;__name__&apos;, &apos;__package__&apos;, &apos;__spec__&apos;, &apos;absolute_import&apos;, &apos;all_feature_names&apos;, &apos;annotations&apos;, &apos;barry_as_FLUFL&apos;, &apos;division&apos;, &apos;generator_stop&apos;, &apos;generators&apos;, &apos;nested_scopes&apos;, &apos;print_function&apos;, &apos;unicode_literals&apos;, &apos;with_statement&apos;] __future__.py 中的每一条语句都是以下格式的： 1FeatureName = _Feature(OptionalRelease, MandatoryRelease, CompilerFlag) OptionalRelease 和 MandatoryRelease 的格式为 5 元素元组，如下： 123456(PY_MAJOR_VERSION, # the 2 in 2.1.0a3; an int PY_MINOR_VERSION, # the 1; an int PY_MICRO_VERSION, # the 0; an int PY_RELEASE_LEVEL, # &quot;alpha&quot;, &quot;beta&quot;, &quot;candidate&quot; or &quot;final&quot;; string PY_RELEASE_SERIAL # the 3; an int) OptionalRelease 记录一个特性首次发布时的 Python 版本。 MandatoryRelases 未发布时，表示该特性会变成语言的一部分的预测时间。 发布后，用来记录这个特性是何时成为语言的一部分的。从该版本往后，使用该特性将不需要 future 语句，不过很多人还是会加上对应的 import。 若是 None, 表示这个特性已经被撤销。 CompilerFlag 若代码需要动态编译，在调用内建函数compile() 时需传入以开启对应的特性，其存储在对应实例的compiler_flag变量中。 __future__ 中不会删除特性的描述。从 Python 2.1 中首次加入以来，通过这种方式引入了以下特性： 特性 可选版本 强制加入版本 效果 nested_scopes 2.1.0b1 2.2 PEP 227: Statically Nested Scopes generators 2.2.0a1 2.3 PEP 255: Simple Generators division 2.2.0a2 3.0 PEP 238: Changing the Division Operator absolute_import 2.5.0a1 3.0 PEP 328: Imports: Multi-Line and Absolute/Relative with_statement 2.5.0a1 2.6 PEP 343: The “with” Statement print_function 2.6.0a2 3.0 PEP 3105: Make print a function unicode_literals 2.6.0a2 3.0 PEP 3112: Bytes literals in Python 3000 generator_stop 3.5.0b1 3.7 PEP 479: StopIteration handling inside generators annotations 3.7.0b1 4.0 PEP 563: Postponed evaluation of annotations 用法divisionpython 2.7示例： 123456789# Python 2.x中，对于除法有两种情况，如果是整数相除，结果仍是整数，余数会被扔掉，这种除法叫“地板除”&gt;&gt;&gt; 10 / 33&gt;&gt;&gt; 10.0 / 3 3.3333333333333335&gt;&gt;&gt; from __future__ import division # 导入后除法将变为精确除法&gt;&gt;&gt; 10 / 33.3333333333333335 12345# Python 3.x中，所有的除法都是精确除法，地板除用//表示&gt;&gt;&gt; 10 / 3 3.3333333333333335&gt;&gt;&gt; 10 // 3 3 unicode_literalspython2.7示例： 123456789101112131415&gt;&gt;&gt; type(&apos;hello world&apos;)&lt;type &apos;str&apos;&gt;&gt;&gt;&gt; type(b&apos;hello world&apos;)&lt;type &apos;str&apos;&gt;&gt;&gt;&gt; type(u&apos;hello world&apos;)&lt;type &apos;unicode&apos;&gt;# python3 默认字符编码为 unicode， 类型为 str&gt;&gt;&gt; from __future__ import unicode_literals&gt;&gt;&gt; type(&apos;hello world&apos;)&lt;type &apos;unicode&apos;&gt;&gt;&gt;&gt; type(b&apos;hello world&apos;)&lt;type &apos;str&apos;&gt;&gt;&gt;&gt; type(u&apos;hello world&apos;)&lt;type &apos;unicode&apos;&gt; python3.7示例： 123456&gt;&gt;&gt; type(&apos;hello world&apos;) &lt;class &apos;str&apos;&gt;&gt;&gt;&gt; type(b&apos;hello world&apos;) &lt;class &apos;bytes&apos;&gt;&gt;&gt;&gt; type(u&apos;hello world&apos;) &lt;class &apos;str&apos;&gt; 注：如果你是python2.X版本，在导入新的功能特性后，就应该按照新功能的特性进行编写。 absolute_import加入绝对引入新特性]]></content>
      <categories>
        <category>python</category>
        <category>module</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>module</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux killall command]]></title>
    <url>%2FLinux%2Fcommand%2Fkillall%2Fck0xy27d1004rksv7p97yi4et.html</url>
    <content type="text"><![CDATA[作用killall - kill processes by name killall sends a signal to all processes running any of the specified commands. If no signal name is specified, SIGTERM is sent. Signals can be specified either by name (e.g. -HUP or -SIGHUP) or by number (e.g. -1) or by option -s. If the command name is not regular expression (option -r) and contains a slash (/), processes executing that particular file will be selected for killing, independent of their name. killall returns a zero return code if at least one process has been killed for each listed command, or no commands were listed and at least one process matched the -u and -Z search criteria. killall returns non-zero otherwise. A killall process never kills itself (but may kill other killall processes) 用法命令格式123killall [-Z CONTEXT] [-u USER] [ -eIgiqrvw ] [ -SIGNAL ] NAME...killall -l, --listkillall -V, --version 命令参数12345678910111213141516-e,--exact require exact match for very long names-I,--ignore-case case insensitive process name match-g,--process-group kill process group instead of process-y,--younger-than kill processes younger than TIME-o,--older-than kill processes older than TIME-i,--interactive ask for confirmation before killing-l,--list list all known signal names-q,--quiet don&apos;t print complaints-r,--regexp interpret NAME as an extended regular expression-s,--signal SIGNAL send this signal instead of SIGTERM-u,--user USER kill only process(es) running as USER-v,--verbose report if the signal was successfully sent-V,--version display version information-w,--wait wait for processes to die-Z,--context REGEXP kill only process(es) having context (must precede other arguments) 123456789101112131415-e,--exact 精准匹配。由于命令名长于15个字符时，会杀死匹配前15个字符的所有进程。此时需要使用-e选项进行精准匹配。-g,--process-group 杀死属于该进程组的所有进程。-i,--interactive 交互式，杀死进程前请求确认-I,--ignore-case 进程名匹配不区分大小写-l,--list 列出所有信号名-o,--older-than 仅匹配指定时间之前（在指定时间之前开始）的进程。单位s、m、h、d、w（周）、M、y-q,--quiet 静默模式，不报错-r,--regexp 使用扩展正则表达式解释name-s,--signal 发送指定信号等同[-signal]-u.--user 仅终止指定用户拥有的进程。命令名是可选的。-v,--verbose 报告是否发送成功-V,version 显示版本-w,--wait 等待killall执行完成，每秒检测一次，直到完成返回。如果信号被忽略或不起作用，或停留在僵尸状态，killall会永久等待。-y,--younger-than 仅匹配指定时间之后的进程，与-o选项相反。-z,--context （仅限SELinux）指定环境（变量）：仅杀死含有与指定扩展正则表达式匹配的环境（变量）的进程。必须在其他参数之前，命令名是可选的。 用法示例查看版本 12345678[root@hadoop-centos-01 ~]# killall -Vkillall (PSmisc) 22.20Copyright (C) 1993-2012 Werner Almesberger and Craig SmallPSmisc comes with ABSOLUTELY NO WARRANTY.This is free software, and you are welcome to redistribute it underthe terms of the GNU General Public License.For more information about these matters, see the files named COPYING. 查看信号列表 1234[root@hadoop-centos-01 ~]# killall -lHUP INT QUIT ILL TRAP ABRT IOT BUS FPE KILL USR1 SEGV USR2 PIPE ALRM TERMSTKFLT CHLD CONT STOP TSTP TTIN TTOU URG XCPU XFSZ VTALRM PROF WINCH IO PWR SYSUNUSED 常用的信号说明： HUP（1，终端断线）， INT（2，中断，同&lt;Ctrl&gt;+c） QUIT（3，退出，同&lt;Ctrl&gt;+\） KILL（9，强制终止） TERM（15，缺省信号，终止，正常结束） CONT（18，继续，同fg/bg命令） STOP（19，停止） TSTP（20，暂停，同&lt;Ctrl&gt;+Z） 杀死所有同名进程 12345678910111213[root@hadoop-centos-01 ~]# ps -aux | grep pythonroot 32618 0.0 0.0 112708 980 pts/0 S+ 07:18 0:00 grep --color=auto python# 启动一个python后台进程[root@hadoop-centos-01 ~]# ps -aux | grep pythonroot 32619 0.2 0.5 130456 5040 pts/3 S+ 07:18 0:00 pythonroot 32621 0.0 0.0 112708 980 pts/0 S+ 07:18 0:00 grep --color=auto python# 执行 killall python 命令， 等效于 killall -15 python[root@hadoop-centos-01 ~]# killall python# 再次过滤发现该进程以终止[root@hadoop-centos-01 ~]# ps -aux | grep pythonroot 32624 0.0 0.0 112708 980 pts/0 S+ 07:18 0:00 grep --color=auto python 向进程发送指定信号 123456789101112131415161718[root@hadoop-centos-01 ~]# ps -aux | grep pythonroot 32670 0.1 0.5 130456 5044 pts/3 T 07:22 0:00 pythonroot 32684 0.0 0.0 112708 980 pts/0 S+ 07:23 0:00 grep --color=auto python[root@hadoop-centos-01 ~]# killall python; ps -aux | grep pythonroot 32670 0.0 0.5 130456 5044 pts/3 T 07:22 0:00 pythonroot 32734 0.0 0.0 112708 980 pts/0 S+ 07:26 0:00 grep --color=auto python# 正常无法终止进程时，需要强制终止，需发送指定信号，终止进程[root@hadoop-centos-01 ~]# killall -9 pythonPython 2.7.15 (default, May 17 2019, 07:26:27)[GCC 4.8.5 20150623 (Red Hat 4.8.5-36)] on linux2Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt;[1]+ Stopped python[root@hadoop-centos-01 ~]# ps -aux | grep pythonroot 32766 0.0 0.0 112708 980 pts/0 S+ 07:29 0:00 grep --color=auto python 杀掉所有的登录后的shell 123456[root@hadoop-centos-01 ~]# killall -9 bashSession stopped - Press &lt;return&gt; to exit tab - Press R to restart session - Press S to save terminal output to file]]></content>
      <categories>
        <category>Linux</category>
        <category>command</category>
        <category>killall</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>command</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux kill command]]></title>
    <url>%2FLinux%2Fcommand%2Fkill%2Fck0xy27cr004nksv7qfw5cvv0.html</url>
    <content type="text"><![CDATA[作用kill 命令是用来向进程发送一个用户指定的信号，对进程进行相应的操作。 kill 命令的执行原理是向操作系统内核发送一个信号（多是终止信号）和目标进程的 PID，系统内核根据收到的信号类型，对指定进程进行相应的操作。 进程PID可用ps、pidof、pstree、top等工具获取，然后使用kill命令来结束该进程。 用法命令格式123456kill [options] &lt;pid&gt; [...]options : -&lt;signal&gt; : 指定发送给进程的信号，指定信号的名称或号码都可以。 -l : 列出所有信号的名称和号码。&lt;pid&gt; […] : 把信号发送给列出的所有进程。 命令参数123456-l 参数为信号名称，显示该信号的数字。如果不加信号参数，显示全部信号名称-p 指定kill 命令只打印相关进程的进程号，而不发送任何信号-s 指定发送信号-u 指定用户-signal_name 指定进程发送信号名称-signal_number 指定进程发送信号数字 使用实例12345678910111213141516[root@hadoop-centos-01 ~]# kill -l 1) SIGHUP 2) SIGINT 3) SIGQUIT 4) SIGILL 5) SIGTRAP 6) SIGABRT 7) SIGBUS 8) SIGFPE 9) SIGKILL 10) SIGUSR111) SIGSEGV 12) SIGUSR2 13) SIGPIPE 14) SIGALRM 15) SIGTERM16) SIGSTKFLT 17) SIGCHLD 18) SIGCONT 19) SIGSTOP 20) SIGTSTP21) SIGTTIN 22) SIGTTOU 23) SIGURG 24) SIGXCPU 25) SIGXFSZ26) SIGVTALRM 27) SIGPROF 28) SIGWINCH 29) SIGIO 30) SIGPWR31) SIGSYS 34) SIGRTMIN 35) SIGRTMIN+1 36) SIGRTMIN+2 37) SIGRTMIN+338) SIGRTMIN+4 39) SIGRTMIN+5 40) SIGRTMIN+6 41) SIGRTMIN+7 42) SIGRTMIN+843) SIGRTMIN+9 44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+1348) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-1253) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9 56) SIGRTMAX-8 57) SIGRTMAX-758) SIGRTMAX-6 59) SIGRTMAX-5 60) SIGRTMAX-4 61) SIGRTMAX-3 62) SIGRTMAX-2[root@hadoop-centos-01 ~]# kill -l SIGRTMIN+1246 代号 名称 内容 1 SIGHUP 启动被终止的程序，可让该进程重新读取自己的配置文件，类似重新启动。 2 SIGINT 相当于用键盘输入 [ctrl]-c 来中断一个程序的进行。 9 SIGKILL 代表强制中断一个程序的进行，如果该程序进行到一半，那么尚未完成的部分可能会有“半产品”产生，类似 vim会有 .filename.swp 保留下来。 15 SIGTERM 以正常的方式来终止该程序。由于是正常的终止，所以后续的动作会将他完成。不过，如果该程序已经发生问题，就是无法使用正常的方法终止时，输入这个 signal 也是没有用的。 19 SIGSTOP 相当于用键盘输入 [ctrl]-z 来暂停一个程序的进行。 12[root@hadoop-centos-01 ~]# kill -15 pid# 这条命令发信号让进程正常退出。所谓的正常退出是指按应用程序自己的退出流程完成退出，这样就可以清理并释放资源。 12[root@hadoop-centos-01 ~]# kill -9 pid# 强制结束进程，这样结束掉的进程不会进行资源的清理工作。 12[root@hadoop-centos-01 ~]# kill -19 pid# 暂停进程 1234# 杀死指定用户所有进程[root@hadoop-centos-01 ~]# kill -9 $(ps -ef | grep username)# 或[root@hadoop-centos-01 ~]# kill -u username 总结kill命令可以带信号选项，也可以不带信号。如果没有信号号码，kill命令就会发出终止信号（15），该信号可以被进程捕获，使进程在退出之前可以清理并释放资源。也可以向进程发送发送指定信号； 可以向多个进程发信号或终止它们，当kill成功地发送了信号后，shell会在屏幕上显示出进程的终止信息； 应注意，信号使进程强行终止，这常会带来一些副作用，如数据丢失或者终端无法恢复到正常状态。发送信号时必须小心，只有在万不得已时，才用kill信号(9)，因为进程不能首先捕获它。要撤销所有的后台作业，可以输入kill 0。因为有些在后台运行的命令会启动多个进程，跟踪并找到所有要杀掉的进程的PID是件很麻烦的事。这时，使用kill 0来终止所有由当前shell启动的进程，是个有效的方法； kill 命令并不能100%终止进程，kill 命令只是“发送”一个信号，故只有当信号被程序成功“捕获”，系统才会执行 kill 命令指定的操作；反之，如果信号被“封锁”或者“忽略”，则 kill 命令将会失效。]]></content>
      <categories>
        <category>Linux</category>
        <category>command</category>
        <category>kill</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>command</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python glob module]]></title>
    <url>%2Fpython%2Fmodule%2Fck0xy27ee0059ksv7ion5qbi4.html</url>
    <content type="text"><![CDATA[简介glob —查找符合特定规则的文件路径名 Source code: Lib/glob.py 匹配符： * 匹配0个或多个字符 ? 匹配单个字符 [] 匹配指定范围内的字符，如：[0-9]匹配数字 属性python2.7123&gt;&gt;&gt; import glob&gt;&gt;&gt; dir(glob)[&apos;__all__&apos;, &apos;__builtins__&apos;, &apos;__doc__&apos;, &apos;__file__&apos;, &apos;__name__&apos;, &apos;__package__&apos;, &apos;_unicode&apos;, &apos;fnmatch&apos;, &apos;glob&apos;, &apos;glob0&apos;, &apos;glob1&apos;, &apos;has_magic&apos;, &apos;iglob&apos;, &apos;magic_check&apos;, &apos;os&apos;, &apos;re&apos;, &apos;sys&apos;] python3.7123&gt;&gt;&gt; import glob &gt;&gt;&gt; dir(glob) [&apos;__all__&apos;, &apos;__builtins__&apos;, &apos;__cached__&apos;, &apos;__doc__&apos;, &apos;__file__&apos;, &apos;__loader__&apos;, &apos;__name__&apos;, &apos;__package__&apos;, &apos;__spec__&apos;, &apos;_glob0&apos;, &apos;_glob1&apos;, &apos;_glob2&apos;, &apos;_iglob&apos;, &apos;_ishidden&apos;, &apos;_isrecursive&apos;, &apos;_iterdir&apos;, &apos;_rlistdir&apos;, &apos;escape&apos;, &apos;fnmatch&apos;, &apos;glob&apos;, &apos;glob0&apos;, &apos;glob1&apos;, &apos;has_magic&apos;, &apos;iglob&apos;, &apos;magic_check&apos;, &apos;magic_check_bytes&apos;, &apos;os&apos;, &apos;re&apos;] 用法1234567目录结构：D:\Practice： 1.gif 2.txt card.gif sub 3.txt python2.7glob.glob(pathname)根据路径名匹配模式，返回一个路径名列表，可能为空。 路径名应是包含路径规范的字符串，可以是相对路径，亦可是绝对路径，返回形式取决于匹配模式。 1234567891011121314151617&gt;&gt;&gt; import os&gt;&gt;&gt; import glob&gt;&gt;&gt; os.getcwd()&apos;D:\\Practice&apos;# 相对路径&gt;&gt;&gt; glob.glob(&apos;*.txt&apos;)[&apos;2.txt&apos;]&gt;&gt;&gt; glob.glob(&apos;[0-9].*&apos;)[&apos;1.gif&apos;, &apos;2.txt&apos;]# 绝对路径&gt;&gt;&gt; glob.glob(os.getcwd() + os.sep +&apos;*.txt&apos;)[&apos;D:\\Practice\\2.txt&apos;]&gt;&gt;&gt; glob.glob(os.getcwd() + os.sep +&apos;[0-9].*&apos;)[&apos;D:\\Practice\\1.gif&apos;, &apos;D:\\Practice\\2.txt&apos;] glob.iglob(pathname)根据路径名匹配模式，返回一个路径名列表的迭代器 python3.7glob.glob(pathname, *, recursive=False)根据路径名匹配模式，返回一个路径名列表，可能为空。 路径名应是包含路径规范的字符串，可以是相对路径，亦可是绝对路径，返回形式取决于匹配模式。 recursive为真，则模式“**”将匹配任何文件以及零个或多个目录和子目录。如果模式后面跟着一个os.sep，只有目录和子目录匹配。 123456789101112131415161718192021222324252627282930&gt;&gt;&gt; import os&gt;&gt;&gt; import glob&gt;&gt;&gt; os.getcwd()&apos;D:\\Practice&apos;&gt;&gt;&gt; os.listdir()[&apos;1.gif&apos;, &apos;2.txt&apos;, &apos;card.gif&apos;, &apos;sub&apos;]# 相对路径&gt;&gt;&gt; glob.glob(&apos;*.txt&apos;, recursive=False)[&apos;2.txt&apos;]&gt;&gt;&gt; glob.glob(&apos;[0-9].*&apos;， recursive=False)[&apos;1.gif&apos;, &apos;2.txt&apos;]# 绝对路径&gt;&gt;&gt; glob.glob(os.getcwd() + os.sep +&apos;*.txt&apos;, recursive=False)[&apos;D:\\Practice\\2.txt&apos;]&gt;&gt;&gt; glob.glob(os.getcwd() + os.sep +&apos;[0-9].*&apos;, recursive=False)[&apos;D:\\Practice\\1.gif&apos;, &apos;D:\\Practice\\2.txt&apos;]# 若recursive=True，需配合&quot;**&quot;使用&gt;&gt;&gt; glob.glob(&apos;**&apos; + os.sep + &apos;*.txt&apos;, recursive=True)[&apos;2.txt&apos;, &apos;sub\\3.txt&apos;]&gt;&gt;&gt; glob.glob(&apos;**&apos; + os.sep, recursive=True)[&apos;sub\\&apos;]&gt;&gt;&gt; glob.glob(&apos;.&apos; + os.sep + &apos;**&apos; + os.sep, recursive=True)[&apos;.\\&apos;, &apos;.\\sub\\&apos;]注： 在一个较大的目录树中使用 &quot;**&quot; 模式可能会消耗非常多的时间。 glob.iglob(pathname, *, recursive=False)根据路径名匹配模式，返回一个路径名列表的迭代器 escape(pathname)转义所有特殊字符。]]></content>
      <categories>
        <category>python</category>
        <category>module</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>module</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux netstat command]]></title>
    <url>%2FLinux%2Fcommand%2Fnetstat%2Fck0xy27jy007nksv7bkjvp4b5.html</url>
    <content type="text"><![CDATA[简介在Internet RFC标准中， Netstat是在内核中访问网络连接状态及其相关信息的程序，它能提供TCP连接，TCP和UDP监听，进程内存管理的相关报告。 Netstat 是控制台命令，是一个监控TCP/IP网络的非常有用的工具，它可以显示路由表、实际的网络连接以及每一个网络接口设备的状态信息。 Netstat 用于显示与IP、TCP、UDP和ICMP协议相关的统计数据，一般用于检验本机各端口的网络连接情况。 作用netstat 命令用于显示各种网络相关信息，如网络连接，路由表，接口状态 (Interface Statistics)，masquerade 连接，多播成员 (Multicast Memberships) 等等。 用法一般用netstat -an 来显示所有连接的端口并用数字表示。若使用时不带参数，netstat显示活动的 TCP 连接。 1234567891011121314[root@hadoop-centos-01 ~]# netstat | moreActive Internet connections (w/o servers)Proto Recv-Q Send-Q Local Address Foreign Address Statetcp 0 48 hadoop-centos-01:ssh 192.168.xxx.x:49299 ESTABLISHEDtcp 0 0 hadoop-centos-01:ssh 192.168.xxx.x:49304 ESTABLISHEDActive UNIX domain sockets (w/o servers)Proto RefCnt Flags Type State I-Node Pathunix 3 [ ] DGRAM 9134 /run/systemd/notifyunix 2 [ ] DGRAM 9136 /run/systemd/cgroups-agentunix 2 [ ] DGRAM 277787unix 3 [ ] STREAM CONNECTED 48707unix 3 [ ] STREAM CONNECTED 48794 /run/systemd/journal/stdoutunix 3 [ ] STREAM CONNECTED 36513 /run/systemd/journal/stdoutunix 3 [ ] STREAM CONNECTED 48948 @/tmp/dbus-iOMFhoTUUK 输出结果可分为两个部分： Active Internet connections（有源TCP连接） Proto ：显示连接使用的协议 Recv-Q ： 接收队列 Send-Q ： 发送队列 Local Address Foreign Address State 注： “Recv-Q”和”Send-Q”一般都应该是0。如果不是则表示软件包正在队列中堆积，这种情况非常少见。 Active UNIX domain sockets （有源Unix域套接口） Proto ：显示连接使用的协议 RefCnt ：表示连接到本套接口上的进程数量 Flags Type： 显示套接口的类型 State ：显示套接口当前的状态 I-Node Path ：表示连接到套接口的其它进程使用的路径名 语法格式 1234netstat [-vWeenNcCF] [&lt;Af&gt;] -r netstat &#123;-V|--version|-h|--help&#125; netstat [-vWnNcaeol] [&lt;Socket&gt; ...] netstat &#123; [-vWeenNac] -I[&lt;Iface&gt;] | [-veenNac] -i | [-cnNe] -M | -s [-6tuw] &#125; [delay] 参数选项 123456789101112131415161718192021222324-a或--all：显示所有连线中的Socket； -A&lt;网络类型&gt;或--&lt;网络类型&gt;：列出该网络类型连线中的相关地址； -c或--continuous：持续列出网络状态； -C或--cache：显示路由器配置的快取信息； -e或--extend：显示网络其他相关信息； -F或--fib：显示FIB； -g或--groups：显示多重广播功能群组组员名单； -h或--help：在线帮助； -i或--interfaces：显示网络界面信息表单； -l或--listening：显示监控中的服务器的Socket； -M或--masquerade：显示伪装的网络连线； -n或--numeric：直接使用ip地址，而不通过域名服务器； -N或--netlink或--symbolic：显示网络硬件外围设备的符号连接名称； -o或--timers：显示计时器； -p或--programs：显示正在使用Socket的程序识别码和程序名称； -r或--route：显示Routing Table； -s或--statistice：显示网络工作信息统计表； -t或--tcp：显示TCP传输协议的连线状况； -u或--udp：显示UDP传输协议的连线状况； -v或--verbose：显示指令执行过程； -V或--version：显示版本信息； -w或--raw：显示RAW传输协议的连线状况； -x或--unix：此参数的效果和指定&quot;-A unix&quot;参数相同； --ip或--inet：此参数的效果和指定&quot;-A inet&quot;参数相同。 参数示例 列出所有端口情况 123[root@hadoop-centos-01 ~]# netstat -a # 列出所有端口[root@hadoop-centos-01 ~]# netstat -au # 列出所有UDP端口[root@hadoop-centos-01 ~]# netstat -at # 列出所有TCP端口 列出所有处于监听状态的 Sockets 1234[root@hadoop-centos-01 ~]# netstat -l # 只显示监听端口[root@hadoop-centos-01 ~]# netstat -lt # 显示监听TCP端口[root@hadoop-centos-01 ~]# netstat -lu # 显示监听UDP端口[root@hadoop-centos-01 ~]# netstat -lx # 显示监听UNIX端口 显示每个协议的统计信息 123[root@hadoop-centos-01 ~]# netstat -s # 显示所有端口的统计信息[root@hadoop-centos-01 ~]# netstat -st # 显示所有TCP的统计信息[root@hadoop-centos-01 ~]# netstat -su # 显示所有UDP的统计信息 显示 PID 和进程名称 123456789101112[root@hadoop-centos-01 ~]# netstat -p | moreActive Internet connections (w/o servers)Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program nametcp 0 0 hadoop-centos-01:ssh 192.168.244.6:49299 ESTABLISHED 28069/sshd: root@pttcp 0 0 hadoop-centos-01:ssh 192.168.244.6:49304 ESTABLISHED 28073/sshd: root@noActive UNIX domain sockets (w/o servers)Proto RefCnt Flags Type State I-Node PID/Program name Pathunix 3 [ ] DGRAM 9134 1/systemd /run/systemd/notifyunix 3 [ ] STREAM CONNECTED 48948 7427/dbus-daemon @/tmp/dbus-iOMFhoTUUKunix 3 [ ] STREAM CONNECTED 48796 7568/gsd-powerunix 3 [ ] STREAM CONNECTED 48947 7571/gsd-rfkillunix 3 [ ] STREAM CONNECTED 37682 6618/abrt-watch-log 显示核心路由信息 123456789101112131415[root@hadoop-centos-01 ~]# netstat -rKernel IP routing tableDestination Gateway Genmask Flags MSS Window irtt Ifacedefault gateway 0.0.0.0 UG 0 0 0 ens33link-local 0.0.0.0 255.255.0.0 U 0 0 0 ens33192.168.122.0 0.0.0.0 255.255.255.0 U 0 0 0 virbr0192.168.244.0 0.0.0.0 255.255.255.0 U 0 0 0 ens33[root@hadoop-centos-01 ~]# netstat -rnKernel IP routing tableDestination Gateway Genmask Flags MSS Window irtt Iface0.0.0.0 192.168.244.2 0.0.0.0 UG 0 0 0 ens33169.254.0.0 0.0.0.0 255.255.0.0 U 0 0 0 ens33192.168.122.0 0.0.0.0 255.255.255.0 U 0 0 0 virbr0192.168.244.0 0.0.0.0 255.255.255.0 U 0 0 0 ens33 查看端口和服务 123456789101112131415[root@hadoop-centos-01 ~]# netstat -anp | grep sshtcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN 7039/sshdtcp 0 0 127.0.0.1:6010 0.0.0.0:* LISTEN 28069/sshd: root@pttcp 0 0 192.168.244.11:22 192.168.244.6:49299 ESTABLISHED 28069/sshd: root@pttcp 0 0 192.168.244.11:22 192.168.244.6:49304 ESTABLISHED 28073/sshd: root@notcp6 0 0 :::22 :::* LISTEN 7039/sshdtcp6 0 0 ::1:6010 :::* LISTEN 28069/sshd: root@ptunix 3 [ ] STREAM CONNECTED 42737 7039/sshdunix 2 [ ] DGRAM 278152 28069/sshd: root@ptunix 2 [ ] DGRAM 278281 28073/sshd: root@no[root@hadoop-centos-01 ~]# netstat -anp | grep 7039tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN 7039/sshdtcp6 0 0 :::22 :::* LISTEN 7039/sshdunix 3 [ ] STREAM CONNECTED 42737 7039/sshd]]></content>
      <categories>
        <category>Linux</category>
        <category>command</category>
        <category>netstat</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>command</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python 查找最大或最小的 N 个元素]]></title>
    <url>%2Fpython%2Ftips%2Fck0xy27nh0092ksv7rwisa0st.html</url>
    <content type="text"><![CDATA[查找最大或最小的 N 个元素 问题 获得一个列表(列表元素很多)中最大或者最小的 N 个元素列表？ 实现 当要查找的元素个数 N 相对比较小的时候 1234567891011&gt;&gt;&gt; import heapq&gt;&gt;&gt; nums = [1, 8, 2, 23, 7, -4, 18, 23, 42, 37, 2]# 取最大的 3 个数&gt;&gt;&gt; heapq.nlargest(3, nums)[42, 37, 23]# 取最小的 3 个数&gt;&gt;&gt; heapq.nsmallest(3, nums)[-4, 1, 2] 当要查找的元素个数 N 接近要查找的可迭代对象的长度时，出于性能考虑，可用切片替代 123456789&gt;&gt;&gt; nums = [1, 8, 2, 23, 7, -4, 18, 23, 42, 37, 2]# 取最大的 3 个数&gt;&gt;&gt; sorted(nums, reverse=True)[:3][42, 37, 23]# 取最小的 3 个数&gt;&gt;&gt; sorted(nums)[:3][-4, 1, 2] 当取一个最大值或最小值，通过 max 和min函数获得 123456789&gt;&gt;&gt; nums = [1, 8, 2, 23, 7, -4, 18, 23, 42, 37, 2]# 取最大数&gt;&gt;&gt; max(nums)42# 取最小数&gt;&gt;&gt; min(nums)-4 测试示例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&gt;&gt;&gt; import heapq&gt;&gt;&gt; import timeit&gt;&gt;&gt; import random&gt;&gt;&gt; nums = random.choices(range(50000), k=20000) &gt;&gt;&gt; len(nums)20000# ---------------------------------------------------------------------------------# 从nums中取10个最小的数# 通过 sorted(nums)[:10] 方式&gt;&gt;&gt; timeit.repeat(&apos;sorted(nums)[:10]&apos;, &apos;import heapq;from __main__ import nums&apos;, number=1000, repeat=3)[5.283976222000092, 5.281303266000577, 5.272159137000017] # 执行1000遍，重复3次用时列表# 通过heapq.nsmallest(10, nums) 方式&gt;&gt;&gt; timeit.repeat(&apos;heapq.nsmallest(10, nums)&apos;, &apos;import heapq;from __main__ import nums&apos;, number=1000, repeat=3)[1.1154322049997063, 1.065238846000284, 1.0126771430004737] # 执行1000遍，重复3次用时列表# ---------------------------------------------------------------------------------# 从nums中取10个最大的数# 通过 sorted(nums)[:10] 方式&gt;&gt;&gt; timeit.repeat(&apos;sorted(nums, reverse=True)[:10]&apos;, &apos;import heapq;from __main__ import nums&apos;, number=1000, repeat=3)[5.402307174000271, 5.62465228200017, 5.546984251999675]# 通过 heapq.nlargest(10, nums) 方式&gt;&gt;&gt; timeit.repeat(&apos;heapq.nlargest(10, nums)&apos;, &apos;import heapq;from __main__ import nums&apos;, number=1000, repeat=3) [1.0458967599997777, 1.060633938999672, 1.0392043130004822] # 执行1000遍，重复3次用时列表# ---------------------------------------------------------------------------------# 从nums中取10000个最小的数# 通过 sorted(nums)[:10000] 方式&gt;&gt;&gt; timeit.repeat(&apos;sorted(nums)[:10000]&apos;, &apos;import heapq;from __main__ import nums&apos;, number=1000, repeat=3)[5.616329210999538, 5.384628143000555, 5.36661329799972] # 执行1000遍，重复3次用时列表# 通过heapq.nsmallest(10000, nums) 方式&gt;&gt;&gt; timeit.repeat(&apos;heapq.nsmallest(10000, nums)&apos;, &apos;import heapq;from __main__ import nums&apos;, number=1000, repeat=3)[30.37623528200038, 30.471836461999374, 30.748560685000484] # 执行1000遍，重复3次用时列表# ---------------------------------------------------------------------------------# 从nums中取10000个最大的数# 通过 sorted(nums， reverse=True)[:10000] 方式&gt;&gt;&gt; timeit.repeat(&apos;sorted(nums, reverse=True)[:10000]&apos;, &apos;import heapq;from __main__ import nums&apos;, number=1000, repeat=3)[5.462146738999763, 5.569061694000084, 5.482768033999491] # 执行1000遍，重复3次用时列表# 通过 heapq.nlargest(10000, nums) 方式&gt;&gt;&gt; timeit.repeat(&apos;heapq.nlargest(10000, nums)&apos;, &apos;import heapq;from __main__ import nums&apos;, number=1000, repeat=3)[33.05006609500015, 30.762279339999623, 33.79276524299985] # 执行1000遍，重复3次用时列表]]></content>
      <categories>
        <category>python</category>
        <category>tips</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python timeit module]]></title>
    <url>%2Fpython%2Fmodule%2Fck0xy27f7005kksv70yjkm67t.html</url>
    <content type="text"><![CDATA[简介用于计算一小段 Python 代码耗时的模块。 源码： Lib/timeit.py 用法包含方法 1234&gt;&gt;&gt; import timeit&gt;&gt;&gt; timeit.__all__[&apos;Timer&apos;, &apos;timeit&apos;, &apos;repeat&apos;, &apos;default_timer&apos;] timeit.Timer(…)class timeit.Timer(stmt=’pass’, setup=’pass’, timer=&lt;timer function&gt;, globals=None) stmt：用于传入要测试时间的代码块，可以直接接受字符串的表达式，也可以接受单个变量或函数。传入函数时要把函数申明在当前文件中，然后在 stmt = ‘func()’ 执行函数，然后使用 setup = ‘from __main__ import func’ setup：传入stmt的运行环境，比如stmt中使用到的参数、变量，要导入的模块等。可以写一行语句，也可以写多行语句，写多行语句时要用分号;隔开语句。 timer：一个定时器函数，与平台有关。 globals： 参数指定用于执行代码的命名空间。 123456789101112&gt;&gt;&gt; import timeit# test function&gt;&gt;&gt; def f(x): max(x) &gt;&gt;&gt; nums = [1, 8, 2, 23, 7, -4, 18, 23, 42, 37, 2]# create timer object&gt;&gt;&gt; timer = timeit.Timer(stmt=&apos;f(nums)&apos;, setup=&apos;from __main__ import f, nums&apos;)&gt;&gt;&gt; [_ for _ in dir(timer) if not _.startswith(&apos;_&apos;)][&apos;autorange&apos;, &apos;inner&apos;, &apos;print_exc&apos;, &apos;repeat&apos;, &apos;src&apos;, &apos;timeit&apos;, &apos;timer&apos;] timeit.timeit(…)timeit.timeit(stmt=’pass’, setup=’pass’, timer=&lt;default timer&gt;, number=1000000, globals=None) 其余参数说明见 timeit.Timer number：要测试的代码的运行次数，默认100000次，对于耗时的代码，运行太多次会比较慢，此时建议自己修改一下运行次数 12&gt;&gt;&gt; timer.timeit(number=100)0.00013752799986832542 timeit.repeat(…)timeit.repeat(stmt=’pass’, setup=’pass’, timer=&lt;default timer&gt;, repeat=5, number=1000000, globals=None) 其余参数说明见 timeit.Timer repeat：指测试要重复几次，每次的结果构成列表返回，默认5次。 number：要测试的代码的运行次数，默认100000次。 12&gt;&gt;&gt; timer.repeat(number=100)[0.0002869599998120975, 0.00013793800007988466, 0.00012151600003562635, 0.00021511800014195614, 0.00019376999989617616] timeit.default_timer(…)默认的计时器，总是 time.perf_counter() 12&gt;&gt;&gt; timeit.default_timer()2506.128862259]]></content>
      <categories>
        <category>python</category>
        <category>module</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>module</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python 保留最后N个元素]]></title>
    <url>%2Fpython%2Ftips%2Fck0xy27lx008eksv7gd74686f.html</url>
    <content type="text"><![CDATA[保留最后 N 个元素 问题 在迭代操作或者其他操作的时候，怎样只保留最后有限几个元素的历史记录？ 实现 保留有限历史记录可通过 collections.deque 实现。例如下面的代码在多行上面做简单的文本匹配， 并返回匹配所在行的最后N行： 1234567891011121314151617from collections import dequedef search(lines, pattern, history=5): previous_lines = deque(maxlen=history) for line in lines: if pattern in line: yield line, previous_lines previous_lines.append(line) # Example use on a fileif __name__ == &apos;__main__&apos;: with open(r&apos;../../cookbook/somefile.txt&apos;) as f: for line, prevlines in search(f, &apos;python&apos;, 5): for pline in prevlines: print(pline, end=&apos;&apos;) print(line, end=&apos;&apos;) print(&apos;-&apos; * 20) deque 用法简述 1234567891011121314151617181920212223from collections import deque语法: deque([iterable[, maxlen]]) --&gt; deque object iterable：init iterable maxlen： maximum size of a deque or None if unbounded 方法: append(...) Add an element to the right side of the deque. appendleft(...) Add an element to the left side of the deque. clear(...) Remove all elements from the deque. copy(...) Return a shallow copy of a deque. count(...) D.count(value) -&gt; integer -- return number of occurrences of value extend(...) Extend the right side of the deque with elements from the iterable extendleft(...) Extend the left side of the deque with elements from the iterable index(...) D.index(value, [start, [stop]]) -&gt; integer -- return first index of value. Raises ValueError if the value is not present. insert(...) D.insert(index, object) -- insert object before index pop(...) Remove and return the rightmost element. popleft(...) Remove and return the leftmost element. remove(...) D.remove(value) -- remove first occurrence of value. reverse(...) D.reverse() -- reverse *IN PLACE* rotate(...) Rotate the deque n steps to the right (default n=1). If n is negative Reference&emsp;&emsp;https://python3-cookbook.readthedocs.io/zh_CN/latest/c01/p03_keep_last_n_items.html]]></content>
      <categories>
        <category>python</category>
        <category>tips</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python 解压序列赋值给多个变量]]></title>
    <url>%2Fpython%2Ftips%2Fck0xy27nb008zksv7llv133o9.html</url>
    <content type="text"><![CDATA[解压序列赋值给多个变量 问题 现在有一个包含 N 个元素的元组或者是序列，怎样将它里面的值解压后同时赋值给 N 个变量？ 实现 123456789101112131415161718# test_seq is sequence or iterable objects # 通过等长个数的变量赋值, 即变量个数等于 len(test_seq)var1, var2, var3, ... = test_seq # 取 test 首尾head, *_, tail = test_seq # 取 test_seq 指定个数的前3个数var1, var2, var3, *_ = test_seq # 取 test_seq 指定个数的后3个数*_, var1, var2, var3 = test_seq 注： 1. 任何的序列（或者是可迭代对象）可以通过一个简单的赋值语句解压并赋值给多个变量。 2. 变量的数量必须跟序列元素的数量是一样的。 3. *_ 会将剩余数据储存于一个列表中]]></content>
      <categories>
        <category>python</category>
        <category>tips</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML 笔记]]></title>
    <url>%2Fweb%2FHTML%2Fck0xy272q0032ksv76ovw9tio.html</url>
    <content type="text"><![CDATA[总得记点啥。。。 认识windows快捷键 Ctrl+c 复制 Ctrl+v 粘贴 Ctrl+x 剪切 Ctrl+a 全选 Ctrl+s 保存 Ctrl+z 撤销一步 Windows+d 返回桌面 Windows+e 我的电脑 Windows+r 打开运行 Alt+tab 切换软件 Ctrl+tab 软件文档之间的切换 F2 重命名 F5 刷新页面 认识大前端前端即网站前台部分，运行在 pc端、移动端 等浏览器上展现给用户浏览的网页。 前端核心技术：HTML、CSS、JavaScript HTML (Hyper Text Markup Language) —&gt; 结构 CSS (Cascading Style Sheet) —&gt; 样式 JavaScript —&gt; 行为动作 认识网页网页由文字、图片、输入框、视频、音频、超链接等组成。 web标准w3c 万维网联盟组织：用来制定web标准的机构（组织）web标准：制作网页要遵循的规范web标准规范的分类： 结构标准 —&gt; html，相当于人的身体 表现标准 —&gt; css，相当于人的衣服 行为标准 —&gt; javascript，相当于人的动作 浏览器浏览器 是网页运行的平台，常用的浏览器有IE、火狐（Firefox）、谷歌（Chrome）、Safari和Opera等。 扩展，待补充 。。。 初识HTMLhtml (Hyper Text Markup Language ) 中文译为“超文本标记语言”，主要是通过html标记对网页中的文本，图片，声音等内容进行描述。 HTML之所以称为超文本标记语言，不仅是因为他通过标记描述网页内容，同时也由于文本中包含了所谓的“超级链接”，通过超链接可以实现网页的跳转。从而构成了丰富多彩的Web页面。 HTML文件后缀名为 .html 或 .htm HTML结构标准123456789101112&lt;!DOCTYPE html&gt; # 声明文档类型&lt;html lang=&quot;en&quot;&gt; # 根标签&lt;head&gt; # 头标签 &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; # 标题标签&lt;/head&gt;&lt;body&gt; # 主题标签 。。。&lt;/body&gt;&lt;/html&gt; HTML标签分类单标签 单标签 注释标签 12&lt;!-- 注释内容 --&gt;注： 快捷键 Ctrl + / 换行标签 1&lt;br /&gt; 水平线标签 1&lt;hr /&gt; 图片标签 1&lt;img src=&quot;/path/filename&quot; alt=&quot;替代文字&quot; /&gt; 。。。。。。 双标签 双标签 段落标签 1&lt;p&gt;段落内容&lt;/p&gt; 标题标签 123&lt;h#&gt; 标题 &lt;/h#&gt;注： # 为 1-6 文本标签 1&lt;font&gt;文本内容&lt;/font&gt; 文本加粗标签 123&lt;strong&gt;文本内容&lt;/strong&gt; # 建议使用或&lt;b&gt;文本内容&lt;/b&gt; 下划线标签 123&lt;ins&gt;文本内容&lt;/ins&gt;或&lt;u&gt;文本内容&lt;/u&gt; 文本倾斜标签 123&lt;em&gt;文本内容&lt;/em&gt; # 建议使用或&lt;i&gt;文本内容&lt;/i&gt; 删除线标签 123&lt;del&gt;文本内容&lt;/del&gt; # 建议使用或&lt;s&gt;&lt;/s&gt; 超链接 1&lt;a href=&quot;link path&quot;&gt;链接名&lt;/a&gt; 。。。。。。 路径相对路径相对于文件自身出发的路径，就是相对路径。 绝对路径从根目录出发的路径，即位绝对路径。]]></content>
      <categories>
        <category>web</category>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python datetime module]]></title>
    <url>%2Fpython%2Fmodule%2Fck0xy27p1009pksv7wue7cdou.html</url>
    <content type="text"><![CDATA[Introductiondatetime Basic date and time types Source code: Lib/datetime.py The datetime module supplies classes for manipulating dates and times in both simple and complex ways. While date and time arithmetic is supported, the focus of the implementation is on efficient attribute extraction for output formatting and manipulation. For related functionality, see also the time and calendar modules. datetime include constants and available types 123&gt;&gt;&gt; import datetime&gt;&gt;&gt; dir(datetime)[&apos;MAXYEAR&apos;, &apos;MINYEAR&apos;, &apos;__builtins__&apos;, &apos;__cached__&apos;, &apos;__doc__&apos;, &apos;__file__&apos;, &apos;__loader__&apos;, &apos;__name__&apos;, &apos;__package__&apos;, &apos;__spec__&apos;, &apos;date&apos;, &apos;datetime&apos;, &apos;datetime_CAPI&apos;, &apos;sys&apos;, &apos;time&apos;, &apos;timedelta&apos;, &apos;timezone&apos;, &apos;tzinfo&apos;] The datetime module constantsdatetime.MINYEARThe smallest year number allowed in a date or datetime object. MINYEAR is 1. datatime.MAXYEARThe largest year number allowed in a date or datetime object. MAXYEAR is 9999. The datetime module available typesclass datetime.timedeltaA duration expressing the difference between two date, time, or datetime instances to microsecond resolution. class datetime.dateAn idealized naive date, assuming the current Gregorian calendar always was, and always will be, in effect. Attributes: year, month, and day. class datetime.timeAn idealized time, independent of any particular day, assuming that every day has exactly 246060 seconds (there is no notion of “leap seconds” here). Attributes: hour, minute, second, microsecond, and tzinfo. class datetime.datetimeA combination of a date and a time. Attributes: year, month, day, hour, minute, second, microsecond, and tzinfo. class datetime.tzinfoAn abstract base class for time zone information objects. These are used by the datetime and time classes to provide a customizable notion of time adjustment (for example, to account for time zone and/or daylight saving time). class datetime.timezoneA class that implements the tzinfo abstract base class as a fixed offset from the UTC. timedelta ObjectsA timedelta object represents a duration, the difference between two dates or times. 1class datetime.timedelta(days=0, seconds=0, microseconds=0, milliseconds=0, minutes=0, hours=0, weeks=0) All arguments are optional and default to 0. Arguments may be integers or floats, and may be positive or negative. Only days, seconds and microseconds are stored internally. Arguments are converted to those units: A millisecond is converted to 1000 microseconds. A minute is converted to 60 seconds. An hour is converted to 3600 seconds. A week is converted to 7 days. days, seconds and microseconds are then normalized so that the representation is unique, with 0 &lt;= microseconds &lt; 1000000 0 &lt;= seconds &lt; 3600*24 (the number of seconds in one day) -999999999 &lt;= days &lt;= 999999999 1234&gt;&gt;&gt; from datetime import timedelta &gt;&gt;&gt; dir(timedelta)[&apos;__abs__&apos;, &apos;__add__&apos;, &apos;__bool__&apos;, &apos;__class__&apos;, &apos;__delattr__&apos;, &apos;__dir__&apos;, &apos;__divmod__&apos;, &apos;__doc__&apos;, &apos;__eq__&apos;, &apos;__floordiv__&apos;, &apos;__format__&apos;, &apos;__ge__&apos;, &apos;__getattribute__&apos;, &apos;__gt__&apos;, &apos;__hash__&apos;, &apos;__init__&apos;, &apos;__init_subclass__&apos;, &apos;__le__&apos;, &apos;__lt__&apos;, &apos;__mod__&apos;, &apos;__mul__&apos;, &apos;__ne__&apos;, &apos;__neg__&apos;, &apos;__new__&apos;, &apos;__pos__&apos;, &apos;__radd__&apos;, &apos;__rdivmod__&apos;, &apos;__reduce__&apos;, &apos;__reduce_ex__&apos;, &apos;__repr__&apos;, &apos;__rfloordiv__&apos;, &apos;__rmod__&apos;, &apos;__rmul__&apos;, &apos;__rsub__&apos;, &apos;__rtruediv__&apos;, &apos;__setattr__&apos;, &apos;__sizeof__&apos;, &apos;__str__&apos;, &apos;__sub__&apos;, &apos;__subclasshook__&apos;, &apos;__truediv__&apos;, &apos;days&apos;, &apos;max&apos;, &apos;microseconds&apos;, &apos;min&apos;, &apos;resolution&apos;, &apos;seconds&apos;, &apos;total_seconds&apos;] Class attributestimedelta.minThe most negative timedelta object, timedelta(-999999999). 12&gt;&gt;&gt; timedelta.min datetime.timedelta(days=-999999999) timedelta.maxThe most positive timedelta object, timedelta(days=999999999, hours=23, minutes=59, seconds=59, microseconds=999999). 12&gt;&gt;&gt; timedelta.max datetime.timedelta(days=999999999, seconds=86399, microseconds=999999) timedelta.resolutionThe smallest possible difference between non-equal timedelta objects, timedelta(microseconds=1). 12&gt;&gt;&gt; timedelta.resolution datetime.timedelta(microseconds=1) Instance attributes (read-only)timedelta.daystimedelta.secondstimedelta.microseconds Attribute Value days Between -999999999 and 999999999 inclusive seconds Between 0 and 86399 inclusive microseconds Between 0 and 999999 inclusive 1234&gt;&gt;&gt; from datetime import timedelta&gt;&gt;&gt; d = timedelta(days=1,seconds=1,microseconds=1) &gt;&gt;&gt; (d.days, d.seconds, d.microseconds)(1, 1, 1) Instance methodstimedelta.total_seconds()Return the total number of seconds contained in the duration. Equivalent to td / timedelta(seconds=1). For interval units other than seconds, use the division form directly (e.g. td / timedelta(microseconds=1)). Note that for very large time intervals (greater than 270 years on most platforms) this method will lose microsecond accuracy. Example usage: 1234567891011121314151617181920&gt;&gt;&gt; from datetime import timedelta&gt;&gt;&gt; year = timedelta(days=365)&gt;&gt;&gt; another_year = timedelta(weeks=40, days=84, hours=23, minutes=50, seconds=600)&gt;&gt;&gt; year.total_seconds()31536000.0&gt;&gt;&gt; year == another_yearTrue&gt;&gt;&gt; ten_years = 10 * year&gt;&gt;&gt; ten_yearsdatetime.timedelta(3650)&gt;&gt;&gt; ten_years, ten_years.days // 365(datetime.timedelta(3650), 10)&gt;&gt;&gt; nine_years = ten_years - year&gt;&gt;&gt; nine_years, nine_years.days // 365(datetime.timedelta(3285), 9)&gt;&gt;&gt; three_years = nine_years // 3&gt;&gt;&gt; three_years, three_years.days // 365(datetime.timedelta(1095), 3)&gt;&gt;&gt; abs(three_years - ten_years) == 2 * three_years + yearTrue Supported operations123456789101112131415161718192021222324252627282930&gt;&gt;&gt; from datetime import timedelta&gt;&gt;&gt; t1 = timedelta(days=1,seconds=1,microseconds=1) &gt;&gt;&gt; t2 = timedelta(days=2,seconds=2,microseconds=2) &gt;&gt;&gt; t1 + t2 datetime.timedelta(days=3, seconds=3, microseconds=3)&gt;&gt;&gt; t2 - t1 datetime.timedelta(days=1, seconds=1, microseconds=1)&gt;&gt;&gt; t1 - t2 datetime.timedelta(days=-2, seconds=86398, microseconds=999999)&gt;&gt;&gt; 6 * t1 datetime.timedelta(days=6, seconds=6, microseconds=6)&gt;&gt;&gt; 6.6 * t1 datetime.timedelta(days=6, seconds=51846, microseconds=600007)&gt;&gt;&gt; abs(t1) datetime.timedelta(days=1, seconds=1, microseconds=1)&gt;&gt;&gt; abs(t1 - t2)datetime.timedelta(days=1, seconds=1, microseconds=1)# equivalent to +t when t.days &gt;= 0, and to -t when t.days &lt; 0. (2)&gt;&gt;&gt; str(t1) &apos;1 day, 0:00:01.000001&apos;# Returns a string in the form [D day[s], ][H]H:MM:SS[.UUUUUU], where D is negative for negative t. (5)&gt;&gt;&gt; repr(t1) &apos;datetime.timedelta(days=1, seconds=1, microseconds=1)&apos;# Returns a string representation of the timedelta object as a constructor call with canonical attribute values. In addition to the operations listed above timedelta objects support certain additions and subtractions with date and datetime objects . date ObjectsA date object represents a date (year, month and day) in an idealized calendar, the current Gregorian calendar indefinitely extended in both directions. January 1 of year 1 is called day number 1, January 2 of year 1 is called day number 2, and so on. 1class datetime.date(year, month, day) All arguments are required. Arguments may be integers, in the following ranges: MINYEAR &lt;= year &lt;= MAXYEAR 1 &lt;= month &lt;= 12 1 &lt;= day &lt;= number of days in the given month and year If an argument outside those ranges is given, ValueError is raised. 1234&gt;&gt;&gt; from datetime import date&gt;&gt;&gt; dir(date)[&apos;__add__&apos;, &apos;__class__&apos;, &apos;__delattr__&apos;, &apos;__dir__&apos;, &apos;__doc__&apos;, &apos;__eq__&apos;, &apos;__format__&apos;, &apos;__ge__&apos;, &apos;__getattribute__&apos;, &apos;__gt__&apos;, &apos;__hash__&apos;, &apos;__init__&apos;, &apos;__init_subclass__&apos;, &apos;__le__&apos;, &apos;__lt__&apos;, &apos;__ne__&apos;, &apos;__new__&apos;, &apos;__radd__&apos;, &apos;__reduce__&apos;, &apos;__reduce_ex__&apos;, &apos;__repr__&apos;, &apos;__rsub__&apos;, &apos;__setattr__&apos;, &apos;__sizeof__&apos;, &apos;__str__&apos;, &apos;__sub__&apos;, &apos;__subclasshook__&apos;, &apos;ctime&apos;, &apos;day&apos;, &apos;fromisoformat&apos;, &apos;fromordinal&apos;, &apos;fromtimestamp&apos;, &apos;isocalendar&apos;, &apos;isoformat&apos;, &apos;isoweekday&apos;, &apos;max&apos;, &apos;min&apos;, &apos;month&apos;, &apos;replace&apos;, &apos;resolution&apos;, &apos;strftime&apos;, &apos;timetuple&apos;, &apos;today&apos;, &apos;toordinal&apos;, &apos;weekday&apos;, &apos;year&apos;] Class attributesdate.minThe earliest representable date, date(MINYEAR, 1, 1). 1234&gt;&gt;&gt; from datetime import date&gt;&gt;&gt; date.min datetime.date(1, 1, 1) date.maxThe latest representable date, date(MAXYEAR, 12, 31). 1234&gt;&gt;&gt; from datetime import date&gt;&gt;&gt; date.maxdatetime.date(9999, 12, 31) date.resolutionThe smallest possible difference between non-equal date objects, timedelta(days=1). 1234&gt;&gt;&gt; from datetime import date&gt;&gt;&gt; date.resolutiondatetime.timedelta(days=1) Instance attributes (read-only)date.yearBetween MINYEAR and MAXYEAR inclusive. date.monthBetween 1 and 12 inclusive. date.dayBetween 1 and the number of days in the given month of the given year. Class methodsdate.today()Return the current local date. This is equivalent to date.fromtimestamp(time.time()). 123&gt;&gt;&gt; from datetime import date&gt;&gt;&gt; date.today() datetime.date(2019, 8, 3) date.fromtimestamp(timestamp)Return the local date corresponding to the POSIX timestamp, such as is returned by time.time(). 12345&gt;&gt;&gt; import time&gt;&gt;&gt; from datetime import date &gt;&gt;&gt; date.fromtimestamp(time.time()) datetime.date(2019, 8, 3) date.fromordinal(ordinal)Return the date corresponding to the proleptic Gregorian ordinal, where January 1 of year 1 has ordinal 1. ValueError is raised unless 1 &lt;= ordinal &lt;= date.max.toordinal(). For any date d, date.fromordinal(d.toordinal()) == d. 12345678910&gt;&gt;&gt; from datetime import date&gt;&gt;&gt; date.fromordinal(1) datetime.date(1, 1, 1)&gt;&gt;&gt; date.fromordinal(31)datetime.date(1, 1, 31)&gt;&gt;&gt; date.fromordinal(35)datetime.date(1, 2, 4) date.fromisoformat(date_string)Return a date corresponding to a date_string in the format emitted by date.isoformat(). Specifically, this function supports strings in the format(s) YYYY-MM-DD. Caution This does not support parsing arbitrary ISO 8601 strings - it is only intended as the inverse operation of date.isoformat(). 12345&gt;&gt;&gt; from datetime import date&gt;&gt;&gt; d = &quot;2018-10-10&quot;&gt;&gt;&gt; date.fromisoformat(d) datetime.date(2018, 10, 10) Instance methodsdate.replace(year=self.year, month=self.month, day=self.day)Return a date with the same value, except for those parameters given new values by whichever keyword arguments are specified. For example 12345678&gt;&gt;&gt; from datetime import date &gt;&gt;&gt; d = date(2018, 10, 10) &gt;&gt;&gt; d.replace(month=12)datetime.date(2018, 12, 10)&gt;&gt;&gt; d.replace(month=12) == date(2018, 12, 10) True date.timetuple()Return a time.struct_time such as returned by time.localtime(). The hours, minutes and seconds are 0, and the DST flag is -1. d.timetuple() is equivalent to time.struct_time((d.year, d.month, d.day, 0, 0, 0, d.weekday(), yday, -1)), where yday = d.toordinal() - date(d.year, 1, 1).toordinal() + 1 is the day number within the current year starting with 1 for January 1st. 12345&gt;&gt;&gt; from datetime import date &gt;&gt;&gt; d = date(2018, 10, 10)&gt;&gt;&gt; d.timetuple() time.struct_time(tm_year=2018, tm_mon=10, tm_mday=10, tm_hour=0, tm_min=0, tm_sec=0, tm_wday=2, tm_yday=283, tm_isdst=-1) date.toordinal()Return the proleptic Gregorian ordinal of the date, where January 1 of year 1 has ordinal 1. For any date object d, date.fromordinal(d.toordinal()) == d. 12345678&gt;&gt;&gt; from datetime import date &gt;&gt;&gt; d = date(2018, 10, 10)&gt;&gt;&gt; d.toordinal() 736977&gt;&gt;&gt; date.fromordinal(d.toordinal()) == dTrue date.weekday()Return the day of the week as an integer, where Monday is 0 and Sunday is 6. For example,date(2018, 10, 10).weekday() == 2, a Wednesday. 12345&gt;&gt;&gt; from datetime import date &gt;&gt;&gt; d = date(2018, 10, 10)&gt;&gt;&gt; d.weekday() 2 # is Wednesday date.isoweekday()Return the day of the week as an integer, where Monday is 1 and Sunday is 7. For example,date(2018, 10, 10).isoweekday() == 3, a Wednesday 12345&gt;&gt;&gt; from datetime import date&gt;&gt;&gt; d = date(2018, 10, 10)&gt;&gt;&gt; d.isoweekday()3 # is Wednesday date.isocalendar()Return a 3-tuple, (ISO year, ISO week number, ISO weekday). The ISO year consists of 52 or 53 full weeks, and where a week starts on a Monday and ends on a Sunday. The first week of an ISO year is the first (Gregorian) calendar week of a year containing a Thursday. This is called week number 1, and the ISO year of that Thursday is the same as its Gregorian year. For example, 2004 begins on a Thursday, so the first week of ISO year 2004 begins on Monday, 29 Dec 2003 and ends on Sunday, 4 Jan 2004, so that date(2003, 12, 29).isocalendar() == (2004, 1, 1) and date(2004, 1, 4).isocalendar() == (2004, 1, 7). 12345&gt;&gt;&gt; from datetime import date&gt;&gt;&gt; d = date(2004, 1, 1)&gt;&gt;&gt; d.isocalendar()(2004, 1, 4) date.isoformat()Return a string representing the date in ISO 8601 format, ‘YYYY-MM-DD’. For example 12345&gt;&gt;&gt; from datetime import date&gt;&gt;&gt; d = date(2018, 10, 10)&gt;&gt;&gt; d.isoformat() &apos;2018-10-10&apos; date.__str__()For a date d, str(d) is equivalent to d.isoformat(). 12345&gt;&gt;&gt; from datetime import date&gt;&gt;&gt; d = date(2018, 10, 10)&gt;&gt;&gt; str(d)&apos;2018-10-10&apos; date.ctime()Return a string representing the date, is equivalent to time.ctime(time.mktime(d.timetuple())) on platforms where the native C ctime() function (which time.ctime() invokes, but which date.ctime() does not invoke) conforms to the C standard. 12345&gt;&gt;&gt; from datetime import date&gt;&gt;&gt; d = date(2018, 10, 10)&gt;&gt;&gt; d.ctime() &apos;Wed Oct 10 00:00:00 2018&apos; date.strftime(format)Return a string representing the date, controlled by an explicit format string. Format codes referring to hours, minutes or seconds will see 0 values 1234567&gt;&gt;&gt; from datetime import date&gt;&gt;&gt; d = date(2018, 10, 10)&gt;&gt;&gt; d.strftime(&apos;%Y-%m-%d&apos;) &apos;2018-10-10&apos;&gt;&gt;&gt; d.strftime(&apos;%Y-%m-%d %H:%M:%S&apos;)&apos;2018-10-10 00:00:00&apos; date.__format__(format)Same as date.strftime(). This makes it possible to specify a format string for a date object in formatted string literals and when using str.format(). Supported operations1234567891011121314151617181920&gt;&gt;&gt; from datetime import date&gt;&gt;&gt; from datetime import timedelta&gt;&gt;&gt; d1 = date(2018, 10, 10) &gt;&gt;&gt; d2 = date(2019, 11, 11)&gt;&gt;&gt; day = timedelta(days=15)&gt;&gt;&gt; d2 - d1datetime.timedelta(days=397)&gt;&gt;&gt; d1 - d2 datetime.timedelta(days=-397)&gt;&gt;&gt; d1 &lt; d2True&gt;&gt;&gt; d1 + day datetime.date(2018, 10, 25)&gt;&gt;&gt; d2 - day datetime.date(2019, 10, 27) time ObjectsA time object represents a (local) time of day, independent of any particular day, and subject to adjustment via a tzinfo object. 1class datetime.time(hour=0, minute=0, second=0, microsecond=0, tzinfo=None, *, fold=0) All arguments are optional. tzinfo may be None, or an instance of a tzinfo subclass. The remaining arguments may be integers, in the following ranges: 0 &lt;= hour &lt; 24, 0 &lt;= minute &lt; 60, 0 &lt;= second &lt; 60, 0 &lt;= microsecond &lt; 1000000, fold in [0, 1]. If an argument outside those ranges is given,ValueError is raised. All default to 0 except tzinfo, which defaults to None. 1234&gt;&gt;&gt; from datetime import time&gt;&gt;&gt; dir(time)[&apos;__class__&apos;, &apos;__delattr__&apos;, &apos;__dir__&apos;, &apos;__doc__&apos;, &apos;__eq__&apos;, &apos;__format__&apos;, &apos;__ge__&apos;, &apos;__getattribute__&apos;, &apos;__gt__&apos;, &apos;__hash__&apos;, &apos;__init__&apos;, &apos;__init_subclass__&apos;, &apos;__le__&apos;, &apos;__lt__&apos;, &apos;__ne__&apos;, &apos;__new__&apos;, &apos;__reduce__&apos;, &apos;__reduce_ex__&apos;, &apos;__repr__&apos;, &apos;__setattr__&apos;, &apos;__sizeof__&apos;, &apos;__str__&apos;, &apos;__subclasshook__&apos;, &apos;dst&apos;, &apos;fold&apos;, &apos;fromisoformat&apos;, &apos;hour&apos;, &apos;isoformat&apos;, &apos;max&apos;, &apos;microsecond&apos;, &apos;min&apos;, &apos;minute&apos;, &apos;replace&apos;, &apos;resolution&apos;, &apos;second&apos;, &apos;strftime&apos;, &apos;tzinfo&apos;, &apos;tzname&apos;, &apos;utcoffset&apos;] Class attributestime.minThe earliest representable time, time(0, 0, 0, 0). 1234&gt;&gt;&gt; from datetime import time&gt;&gt;&gt; time.min datetime.time(0, 0) time.maxThe latest representable time, time(23, 59, 59, 999999). 1234&gt;&gt;&gt; from datetime import time&gt;&gt;&gt; time.max datetime.time(23, 59, 59, 999999) time.resolutionThe smallest possible difference between non-equal time objects, timedelta(microseconds=1), although note that arithmetic on time objects is not supported. 1234&gt;&gt;&gt; from datetime import time&gt;&gt;&gt; time.resolution datetime.timedelta(microseconds=1) Instance attributestime.hourIn range(24). time.minuteIn range(60). time.secondIn range(60). time.microsecondIn range(1000000). time.tzinfoThe object passed as the tzinfo argument to the time constructor, or None if none was passed. time.foleIn [0, 1]. Used to disambiguate wall times during a repeated interval. (A repeated interval occurs when clocks are rolled back at the end of daylight saving time or when the UTC offset for the current zone is decreased for political reasons.) The value 0 (1) represents the earlier (later) of the two moments with the same wall time representation. 12345&gt;&gt;&gt; from datetime import time&gt;&gt;&gt; t = time(10, 23, 56)&gt;&gt;&gt; t.hour, t.minute, t.second, t.microsecond, t.tzinfo, t.fold (10, 23, 56, 0, None, 0) Class methodstime.fromisoformat(time_sting)Return a time corresponding to a time_string in one of the formats emitted by time.isoformat(). Specifically, this function supports strings in the format(s) HH[:MM[:SS[.fff[fff]]]][+HH:MM[:SS[.ffffff]]]. Instance methodstime.replace(hour=self.hour, minute=self.minute, second=self.second, microsecond=self.microsecond, tzinfo=self.tzinfo, * fold=0)Return a time with the same value, except for those attributes given new values by whichever keyword arguments are specified. Note that tzinfo=None can be specified to create a naive time from an aware time, without conversion of the time data. New in version 3.6: Added the fold argument. time.isoformat(timespec=’auto’)Return a string representing the time in ISO 8601 format, HH:MM:SS.ffffff or, if microsecond is 0, HH:MM:SS If utcoffset() does not return None, a string is appended, giving the UTC offset: HH:MM:SS.ffffff+HH:MM[:SS[.ffffff]] or, if self.microsecond is 0, HH:MM:SS+HH:MM[:SS[.ffffff]]. The optional argument timespec specifies the number of additional components of the time to include (the default is ‘auto’). It can be one of the following: ‘auto’: Same as ‘seconds’ if microsecond is 0, same as ‘microseconds’ otherwise. ‘hours’: Include the hour in the two-digit HH format. ‘minutes’: Include hour and minute in HH:MM format. ‘seconds’: Include hour, minute, and second in HH:MM:SS format. ‘milliseconds’: Include full time, but truncate fractional second part to milliseconds. HH:MM:SS.sss format. ‘microseconds’: Include full time in HH:MM:SS.ffffff format. ValueError will be raised on an invalid timespec argument. 12345678910111213&gt;&gt;&gt; from datetime import time &gt;&gt;&gt; t = time(hour=12, minute=34, second=56, microsecond=123456) &gt;&gt;&gt; t.isoformat() &apos;12:34:56.123456&apos;&gt;&gt;&gt; t.isoformat(timespec=&apos;minutes&apos;) &apos;12:34&apos;&gt;&gt;&gt; t = time(hour=12, minute=34, second=56, microsecond=0) &gt;&gt;&gt; t.isoformat(timespec=&apos;microseconds&apos;) &apos;12:34:56.000000&apos;&gt;&gt;&gt; t.isoformat(timespec=&apos;auto&apos;) &apos;12:34:56&apos; time.str()For a time t, str(t) is equivalent to t.isoformat(). time.strftime(format)Return a string representing the time, controlled by an explicit format string. 12345&gt;&gt;&gt; from datetime import time&gt;&gt;&gt; t = time(hour=12, minute=34, second=56, microsecond=0)&gt;&gt;&gt; t.strftime(&apos;%H:%M:%S&apos;) &apos;12:34:56&apos; time.__format__(format)Same as time.strftime(). This makes it possible to specify a format string for a time object in formatted string literals and when using str.format(). time.utcoffset()If tzinfo is None, returns None, else returns self.tzinfo.utcoffset(None), and raises an exception if the latter doesn’t return None or a timedelta object with magnitude less than one day. Changed in version 3.7: The UTC offset is not restricted to a whole number of minutes. time.dst()If tzinfo is None, returns None, else returns self.tzinfo.dst(None), and raises an exception if the latter doesn’t return None, or a timedelta object with magnitude less than one day. Changed in version 3.7: The DST offset is not restricted to a whole number of minutes. time.tzname()If tzinfo is None, returns None, else returns self.tzinfo.tzname(None), or raises an exception if the latter doesn’t return None or a string object. 123456789101112131415161718192021222324&gt;&gt;&gt; from datetime import time, tzinfo, timedelta&gt;&gt;&gt; class TZ1(tzinfo):... def utcoffset(self, dt):... return timedelta(hours=1)... def dst(self, dt):... return timedelta(0)... def tzname(self,dt):... return &quot;+01:00&quot;... def __repr__(self):... return f&quot;&#123;self.__class__.__name__&#125;()&quot;...&gt;&gt;&gt; t = time(12, 10, 30, tzinfo=TZ1())&gt;&gt;&gt; tdatetime.time(12, 10, 30, tzinfo=TZ1())&gt;&gt;&gt; t.isoformat()&apos;12:10:30+01:00&apos;&gt;&gt;&gt; t.dst()datetime.timedelta(0)&gt;&gt;&gt; t.tzname()&apos;+01:00&apos;&gt;&gt;&gt; t.strftime(&quot;%H:%M:%S %Z&quot;)&apos;12:10:30 +01:00&apos;&gt;&gt;&gt; &apos;The &#123;&#125; is &#123;:%H:%M&#125;.&apos;.format(&quot;time&quot;, t)&apos;The time is 12:10.&apos; datetime ObjectsA datetime object is a single object containing all the information from a date object and a time object. Like a date object, datetime assumes the current Gregorian calendar extended in both directions; like a time object, datetime assumes there are exactly 3600*24 seconds in every day. 1class datetime.datetime(year, month, day, hour=0, minute=0, second=0, microsecond=0, tzinfo=None, *, fold=0) The year, month and day arguments are required. tzinfo may be None, or an instance of a tzinfo subclass. The remaining arguments may be integers, in the following ranges: MINYEAR &lt;= year &lt;= MAXYEAR, 1 &lt;= month &lt;= 12, 1 &lt;= day &lt;= number of days in the given month and year, 0 &lt;= hour &lt; 24, 0 &lt;= minute &lt; 60, 0 &lt;= second &lt; 60, 0 &lt;= microsecond &lt; 1000000, fold in [0, 1]. If an argument outside those ranges is given, ValueError is raised. New in version 3.6: Added the fold argument. 1234&gt;&gt;&gt; from datetime import datetime &gt;&gt;&gt; dir(datetime) [&apos;__add__&apos;, &apos;__class__&apos;, &apos;__delattr__&apos;, &apos;__dir__&apos;, &apos;__doc__&apos;, &apos;__eq__&apos;, &apos;__format__&apos;, &apos;__ge__&apos;, &apos;__getattribute__&apos;, &apos;__gt__&apos;, &apos;__hash__&apos;, &apos;__init__&apos;, &apos;__init_subclass__&apos;, &apos;__le__&apos;, &apos;__lt__&apos;, &apos;__ne__&apos;, &apos;__new__&apos;, &apos;__radd__&apos;, &apos;__reduce__&apos;, &apos;__reduce_ex__&apos;, &apos;__repr__&apos;, &apos;__rsub__&apos;, &apos;__setattr__&apos;, &apos;__sizeof__&apos;, &apos;__str__&apos;, &apos;__sub__&apos;, &apos;__subclasshook__&apos;, &apos;astimezone&apos;, &apos;combine&apos;, &apos;ctime&apos;, &apos;date&apos;, &apos;day&apos;, &apos;dst&apos;, &apos;fold&apos;, &apos;fromisoformat&apos;, &apos;fromordinal&apos;, &apos;fromtimestamp&apos;, &apos;hour&apos;, &apos;isocalendar&apos;, &apos;isoformat&apos;, &apos;isoweekday&apos;, &apos;max&apos;, &apos;microsecond&apos;, &apos;min&apos;, &apos;minute&apos;, &apos;month&apos;, &apos;now&apos;, &apos;replace&apos;, &apos;resolution&apos;, &apos;second&apos;, &apos;strftime&apos;, &apos;strptime&apos;, &apos;time&apos;, &apos;timestamp&apos;, &apos;timetuple&apos;, &apos;timetz&apos;, &apos;today&apos;, &apos;toordinal&apos;, &apos;tzinfo&apos;, &apos;tzname&apos;, &apos;utcfromtimestamp&apos;, &apos;utcnow&apos;, &apos;utcoffset&apos;, &apos;utctimetuple&apos;, &apos;weekday&apos;, &apos;year&apos;] Class attributesdatetime.minThe earliest representable datetime, datetime(MINYEAR, 1, 1, tzinfo=None). datetime.maxThe latest representable datetime, datetime(MAXYEAR, 12, 31, 23, 59, 59, 999999, tzinfo=None). datetime.resolutionThe smallest possible difference between non-equal datetime objects, timedelta(microseconds=1). Instance attributes (read-only)datetime.yearBetween MINYEAR and MAXYEAR inclusive. datetime.monthBetween 1 and 12 inclusive. datetime.dayBetween 1 and the number of days in the given month of the given year. datetime.hourIn range(24). datetime.minuteIn range(60). datetime.secondIn range(60). datetime.microsecondIn range(1000000). datetime.tzinfoThe object passed as the tzinfo argument to the datetime constructor, or None if none was passed. datetime.foldIn [0, 1]. Used to disambiguate wall times during a repeated interval. (A repeated interval occurs when clocks are rolled back at the end of daylight saving time or when the UTC offset for the current zone is decreased for political reasons.) The value 0 (1) represents the earlier (later) of the two moments with the same wall time representation. Class methodsdatetime.today()Return the current local datetime, with tzinfo None. This is equivalent to datetime.fromtimestamp(time.time()). 123&gt;&gt;&gt; from datetime import datetime&gt;&gt;&gt; datetime.today()datetime.datetime(2019, 8, 3, 23, 38, 14, 444364) datetime.now(tz=None)Return the current local date and time. If optional argument tz is None or not specified, this is like today(), but, if possible, supplies more precision than can be gotten from going through a time.time() timestamp (for example, this may be possible on platforms supplying the C gettimeofday() function). If tz is not None, it must be an instance of a tzinfo subclass, and the current date and time are converted to tz’s time zone. In this case the result is equivalent to tz.fromutc(datetime.utcnow().replace(tzinfo=tz)). datetime.utcnow()Return the current UTC date and time, with tzinfo None. This is like now(), but returns the current UTC date and time, as a naive datetime object. An aware current UTC datetime can be obtained by calling datetime.now(timezone.utc). See also now(). datetime.fromtimestamp(timestamp, tz=None)Return the local date and time corresponding to the POSIX timestamp, such as is returned by time.time(). If optional argument tz is None or not specified, the timestamp is converted to the platform’s local date and time, and the returned datetime object is naive. If tz is not None, it must be an instance of a tzinfo subclass, and the timestamp is converted to tz’s time zone. In this case the result is equivalent to tz.fromutc(datetime.utcfromtimestamp(timestamp).replace(tzinfo=tz)). datetime.utcfromtimestamp(timestamp)Return the UTC datetime corresponding to the POSIX timestamp, with tzinfo None. This may raise OverflowError, if the timestamp is out of the range of values supported by the platform C gmtime() function, and OSError on gmtime() failure. It’s common for this to be restricted to years in 1970 through 2038. datetime.fromordinal(ordinal)Return the datetime corresponding to the proleptic Gregorian ordinal, where January 1 of year 1 has ordinal 1. ValueError is raised unless 1 &lt;= ordinal &lt;= datetime.max.toordinal(). The hour, minute, second and microsecond of the result are all 0, and tzinfo is None. datetime.combine(date, time, tzinfo=self.tzinfo)Return a new datetime object whose date components are equal to the given date object’s, and whose time components are equal to the given time object’s. If the tzinfo argument is provided, its value is used to set the tzinfo attribute of the result, otherwise the tzinfo attribute of the time argument is used. For any datetime object d, d == datetime.combine(d.date(), d.time(), d.tzinfo). If date is a datetime object, its time components and tzinfo attributes are ignored. Changed in version 3.6: Added the tzinfo argument. datetime.fromisoformat(date_string)Return a datetime corresponding to a date_string in one of the formats emitted by date.isoformat() and datetime.isoformat(). Specifically, this function supports strings in the format(s) YYYY-MM-DD[*HH[:MM[:SS[.fff[fff]]]][+HH:MM[:SS[.ffffff]]]], where * can match any single character. datetime.strptime(date_string, format)Return a datetime corresponding to date_string, parsed according to format. This is equivalent to datetime(*(time.strptime(date_string, format)[0:6])). ValueError is raised if the date_string and format can’t be parsed by time.strptime() or if it returns a value which isn’t a time tuple. For a complete list of formatting directives, see strftime() and strptime() Behavior. Instance methodsdatetime.date()Return date object with same year, month and day. datetime.time()Return time object with same hour, minute, second, microsecond and fold. tzinfo is None. See also method timetz(). Changed in version 3.6: The fold value is copied to the returned time object. datetime.timetz()Return time object with same hour, minute, second, microsecond, fold, and tzinfo attributes. See also method time(). Changed in version 3.6: The fold value is copied to the returned time object. datetime.replace(year=self.year, month=self.month, day=self.day, hour=self.hour, minute=self.minute, second=self.second, microsecond=self.microsecond, tzinfo=self.tzinfo, * fold=0)Return a datetime with the same attributes, except for those attributes given new values by whichever keyword arguments are specified. Note that tzinfo=None can be specified to create a naive datetime from an aware datetime with no conversion of date and time data. New in version 3.6: Added the fold argument. datetime.astimezone(tz=None)Return a datetime object with new tzinfo attribute tz, adjusting the date and time data so the result is the same UTC time as self, but in tz’s local time. If provided, tz must be an instance of a tzinfo subclass, and its utcoffset() and dst() methods must not return None. If self is naive, it is presumed to represent time in the system timezone. datetime.utcoffset()If tzinfo is None, returns None, else returns self.tzinfo.utcoffset(self), and raises an exception if the latter doesn’t return None or a timedelta object with magnitude less than one day. Changed in version 3.7: The UTC offset is not restricted to a whole number of minutes. datetime.dst()If tzinfo is None, returns None, else returns self.tzinfo.dst(self), and raises an exception if the latter doesn’t return None or a timedelta object with magnitude less than one day. Changed in version 3.7: The DST offset is not restricted to a whole number of minutes. datetime.tzname()If tzinfo is None, returns None, else returns self.tzinfo.tzname(self), raises an exception if the latter doesn’t return None or a string object, datetime.timetuple()Return a time.struct_time such as returned by time.localtime(). d.timetuple() is equivalent to time.struct_time((d.year, d.month, d.day, d.hour, d.minute, d.second, d.weekday(), yday, dst)), where yday = d.toordinal() - date(d.year, 1, 1).toordinal() + 1 is the day number within the current year starting with 1 for January 1st. The tm_isdst flag of the result is set according to the dst() method: tzinfo is None or dst() returns None, tm_isdst is set to -1; else if dst() returns a non-zero value, tm_isdst is set to 1; else tm_isdst is set to 0. datetime.utctimetuple()If datetime instance d is naive, this is the same as d.timetuple() except that tm_isdst is forced to 0 regardless of what d.dst() returns. DST is never in effect for a UTC time. If d is aware, d is normalized to UTC time, by subtracting d.utcoffset(), and a time.struct_time for the normalized time is returned. tm_isdst is forced to 0. Note that an OverflowError may be raised if d.year was MINYEAR or MAXYEAR and UTC adjustment spills over a year boundary. datetime.toordinal()Return the proleptic Gregorian ordinal of the date. The same as self.date().toordinal(). datetime.timestamp()Return POSIX timestamp corresponding to the datetime instance. The return value is a float similar to that returned by time.time(). Naive datetime instances are assumed to represent local time and this method relies on the platform C mktime() function to perform the conversion. Since datetime supports wider range of values than mktime() on many platforms, this method may raise OverflowError for times far in the past or far in the future. datetime.weekday()Return the day of the week as an integer, where Monday is 0 and Sunday is 6. The same as self.date().weekday(). See also isoweekday(). datetime.isoweekday()Return the day of the week as an integer, where Monday is 1 and Sunday is 7. The same as self.date().isoweekday(). See also weekday(), isocalendar(). datetime.isocalendar()Return a 3-tuple, (ISO year, ISO week number, ISO weekday). The same as self.date().isocalendar(). datetime.isoformat(sep=’T’, timespec=’auto’)Return a string representing the date and time in ISO 8601 format, YYYY-MM-DDTHH:MM:SS.ffffff or, if microsecond is 0, YYYY-MM-DDTHH:MM:SS If utcoffset() does not return None, a string is appended, giving the UTC offset: YYYY-MM-DDTHH:MM:SS.ffffff+HH:MM[:SS[.ffffff]] or, if microsecond is 0 YYYY-MM-DDTHH:MM:SS+HH:MM[:SS[.ffffff]]. The optional argument sep (default ‘T’) is a one-character separator, placed between the date and time portions of the result. For example, 123456&gt;&gt;&gt; from datetime import tzinfo, timedelta, datetime&gt;&gt;&gt; class TZ(tzinfo):... def utcoffset(self, dt): return timedelta(minutes=-399)...&gt;&gt;&gt; datetime(2002, 12, 25, tzinfo=TZ()).isoformat(&apos; &apos;)&apos;2002-12-25 00:00:00-06:39&apos; The optional argument timespec specifies the number of additional components of the time to include (the default is ‘auto’). It can be one of the following: ‘auto’: Same as ‘seconds’ if microsecond is 0, same as ‘microseconds’ otherwise. ‘hours’: Include the hour in the two-digit HH format. ‘minutes’: Include hour and minute in HH:MM format. ‘seconds’: Include hour, minute, and second in HH:MM:SS format. ‘milliseconds’: Include full time, but truncate fractional second part to milliseconds. HH:MM:SS.sss format. ‘microseconds’: Include full time in HH:MM:SS.ffffff format. ValueError will be raised on an invalid timespec argument. 123456&gt;&gt;&gt; from datetime import datetime&gt;&gt;&gt; datetime.now().isoformat(timespec=&apos;minutes&apos;) # doctest: +SKIP&apos;2002-12-25T00:00&apos;&gt;&gt;&gt; dt = datetime(2015, 1, 1, 12, 30, 59, 0)&gt;&gt;&gt; dt.isoformat(timespec=&apos;microseconds&apos;)&apos;2015-01-01T12:30:59.000000&apos; datetime.str()For a datetime instance d, str(d) is equivalent to d.isoformat(‘ ‘). datetime.ctime()Return a string representing the date and time, for example datetime(2002, 12, 4, 20, 30, 40).ctime() == ‘Wed Dec 4 20:30:40 2002’. d.ctime() is equivalent to time.ctime(time.mktime(d.timetuple())) on platforms where the native C ctime() function (which time.ctime() invokes, but which datetime.ctime() does not invoke) conforms to the C standard. datetime.strftime(format)Return a string representing the date and time, controlled by an explicit format string. For a complete list of formatting directives, see strftime() and strptime() Behavior. datetime.format(format)Same as datetime.strftime(). This makes it possible to specify a format string for a datetime object in formatted string literals and when using str.format(). For a complete list of formatting directives, see strftime() and strptime() Behavior. Examples of working with datetime objects: 123456789101112131415161718192021222324252627282930313233343536373839404142&gt;&gt;&gt; from datetime import datetime, date, time&gt;&gt;&gt; # Using datetime.combine()&gt;&gt;&gt; d = date(2005, 7, 14)&gt;&gt;&gt; t = time(12, 30)&gt;&gt;&gt; datetime.combine(d, t)datetime.datetime(2005, 7, 14, 12, 30)&gt;&gt;&gt; # Using datetime.now() or datetime.utcnow()&gt;&gt;&gt; datetime.now() datetime.datetime(2007, 12, 6, 16, 29, 43, 79043) # GMT +1&gt;&gt;&gt; datetime.utcnow() datetime.datetime(2007, 12, 6, 15, 29, 43, 79060)&gt;&gt;&gt; # Using datetime.strptime()&gt;&gt;&gt; dt = datetime.strptime(&quot;21/11/06 16:30&quot;, &quot;%d/%m/%y %H:%M&quot;)&gt;&gt;&gt; dtdatetime.datetime(2006, 11, 21, 16, 30)&gt;&gt;&gt; # Using datetime.timetuple() to get tuple of all attributes&gt;&gt;&gt; tt = dt.timetuple()&gt;&gt;&gt; for it in tt: ... print(it)...2006 # year11 # month21 # day16 # hour30 # minute0 # second1 # weekday (0 = Monday)325 # number of days since 1st January-1 # dst - method tzinfo.dst() returned None&gt;&gt;&gt; # Date in ISO format&gt;&gt;&gt; ic = dt.isocalendar()&gt;&gt;&gt; for it in ic: ... print(it)...2006 # ISO year47 # ISO week2 # ISO weekday&gt;&gt;&gt; # Formatting datetime&gt;&gt;&gt; dt.strftime(&quot;%A, %d. %B %Y %I:%M%p&quot;)&apos;Tuesday, 21. November 2006 04:30PM&apos;&gt;&gt;&gt; &apos;The &#123;1&#125; is &#123;0:%d&#125;, the &#123;2&#125; is &#123;0:%B&#125;, the &#123;3&#125; is &#123;0:%I:%M%p&#125;.&apos;.format(dt, &quot;day&quot;, &quot;month&quot;, &quot;time&quot;)&apos;The day is 21, the month is November, the time is 04:30PM.&apos; Using datetime with tzinfo: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&gt;&gt;&gt; from datetime import timedelta, datetime, tzinfo, timezone&gt;&gt;&gt; class KabulTz(tzinfo):... # Kabul used +4 until 1945, when they moved to +4:30... UTC_MOVE_DATE = datetime(1944, 12, 31, 20, tzinfo=timezone.utc)... def utcoffset(self, dt):... if dt.year &lt; 1945:... return timedelta(hours=4)... elif (1945, 1, 1, 0, 0) &lt;= dt.timetuple()[:5] &lt; (1945, 1, 1, 0, 30):... # If dt falls in the imaginary range, use fold to decide how... # to resolve. See PEP495... return timedelta(hours=4, minutes=(30 if dt.fold else 0))... else:... return timedelta(hours=4, minutes=30)...... def fromutc(self, dt):... # A custom implementation is required for fromutc as... # the input to this function is a datetime with utc values... # but with a tzinfo set to self... # See datetime.astimezone or fromtimestamp...... # Follow same validations as in datetime.tzinfo... if not isinstance(dt, datetime):... raise TypeError(&quot;fromutc() requires a datetime argument&quot;)... if dt.tzinfo is not self:... raise ValueError(&quot;dt.tzinfo is not self&quot;)...... if dt.replace(tzinfo=timezone.utc) &gt;= self.UTC_MOVE_DATE:... return dt + timedelta(hours=4, minutes=30)... else:... return dt + timedelta(hours=4)...... def dst(self, dt):... return timedelta(0)...... def tzname(self, dt):... if dt &gt;= self.UTC_MOVE_DATE:... return &quot;+04:30&quot;... else:... return &quot;+04&quot;...... def __repr__(self):... return f&quot;&#123;self.__class__.__name__&#125;()&quot;...&gt;&gt;&gt; tz1 = KabulTz()&gt;&gt;&gt; # Datetime before the change&gt;&gt;&gt; dt1 = datetime(1900, 11, 21, 16, 30, tzinfo=tz1)&gt;&gt;&gt; print(dt1.utcoffset())4:00:00&gt;&gt;&gt; # Datetime after the change&gt;&gt;&gt; dt2 = datetime(2006, 6, 14, 13, 0, tzinfo=tz1)&gt;&gt;&gt; print(dt2.utcoffset())4:30:00&gt;&gt;&gt; # Convert datetime to another time zone&gt;&gt;&gt; dt3 = dt2.astimezone(timezone.utc)&gt;&gt;&gt; dt3datetime.datetime(2006, 6, 14, 8, 30, tzinfo=datetime.timezone.utc)&gt;&gt;&gt; dt2datetime.datetime(2006, 6, 14, 13, 0, tzinfo=KabulTz())&gt;&gt;&gt; dt2.utctimetuple() == dt3.utctimetuple()True tzinfo Objects1class datetime.tzinfo 12345&gt;&gt;&gt; from datetime import tzinfo &gt;&gt;&gt; dir(tzinfo) [&apos;__class__&apos;, &apos;__delattr__&apos;, &apos;__dir__&apos;, &apos;__doc__&apos;, &apos;__eq__&apos;, &apos;__format__&apos;, &apos;__ge__&apos;, &apos;__getattribute__&apos;, &apos;__gt__&apos;, &apos;__hash__&apos;, &apos;__init__&apos;, &apos;__init_subclass__&apos;, &apos;__le__&apos;, &apos;__lt__&apos;, &apos;__ne__&apos;, &apos;__new__&apos;, &apos;__reduce__&apos;, &apos;__reduce_ex__&apos;, &apos;__repr__&apos;, &apos;__setattr__&apos;, &apos;__sizeof__&apos;, &apos;__str__&apos;, &apos;__subclasshook__&apos;, &apos;dst&apos;, &apos;fromutc&apos;, &apos;tzname&apos;, &apos;utcoffset&apos;] 123456789101112131415161718192021222324252627282930Help on class tzinfo in module datetime:class tzinfo(builtins.object) | Abstract base class for time zone info objects. | | Methods defined here: | | __getattribute__(self, name, /) | Return getattr(self, name). | | __reduce__(...) | -&gt; (cls, state) | | dst(...) | datetime -&gt; DST offset as timedelta positive east of UTC. | | fromutc(...) | datetime in UTC -&gt; datetime in local time. | | tzname(...) | datetime -&gt; string name of time zone. | | utcoffset(...) | datetime -&gt; timedelta showing offset from UTC, negative values indicating West of UTC | | ---------------------------------------------------------------------- | Static methods defined here: | | __new__(*args, **kwargs) from builtins.type | Create and return a new object. See help(type) for accurate signature. timezone ObjectsThe timezone class is a subclass of tzinfo, each instance of which represents a timezone defined by a fixed offset from UTC. Note that objects of this class cannot be used to represent timezone information in the locations where different offsets are used in different days of the year or where historical changes have been made to civil time. 1class datetime.timezone(offset, name=None) The offset argument must be specified as a timedelta object representing the difference between the local time and UTC. It must be strictly between -timedelta(hours=24) and timedelta(hours=24), otherwise ValueError is raised. The name argument is optional. If specified it must be a string that will be used as the value returned by the datetime.tzname() method. 1234&gt;&gt;&gt; from datetime import timezone &gt;&gt;&gt; dir(timezone) [&apos;__class__&apos;, &apos;__delattr__&apos;, &apos;__dir__&apos;, &apos;__doc__&apos;, &apos;__eq__&apos;, &apos;__format__&apos;, &apos;__ge__&apos;, &apos;__getattribute__&apos;, &apos;__getinitargs__&apos;, &apos;__gt__&apos;, &apos;__hash__&apos;, &apos;__init__&apos;, &apos;__init_subclass__&apos;, &apos;__le__&apos;, &apos;__lt__&apos;, &apos;__ne__&apos;, &apos;__new__&apos;, &apos;__reduce__&apos;, &apos;__reduce_ex__&apos;, &apos;__repr__&apos;, &apos;__setattr__&apos;, &apos;__sizeof__&apos;, &apos;__str__&apos;, &apos;__subclasshook__&apos;, &apos;dst&apos;, &apos;fromutc&apos;, &apos;max&apos;, &apos;min&apos;, &apos;tzname&apos;, &apos;utc&apos;, &apos;utcoffset&apos;] 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677Help on class timezone in module datetime:class timezone(tzinfo) | Fixed offset from UTC implementation of tzinfo. | | Method resolution order: | timezone | tzinfo | builtins.object | | Methods defined here: | | __eq__(self, value, /) | Return self==value. | | __ge__(self, value, /) | Return self&gt;=value. | | __getinitargs__(...) | pickle support | | __gt__(self, value, /) | Return self&gt;value. | | __hash__(self, /) | Return hash(self). | | __le__(self, value, /) | Return self&lt;=value. | | __lt__(self, value, /) | Return self&lt;value. | | __ne__(self, value, /) | Return self!=value. | | __repr__(self, /) | Return repr(self). | | __str__(self, /) | Return str(self). | | dst(...) | Return None. | | fromutc(...) | datetime in UTC -&gt; datetime in local time. | | tzname(...) | If name is specified when timezone is created, returns the name. Otherwise returns offset as &apos;UTC(+|-)HH:MM&apos;. | | utcoffset(...) | Return fixed offset. | | ---------------------------------------------------------------------- | Static methods defined here: | | __new__(*args, **kwargs) from builtins.type | Create and return a new object. See help(type) for accurate signature. | | ---------------------------------------------------------------------- | Data and other attributes defined here: | | max = datetime.timezone(datetime.timedelta(seconds=86340)) | | min = datetime.timezone(datetime.timedelta(days=-1, seconds=60)) | | utc = datetime.timezone.utc | | ---------------------------------------------------------------------- | Methods inherited from tzinfo: | | __getattribute__(self, name, /) | Return getattr(self, name). | | __reduce__(...) | -&gt; (cls, state) Appendix1234567891011121314151617181920212223格式 说明%a 显示简化星期名称%A 显示完整星期名称%b 显示简化月份名称%B 显示完整月份名称%c 本地相应的日期和时间表示%d 显示当月第几天%H 按24小时制显示小时%I 按12小时制显示小时%j 显示当年第几天%m 显示月份%M 显示分钟数）%p 本地am或者pm的相应符%S 显示秒数）%U 一年中的星期数%w 显示在星期中的第几天，默认从0开始表示周一%W 和%U基本相同%x 本地相应日期%X 本地相应时间%y 去掉世纪的年份（00 - 99）%Y 完整的年份%Z 时区的名字（如果不存在为空字符）%% ‘%’字符 summary123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251NAME datetime - Fast implementation of the datetime type.CLASSES builtins.object date datetime time timedelta tzinfo timezone class date(builtins.object) date(year, month, day) --&gt; date object td = date(year=2018, month=10, day=10) # td is instance of date Instance Methods defined here: ctime() # Return ctime() style string. isocalendar() # Return a 3-tuple containing ISO year, week number, and weekday. isoformat() # Return string in ISO 8601 format, YYYY-MM-DD. isoweekday() # Return the day of the week represented by the date. Monday == 1 ... Sunday == 7 replace(year=self.year, month=self.month, day=self.day) # Return date with new specified fields. strftime(format) # format -&gt; strftime() style string. timetuple() # Return time tuple, compatible with time.localtime(). toordinal() # Return proleptic Gregorian ordinal. January 1 of year 1 is day 1. weekday() # Return the day of the week represented by the date. Monday == 0 ... Sunday == 6 Class methods defined here: fromisoformat(date_string) from builtins.type str -&gt; Construct a date from the output of date.isoformat() fromordinal(ordinal) from builtins.type int -&gt; date corresponding to a proleptic Gregorian ordinal. fromtimestamp(timestamp) from builtins.type timestamp -&gt; local date from a POSIX timestamp (like time.time()). today() from builtins.type Current date or datetime: same as self.__class__.fromtimestamp(time.time()). Data descriptors defined here: day month year Data and other attributes defined here: max = datetime.date(9999, 12, 31) min = datetime.date(1, 1, 1) resolution = datetime.timedelta(days=1) class datetime(date) datetime(year, month, day[, hour[, minute[, second[, microsecond[,tzinfo]]]]]) The year, month and day arguments are required. tzinfo may be None, or an instance of a tzinfo subclass. The remaining arguments may be ints. Method resolution order: datetime date builtins.object Instance Methods defined here: astimezone(tz=None) # tz -&gt; convert to local time in new timezone tz ctime() # Return ctime() style string. date() # Return date object with same year, month and day. dst() # Return self.tzinfo.dst(self). isoformat(sep=’T’, timespec=’auto’) [sep] -&gt; string in ISO 8601 format, YYYY-MM-DDT[HH[:MM[:SS[.mmm[uuu]]]]][+HH:MM]. sep is used to separate the year from the time, and defaults to &apos;T&apos;. timespec specifies what components of the time to include (allowed values are &apos;auto&apos;, &apos;hours&apos;, &apos;minutes&apos;, &apos;seconds&apos;, &apos;milliseconds&apos;, and &apos;microseconds&apos;). replace(year=self.year, month=self.month, day=self.day, hour=self.hour, minute=self.minute, second=self.second, microsecond=self.microsecond, tzinfo=self.tzinfo, * fold=0) Return datetime with new specified fields. time() # Return time object with same time but with tzinfo=None. timestamp() # Return POSIX timestamp as float. timetuple() # Return time tuple, compatible with time.localtime(). timetz() # Return time object with same time and tzinfo. tzname() # Return self.tzinfo.tzname(self). utcoffset() # Return self.tzinfo.utcoffset(self). utctimetuple() # Return UTC time tuple, compatible with time.localtime(). Class methods defined here: combine(date, time, tzinfo=self.tzinfo) from builtins.type date, time -&gt; datetime with same date and time fields fromisoformat(date_string) from builtins.type string -&gt; datetime from datetime.isoformat() output fromtimestamp(timestamp, tz=None) from builtins.type timestamp[, tz] -&gt; tz&apos;s local time from POSIX timestamp. timestamp is &apos;datetime.datetime&apos; object now(tz=None) from builtins.type Returns new datetime object representing current time local to tz. tz Timezone object. If no tz is specified, uses local timezone. strptime(date_string, format) from builtins.type date_string, format -&gt; new datetime parsed from a string (like time.strptime()). utcfromtimestamp(timestamp) from builtins.type Construct a naive UTC datetime from a POSIX timestamp. utcnow() from builtins.type Return a new datetime representing UTC day and time. Data descriptors defined here: fold hour microsecond minute second tzinfo Data and other attributes defined here: max = datetime.datetime(9999, 12, 31, 23, 59, 59, 999999) min = datetime.datetime(1, 1, 1, 0, 0) resolution = datetime.timedelta(microseconds=1) Methods inherited from date: isocalendar() # Return a 3-tuple containing ISO year, week number, and weekday. isoweekday() Return the day of the week represented by the date. Monday == 1 ... Sunday == 7 strftime(format) format -&gt; strftime() style string. toordinal() Return proleptic Gregorian ordinal. January 1 of year 1 is day 1. weekday() Return the day of the week represented by the date. Monday == 0 ... Sunday == 6 Class methods inherited from date: fromordinal(ordinal) from builtins.type int -&gt; date corresponding to a proleptic Gregorian ordinal. today() from builtins.type Current date or datetime: same as self.__class__.fromtimestamp(time.time()). Data descriptors inherited from date: day month year class time(builtins.object) time([hour[, minute[, second[, microsecond[, tzinfo]]]]]) --&gt; a time object All arguments are optional. tzinfo may be None, or an instance of a tzinfo subclass. The remaining arguments may be ints. Methods defined here: dst() # Return self.tzinfo.dst(self). isoformat(timespec=’auto’) Return string in ISO 8601 format, [HH[:MM[:SS[.mmm[uuu]]]]][+HH:MM]. timespec specifies what components of the time to include. replace(hour=self.hour, minute=self.minute, second=self.second, microsecond=self.microsecond, tzinfo=self.tzinfo, * fold=0) Return time with new specified fields. strftime(format) format -&gt; strftime() style string. tzname() Return self.tzinfo.tzname(self). utcoffset() Return self.tzinfo.utcoffset(self). Class methods defined here: fromisoformat(time_string) from builtins.type string -&gt; time from time.isoformat() output Data descriptors defined here: fold hour microsecond minute second tzinfo Data and other attributes defined here: max = datetime.time(23, 59, 59, 999999) min = datetime.time(0, 0) resolution = datetime.timedelta(microseconds=1) class timedelta(builtins.object) Difference between two datetime values. Methods defined here: total_seconds() Total seconds in the duration. Data descriptors defined here: days # Number of days. microseconds # Number of microseconds (&gt;= 0 and less than 1 second). seconds # Number of seconds (&gt;= 0 and less than 1 day). Data and other attributes defined here: max = datetime.timedelta(days=999999999, seconds=86399, microseconds=9... min = datetime.timedelta(days=-999999999) resolution = datetime.timedelta(microseconds=1) class timezone(tzinfo) Fixed offset from UTC implementation of tzinfo. Method resolution order: timezone tzinfo builtins.object Methods defined here: dst() # Return None. fromutc() # datetime in UTC -&gt; datetime in local time. tzname(...) If name is specified when timezone is created, returns the name. Otherwise returns offset as &apos;UTC(+|-) HH:MM&apos;. utcoffset(...) Return fixed offset. Data and other attributes defined here: max = datetime.timezone(datetime.timedelta(seconds=86340)) min = datetime.timezone(datetime.timedelta(days=-1, seconds=60)) utc = datetime.timezone.utc class tzinfo(builtins.object) Abstract base class for time zone info objects. Methods defined here: dst(...) datetime -&gt; DST offset as timedelta positive east of UTC. fromutc(...) datetime in UTC -&gt; datetime in local time. tzname(...) datetime -&gt; string name of time zone. utcoffset(...) datetime -&gt; timedelta showing offset from UTC, negative values indicating West of UTCDATA MAXYEAR = 9999 MINYEAR = 1 datetime_CAPI = &lt;capsule object &quot;datetime.datetime_CAPI&quot;&gt;]]></content>
      <categories>
        <category>python</category>
        <category>module</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>module</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux 安装ssh以及ssh用法与免密登录]]></title>
    <url>%2FLinux%2Fssh%2Fck0xy26zd001sksv770384p0l.html</url>
    <content type="text"><![CDATA[ssh 简述SSH ( Secure Shell) 由 IETF 的网络工作小组（Network Working Group）所制定； SSH 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。其是建立在应用层和传输层基础上的安全协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。 SSH最初是UNIX系统上的一个程序，后来又迅速扩展到其他操作平台。SSH在正确使用时可弥补网络中的漏洞。 SSH客户端适用于多种平台。几乎所有UNIX平台—包括HP-UX、Linux、AIX、Solaris、Digital UNIX、Irix，以及其他平台，都可运行SSH。 ssh 安装命令： yum install -y openssh-server openssh-clients 启动ssh： service sshd start 或 /etc/init.d/sshd start 配置开机启动： chkconfig –level 2345 sshd on 配置hosts文件编辑 /etc/hosts文件，在文件尾部添加： ​ IP hostname ​ 例： ​ 192.168.10.10 linux ssh免密登录生成密钥命令：ssh-keygen -t rsa 注：上述操作后一路回车，生成之后会在用户的根目录生成一个 “.ssh”的文件夹。 123456789101112131415161718192021[root@hadoop-centos-01 bin]# ssh-keygen -t rsaGenerating public/private rsa key pair.Enter file in which to save the key (/root/.ssh/id_rsa):Enter passphrase (empty for no passphrase):Enter same passphrase again:Your identification has been saved in /root/.ssh/id_rsa.Your public key has been saved in /root/.ssh/id_rsa.pub.The key fingerprint is:SHA256:cvRFrezrrpzUxZiHr7oufeyNJZGRimjVd1QV7TYTF9c root@hadoop-centos-01The key&apos;s randomart image is:+---[RSA 2048]----+| ...+X|| . . o..E|| o ..=...o|| + o +oO oo|| + S o.* +.o|| . o ..= || ...o.o || .o..+* || oBO* . |+----[SHA256]-----+ 12[root@hadoop-centos-01 opt]# cd ; ll -al | grep .sshdrwx------. 2 root root 80 May 12 22:25 .ssh .ssh 目录包含文件： 123456[root@hadoop-centos-01 .ssh]# ll -ltotal 16-rw-------. 1 root root 1613 May 12 22:30 authorized_keys-rw-------. 1 root root 1675 Aug 1 07:37 id_rsa-rw-r--r--. 1 root root 403 Aug 1 07:37 id_rsa.pub-rw-r--r--. 1 root root 919 May 13 06:54 known_hosts authorized_keys: 存放远程免密登录的公钥,主要通过这个文件记录多台机器的公钥 id_rsa : 生成的私钥文件 id_rsa.pub ： 生成的公钥文件 know_hosts : 已知的主机公钥清单 注： ​ 如果希望ssh公钥生效需满足至少下面两个条件： 1) .ssh目录的权限必须是700 2) .ssh/authorized_keys文件权限必须是600 设置免密登录通过ssh-copy-id的方式命令： ssh-copy-id -i ~/.ssh/id_rsa.pub [ip/hosts] 通过scp将内容写到对方的文件中命令：scp -p ~/.ssh/id_rsa.pub root@:/root/.ssh/authorized_keys]]></content>
      <categories>
        <category>Linux</category>
        <category>ssh</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>command</tag>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Typora简单教程]]></title>
    <url>%2FTypora%2Fck0xy26lu0009ksv7aa7n4lez.html</url>
    <content type="text"><![CDATA[序言Typora是一款轻便简洁的Markdown编辑器，支持即时渲染技术，这也是与其他Markdown编辑器最显著的区别。即时渲染使得你写Markdown就想是写Word文档一样流畅自如，不像其他编辑器的有编辑栏和显示栏。 基本操作内容目录 语法 1[toc] 标题 语法 123456# 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 引用 语法 123&gt; 引用内容1&gt; 引用内容2&gt;&gt; 引用内容3 效果 引用内容1 引用内容2 引用内容3 代码单行代码 语法 1`String str1 = &quot;hello&quot;;` 效果 string str1 = &quot;hello world&quot;; 多行代码 语法 1~~~ Language 效果 12int a = 10;int b = 20; 列表无序列表 语法 123* 无序列表1+ 无序列表2- 无序列表3 效果 无序列表1 无序列表2 无序列表3 多行无需列表 语法 123* 多行无序列表1TAB * 多行无序列表2TAB TAB * 多行无序列表3 效果 多行无序列表1 多行无序列表2 多行无序列表3 有序列表 语法 1231. 有序列表12. 有序列表23. 有序列表3 效果 有序列表1 有序列表2 有序列表3 多行有序列表 语法 12345671. 多行有序列表12. 多行有序列表2 1. 多行有序列表2-1 2. 多行有序列表2-23. 多行有序列表3 1. 多行有序列表3-1 2. 多行有序列表3-2 效果 多行有序列表1 多行有序列表2 多行有序列表2-1 多行有序列表2-2 多行有序列表3 多行有序列表3-1 多行有序列表3-2 任务列表 语法 123-[ ] 抽烟-[x] 喝酒-[ ] 烫头 效果 -[ ] 抽烟-[x] 喝酒-[ ] 烫头 表格 语法 12345|姓名|性别|年龄|手机号||:---|:--:|:--:|---:||张三|男|21|18975346876||李四|女|23|17789548964||王五|男|25|15876513546| 效果 姓名 性别 年龄 手机号 张三 男 21 18975346876 李四 女 23 17789548964 王五 男 25 15876513546 链接图片 语法1（本地图片） 1[图片上传失败...(image-61fd19-1520850984854)] 语法2（网络图片） 1![typora.jpg(https://uploadimages.jianshu.io/upload_images/1538862d91e815790b81e4a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) 超链接 语法1（行内式链接） 12[百度][https://www.baidu.com/][百度](https://www.baidu.com/) 效果 [百度][https://www.baidu.com/ ]百度 语法2（参考式链接） 12[CSDN][CSDN网址][CSDN网址]:https://www.csdn.net/ 效果CSDN 语法3（自动链接） 1&lt;https://github.com/&gt; 效果3 https://github.com/ 其他斜体 语法 12*斜体*_斜体_ 效果 斜体 斜体 加粗 语法 12**加粗**__加粗__ 效果 加粗 加粗 下划线 语法 1&lt;u&gt;下划线&lt;/u&gt; 效果 下划线 删除线 语法 1删除线 效果 删除线 分隔线 语法 123***---___ 效果 注脚 语法 12Typora[^1][^1]A markdown editor 效果 Typora[^1] 上下标 语法 1234$3^2=9$$3^&#123;(3-1)&#125;=9$$H_2SO_4$$H_&#123;2SO_4&#125;$ 效果 $3^2=9$ $3^{(3-1)}=9$ $H_2SO_4$ $H_{2SO_4}$ 符号的输入 语法 123456789101112\\ 反斜线\` 反引号\* 星号\_ 底线\&#123; \&#125; 花括号\[ \] 方括号\( \) 括弧\# 井字号\+ 加号\- 减号\. 英文句点\! 惊叹号 效果 \ ` * _ {} [] ( ) # + - . ! 特殊字符 语法 1234567891011121314151617181920&amp;copy; 版权 &amp;reg; 注册商标&amp;trade; 商标&amp;nbsp; 空格&amp;amp; 和号&amp;quot; 引号&amp;apos; 撇号&amp;lt; 小于号&amp;gt; 大于号&amp;ne; 不等号&amp;le; 小于等于&amp;ge; 大于等于&amp;cent; 分&amp;pound; 磅&amp;euro; 欧元&amp;yen; 元&amp;sect; 节&amp;times; 乘号&amp;divide; 除号&amp;plusmn; 正负号 效果 &copy; &reg; &trade; &nbsp; &amp; &quot; &apos; &lt; &gt; &ne; &le; &ge; &cent; &pound; &euro; &yen; &sect; &times; &divide; &plusmn; 附: HTML特殊字符编码对照表[传送门]https://www.jb51.net/onlineread/htmlchar.htm]]></content>
      <categories>
        <category>Typora</category>
      </categories>
      <tags>
        <tag>markdown</tag>
        <tag>Typora</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo error log]]></title>
    <url>%2Fhexo%2Ferror-log%2Fck0xy270u002gksv77y2shkit.html</url>
    <content type="text"><![CDATA[搭建 hexo，在执行 hexo deploy 后,出现 error deployer not found:github 的错误 hexo 更新到3.0之后，deploy的type 的github需要改成gitnpm install hexo-deployer-git –save 改了之后执行，然后再部署]]></content>
      <categories>
        <category>hexo</category>
        <category>error log</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown 教程]]></title>
    <url>%2Fmarkdown%2Fck0xy26se000uksv7povvdlda.html</url>
    <content type="text"><![CDATA[概览Markdown 是一种标记语言（轻量级的、可用纯文本编写）;Markdown 诞生于2004年，由约翰·格鲁伯（John Gruber）创建；Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式。Markdown 编写的文档后缀为 .md, .markdown。 宗旨Markdown 的目标是实现「易读易写」。 应用Markdown 能被使用来撰写电子书，如：Gitbook。 当前许多网站都广泛使用 Markdown 来撰写帮助文档或是用于论坛上发表消息。例如：GitHub、简书、reddit、Diaspora、Stack Exchange、OpenStreetMap 、SourceForge等。 编辑器Markdown编辑器目前颇多，可参考以下链接进行选择。 [传送门] https://blog.csdn.net/qq_36759224/article/details/82229243 区块元素段落和换行Markdown段落由一个或多个连续的文本行组成。Markdown换行由两个及已上的空格加回车实现。 标题Markdown 支持两种标题的语法，类Setext 和 Atx形式。 使用 = 和 - 标记一级和二级标题（类Setext）12345我展示的是一级标题=================我展示的是二级标题----------------- 注：任何数量的 = 和 - 都可以有效果。 使用 # 号标记 1-6 级标题（类Atx）123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 区块引用 BlockquotesMarkdown 标记区块引用是在每行的最前面加上 &gt; ，如下： 123456&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,&gt; consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.&gt; Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.&gt; &gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse&gt; id sem consectetuer libero luctus adipiscing. 或在整个段落的第一行最前面加上 &gt; ： 123456&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.&gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisseid sem consectetuer libero luctus adipiscing. 区块引用可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的 &gt; ： 12345 This is the first level of quoting.&gt;&gt; &gt; This is nested blockquote.&gt;&gt; Back to the first level. 引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等： 12345678&gt; ## 这是一个标题。&gt; &gt; 1. 这是第一行列表项。&gt; 2. 这是第二行列表项。&gt; &gt; 给出一些例子代码：&gt; &gt; return shell_exec(&quot;echo $input | $markdown_script&quot;); 列表Markdown支持有序列表和无序列表。 无序列表无序列表使用星号、加号或是减号作为列表标记： 123* 无序列表+ 无序列表- 无序列表 有序列表有序列表则使用数字接着一个英文句点，然后加至少一个空格： 1231. Bird2. McHale3. Parish 注：列表上的数字不会影响输出的 HTML 结果 代码区块 Markdown 实现代码区块只要简单地缩进 4 个空格或是 1 个制表符就可以； 一个代码区块会一直持续到没有缩进的那一行（或是文件结尾）。 在代码区块里面， &amp; 、 &lt; 和 &gt; 会自动转成 HTML 实体。 代码区块中，一般的 Markdown 语法不会被转换，像是星号便只是星号。 分割线在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。 123***---___ 区段元素链接Markdown 支持两种形式的链接语法： 行内式和参考式两种形式。 不管是哪一种，链接文字都是用 [方括号] 来标记。 行内式建立一个行内式的链接，只要在方块括号后面紧接着圆括号并插入网址链接即可，如果你还想要加上链接的title文字，只要在网址后面，用双引号把title文字包起来即可 12This is [an example](http://example.com/ &quot;Title&quot;) inline link.[This link](http://example.net/) has no title attribute. 如果你是要链接到同样主机的资源，你可以使用相对路径： 1See my [About](/about/) page for details. 参考式在链接文字的括号后面再接上另一个方括号，而在第二个方括号里面要填入用以辨识链接的标记： 1This is [an example][id] reference-style link. 你也可以选择性地在两个方括号中间加上一个空格： 1This is [an example] [id] reference-style link. 接着，在文件的任意处，你可以把这个标记的链接内容定义出来： 1[id]: http://example.com/ "Optional Title Here" 隐式链接标记功能让你可以省略指定链接标记，这种情形下，链接标记会视为等同于链接文字，要用隐式链接标记只要在链接文字后面加上一个空的方括号，如果你要让 “Google” 链接到 google.com，你可以简化成： 1[Google][] 然后定义链接内容： 1[Google]: http://google.com/ 注：链接辨别标签可以有字母、数字、空白和标点符号，但是并不区分大小写，链接的定义可以放在文件中的任何一个地方，我比较偏好直接放在链接出现段落的后面，你也可以把它放在文件最后面，就像是注解一样。 强调Markdown 使用星号（*）和底线（_）作为标记强调字词的符号。 1234*single asterisks*_single underscores_**double asterisks**__double underscores__ 注：用什么符号开启标签，就要用什么符号结束，强调可以出现在文字中间，但如果*和_两边都有空白的话，它们将被当成普通的符号。 如果要在文字前后直接插入普通的星号或底线，你可以用反斜线： 1\*this text is surrounded by literal asterisks\* 代码如果要标记一小段行内代码，你可以用反引号把它包起来（`），例如： 1Use the `printf()` function. 如果要在代码区段内插入反引号，你可以用多个反引号来开启和结束代码区段： 1``There is a literal backtick (`) here.`` 代码区段的起始和结束端都可以放入一个空白，起始端后面一个，结束端前面一个，这样你就可以在区段的一开始就插入反引号： 123A single backtick in a code span: `` ` ``A backtick-delimited string in a code span: `` `foo` `` 在代码区段内，&amp; 和方括号都会被自动地转成 HTML 实体，这使得插入 HTML 原始码变得很容易，Markdown 会把下面这段： 图片Markdown 使用一种和链接很相似的语法来标记图片，同样也允许两种样式： 行内式和参考式。 行内式12![Alt text](/path/to/img.jpg)![Alt text](/path/to/img.jpg &quot;Optional title&quot;) 详细叙述如下： 一个惊叹号 ! 接着一个方括号，里面放上图片的替代文字 接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上 选择性的 ‘title’ 文字。 参考式1![Alt text][id] 「id」是图片参考的名称，图片参考的定义方式则和连结参考一样： 1[id]: url/to/image "Optional title attribute" 到目前为止， Markdown 还没有办法指定图片的宽高，如果你需要的话，你可以使用普通的&lt;img&gt; 标签。 其它反斜杠Markdown 可以利用反斜杠来插入一些在语法中有其它意义的符号，例如：如果你想要用星号加在文字旁边的方式来做出强调效果（但不用 标签），你可以在星号的前面加上反斜杠： 1\*literal asterisks\* Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号： 123456789101112\ 反斜线` 反引号* 星号_ 底线&#123;&#125; 花括号[] 方括号() 括弧# 井字号+ 加号- 减号. 英文句点! 惊叹号 自动链接Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用方括号包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如： 1&lt;http://example.com/&gt; Markdown 会转为： 1&lt;a href="http://example.com/"&gt;http://example.com/&lt;/a&gt; 邮址的自动链接也很类似，只是 Markdown 会先做一个编码转换的过程，把文字字符转成 16 进位码的 HTML 实体，这样的格式可以糊弄一些不好的邮址收集机器人，例如： 1&lt;address@example.com&gt; Markdown 会转成： 1234&lt;a href="mailto:address@example.com"&gt;address@example.com&lt;/a&gt; 在浏览器里面，这段字串（其实是 &lt;a href=&quot;mailto:address@example.com&quot;&gt;address@example.com&lt;/a&gt;）会变成一个可以点击的「address@example.com」链接。 感谢http://www.markdown.cn/#acknowledgement]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git 教程]]></title>
    <url>%2Fgit%2Fck0xy27c6004fksv70jb1xwe5.html</url>
    <content type="text"><![CDATA[git 简介git是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。 Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。 Git 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。 Git 与 SVN 区别 Git 是分布式的，SVN 不是：这是 Git 和其它非分布式的版本控制系统，例如 SVN，CVS 等，最核心的区别。 Git 把内容按元数据方式存储，而 SVN 是按文件：所有的资源控制系统都是把文件的元信息隐藏在一个类似 .svn、.cvs 等的文件夹里。 Git 分支和 SVN 的分支不同：分支在 SVN 中一点都不特别，其实它就是版本库中的另外一个目录。 Git 没有一个全局的版本号，而 SVN 有：目前为止这是跟 SVN 相比 Git 缺少的最大的一个特征。 Git 的内容完整性要优于 SVN：Git 的内容存储使用的是 SHA-1 哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏。 Git 安装配置Git 目前支持 Linux/Unix、Solaris、Mac和 Windows 平台上运行。 Git 各平台安装包下载地址为：http://git-scm.com/downloads Linux 平台上安装首先安装依赖库 curl，zlib，openssl，expat，libiconv 等。 Debian/Ubuntu123456$ apt-get install libcurl4-gnutls-dev libexpat1-dev gettext libz-dev libssl-dev$ apt-get install git$ git --versiongit version 1.8.1.2 Centos/RedHat123456$ yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel$ yum -y install git-core$ git --versiongit version 1.7.1 源码安装官网下载源码包来安装，下载地址：https://git-scm.com/download 安装指定系统的依赖包： 12345########## Centos/RedHat ##########$ yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel########## Debian/Ubuntu ##########$ apt-get install libcurl4-gnutls-dev libexpat1-dev gettext libz-dev libssl-dev 解压安装下载的源码包： 1234$ tar -zxf git-1.7.2.2.tar.gz$ cd git-1.7.2.2$ make perfix=/usr/local all$ sudo mkdir prefix=/usr/local install Windows 平台上安装下载安装包：https://gitforwindows.org/ 安装流程与普通软件无异 完成安装之后，在开始菜单里找到”Git”-&gt;”Git Bash”，会弹出 Git 命令窗口，你可以在该窗口进行 Git 操作。 Mac 平台上安装下载安装包：http://sourceforge.net/projects/git-osx-installer/ Git 配置Git 提供了一个叫做 git config 的工具，专门用来配置或读取相应的工作环境变量。 这些环境变量，决定了 Git 在各个环节的具体工作方式和行为。这些变量可以存放在以下三个不同的地方： /etc/gitconfig 文件：系统中对所有用户都普遍适用的配置。若使用 git config 时用 --system 选项，读写的就是这个文件。 ~/.gitconfig 文件：用户目录下的配置文件只适用于该用户。若使用 git config 时用 --global 选项，读写的就是这个文件。 当前项目的 Git 目录中的配置文件（也就是工作目录中的 .git/config 文件）：这里的配置仅仅针对当前项目有效。每一个级别的配置都会覆盖上层的相同配置，所以 .git/config 里的配置会覆盖 /etc/gitconfig 中的同名变量。 在 Windows 系统上，Git 会找寻用户主目录下的 .gitconfig 文件。主目录即 $HOME 变量指定的目录，一般都是 C:\Documents and Settings$USER。 用户信息配置个人的用户名称和电子邮件地址 12$ git config --global user.name &quot;your_name&quot;$ git config --global user.email &quot;your_email&quot; 如果用了 –global 选项，那么更改的配置文件就是位于你用户主目录下的那个，以后你所有的项目都会默认使用这里配置的用户信息。 如果要在某个特定的项目中使用其他名字或者电邮，只要去掉 –global 选项重新配置即可，新的设定保存在当前项目的 .git/config 文件里 文本编辑器设置Git默认使用的文本编辑器, 一般可能会是 Vi 或者 Vim。如果你有其他偏好，比如 Emacs 的话，可以重新设置： 1$ git config --global core.editor emacs 差异分析工具还有一个比较常用的是，在解决合并冲突时使用哪种差异分析工具。比如要改用 vimdiff 的话： 1$ git config --global merge.tool vimdiff Git 可以理解 kdiff3，tkdiff，meld，xxdiff，emerge，vimdiff，gvimdiff，ecmerge，和 opendiff 等合并工具的输出信息。 查看配置信息要检查已有的配置信息，可以使用 git config –list 命令： 123456789101112131415$ git config --listcore.symlinks=falsecore.autocrlf=truecore.fscache=truecolor.diff=autocolor.status=autocolor.branch=autocolor.interactive=truehelp.format=htmlrebase.autosquash=truehttp.sslbackend=opensslhttp.sslcainfo=E:/Git/mingw64/ssl/certs/ca-bundle.crtcredential.helper=manageruser.name=yournameuser.email= emailname 直接查阅某个环境变量的设定，只要把特定的名字跟在后面即可 12$ git config user.nameyourname Git 工作流程 克隆 Git 资源作为工作目录 在克隆的资源上添加或修改文件 如果其他人修改了，也可以更新资源 在提交前查看修改 提交修改 修改完成后，如果发现错误，可以撤回并再次修改提交 Git 工作区、暂存区和版本库工作区 就是你在电脑里能看到的目录，当前编辑的目录。 暂存区 英文叫stage, 或index。一般存放在 “.git目录下” 下的index文件（.git/index）中，所以我们把暂存区有时也叫作索引（index） 版本库 工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。 下面这个图展示了工作区、版本库中的暂存区和版本库之间的关系： 图中左侧为工作区，右侧为版本库。在版本库中标记为 “index” 的区域是暂存区（stage, index），标记为 “master” 的是 master 分支所代表的目录树 图中我们可以看出此时 “HEAD” 实际是指向 master 分支的一个”游标”。所以图示的命令中出现 HEAD 的地方可以用 master 来替换 图中的 objects 标识的区域为 Git 的对象库，实际位于 “.git/objects” 目录下，里面包含了创建的各种对象及内容 当对工作区修改（或新增）的文件执行 “git add” 命令时，暂存区的目录树被更新，同时工作区修改（或新增）的文件内容被写入到对象库中的一个新的对象中，而该对象的ID被记录在暂存区的文件索引中。 当执行提交操作（git commit）时，暂存区的目录树写到版本库（对象库）中，master 分支会做相应的更新。即 master 指向的目录树就是提交时暂存区的目录树。 当执行 “git reset HEAD” 命令时，暂存区的目录树会被重写，被 master 分支指向的目录树所替换，但是工作区不受影响。 当执行 “git rm –cached &lt;file&gt;“ 命令时，会直接从暂存区删除文件，工作区则不做出改变。 当执行 “git checkout .” 或者 “git checkout -- &lt;file&gt;“ 命令时，会用暂存区全部或指定的文件替换工作区的文件。这个操作很危险，会清除工作区中未添加到暂存区的改动。 当执行 “git checkout HEAD .“ 或者 “git checkout HEAD &lt;file&gt;“ 命令时，会用 HEAD 指向的 master 分支中的全部或者部分文件替换暂存区和以及工作区中的文件。这个命令也是极具危险性的，因为不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动。 Git 创建仓库git initGit 使用 git init 命令来初始化一个 Git 仓库，Git 的很多命令都需要在 Git 的仓库中运行，所以 git init 是使用 Git 的第一个命令。 在执行完成 git init 命令后，Git 仓库会生成一个 .git 目录，该目录包含了资源的所有元数据，其他的项目目录保持不变（不像 SVN 会在每个子目录生成 .svn 目录，Git 只在仓库的根目录生成 .git 目录）。 1$ git init [directory] git clone现有 Git 仓库中拷贝项目 123$ git clone &lt;repo&gt; [directory] &lt;repo&gt; Git 仓库 [directory] 本地目录 例： 12$ git clone git://github.com/schacon/grit.git # 默认下载到当前目录$ git clone git://github.com/schacon/grit.git mygrit # 下载到 mygrit 目录 Git 基本操作获取与创建项目命令git init1$ git init [directory] 例： 12345678910$ mkdir test$ cd test/$ git initInitialized empty Git repository in D:/Github/test/.git/$ ll -altotal 8drwxr-xr-x 1 Mr wang 197121 0 8月 27 06:34 ./drwxr-xr-x 1 Mr wang 197121 0 8月 27 06:33 ../drwxr-xr-x 1 Mr wang 197121 0 8月 27 06:34 .git/ git clone使用 git clone 拷贝一个 Git 仓库到本地，让自己能够查看该项目，或者进行修改。 如果你需要与他人合作一个项目，或者想要复制一个项目，看看代码，你就可以克隆那个项目,命令： 1$ git clone &lt;url&gt; [directory] 默认情况下，Git 会按照你提供的 URL 所指示的项目的名称创建你的本地项目目录。 通常就是该 URL 最后一个 / 之后的项目名称。如果你想要一个不一样的名字， 你可以在该命令后加上你想要的名称。 基本快照Git 的工作就是创建和保存你的项目的快照及与之后的快照进行对比。 git add添加文件到缓存 123456789101112131415161718# 新建文件 README exapmle.py$ touch README$ touch example.py$ lsexample.py README# 查看项目的当前状态$ git status -s?? README?? example.py# 添加文件到缓存$ git add README example.py# 再次查看项目的当前状态，新建的两个文件已经加到缓存$ git status -sA READMEA example.py 添加当前项目的所有文件 1$ git add . git status查看在上次提交之后是否有修改 12345678910$ git statusOn branch masterNo commits yetChanges to be committed: (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage) new file: README new file: example.py git diff显示已写入缓存与已修改但尚未写入缓存的改动的区别。git diff 有两个主要的应用场景。 尚未缓存的改动：git diff 查看已缓存的改动： git diff –cached 查看已缓存的与未缓存的所有改动：git diff HEAD 显示摘要而非整个 diff：git diff –stat git commit12$ git commit [-m &quot;commit message&quot;]$ git commit -a # 越过提交信息填写 git reset HEAD执行 git reset HEAD 以取消之前 git add 添加，但不希望包含在下一提交快照中的缓存 1$ git reset HEAD filename git rm要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除，然后提交。可以用以下命令完成此项工作 1$ git rm &lt;file&gt; 如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 -f 1$ git rm -f &lt;file&gt; 如果把文件从暂存区域移除，但仍然希望保留在当前工作目录中，换句话说，仅是从跟踪清单中删除，使用 –cached 选项即可 1$ git rm --cached &lt;file&gt; 不从工作区中删除文件 1$ git rm --cached filename 进入某个目录中，执行下面语句，会删除该目录下的所有文件和子目录 1$ git rm -r * git mv移动或重命名一个文件、目录、软连接 1$ git mv old_file new_file Git 分支管理几乎每一种版本控制系统都以某种形式支持分支。使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作。 有人把 Git 的分支模型称为必杀技特性，而正是因为它，将 Git 从版本控制系统家族里区分出来 创建分支命令1$ git branch &lt;branchname&gt; 切换分支命令1$ git checkout &lt;branchname&gt; 当你切换分支的时候，Git 会用该分支的最后提交的快照替换你的工作目录的内容， 所以多个分支不需要多个目录。 创建并切换分支1$ git checkout -b &lt;branchname&gt; 合并分支命令1$ git merge &lt;branchname&gt; 合并分支内容到当前分支 列出分支1$ git branch 删除分支1$ git branch -d &lt;branchname&gt; 合并冲突Git 查看提交历史查看详细提交历史记录 1$ git log 查看简洁提交历史记录 1$ git log --oneline 1234$ git log --oneline3672b71 (HEAD -&gt; master, test) change the test.txt9b6ac00 add test.txtfd6f625 first commit 查看历史中什么时候出现了分支、合并 1$ git log --graph Git 标签如果你达到一个重要的阶段，并希望永远记住那个特别的提交快照，你可以使用 git tag 给它打上标签。 比如说，我们想为我们的 runoob 项目发布一个”1.0”版本。 我们可以用 git tag -a v1.0 命令给最新一次提交打上（HEAD）”v1.0”的标签。 -a 选项意为”创建一个带注解的标签”。 不用 -a 选项也可以执行的，但它不会记录这标签是啥时候打的，谁打的，也不会让你添加个标签的注解。 推荐一直创建带注解的标签。 1$ git tag -a &lt;version&gt; [commit_id] 查看标签 1$ git tag 指定标签信息命令 1$ git tag -a &lt;tagname&gt; -m &quot;message&quot; PGP签名标签命令 1$ git tag -s &lt;tagname&gt; -m &quot;message&quot; Git 远程仓库(Github)添加远程库1$ git remote add &lt;shortname&gt; &lt;url&gt; Git 服务器搭建 安装Git 12$ yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel perl-devel$ yum install git 接下来我们 创建一个git用户组和用户，用来运行git服务： 12$ groupadd git$ useradd git -g git 创建证书登录 收集所有需要登录的用户的公钥，公钥位于id_rsa.pub文件中，把我们的公钥导入到/home/git/.ssh/authorized_keys文件里，一行一个。如果没有该文件创建它。 12345$ cd /home/git/$ mkdir .ssh$ chmod 755 .ssh$ touch .ssh/authorized_keys$ chmod 644 .ssh/authorized_keys 初始化Git仓库 首先我们选定一个目录作为Git仓库，假定是/home/gitrepo/runoob.git，在/home/gitrepo目录下输入命令： 1234567$ cd /home$ mkdir gitrepo$ chown git:git gitrepo/$ cd gitrepo$ git init --bare runoob.gitInitialized empty Git repository in /home/gitrepo/runoob.git/ 以上命令Git创建一个空仓库，服务器上的Git仓库通常都以.git结尾。然后，把仓库所属用户改为git： 1$ chown -R git:git runoob.git 克隆仓库 1234$ git clone git@192.168.45.4:/home/gitrepo/runoob.gitCloning into &apos;runoob&apos;...warning: You appear to have cloned an empty repository.Checking connectivity... done. 192.168.45.4 为 Git 所在服务器 ip ，你需要将其修改为你自己的 Git 服务 ip。这样我们的 Git 服务器安装就完成。 Reference[本文内容转载自] : https://www.runoob.com/git/git-tutorial.html]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
</search>
